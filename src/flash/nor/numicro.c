/***************************************************************************
 *   Copyright (C) 2011 by James K. Larson                                 *
 *   jlarson@pacifier.com                                                  *
 *                                                                         *
 *   Copyright (C) 2013 Cosmin Gorgovan                                    *
 *   cosmin [at] linux-geek [dot] org                                      *
 *                                                                         *
 *   Copyright (C) 2014 Pawel Si                                           *
 *   stawel+openocd@gmail.com                                              *
 *                                                                         *
 *   Copyright (C) 2015 Nemui Trinomius                                    *
 *   nemuisan_kawausogasuki@live.jp                                        *
 *                                                                         *
 *   Copyright (C) 2017 Zale Yu                                            *
 *   CYYU@nuvoton.com                                                      *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include "imp.h"
#include <helper/binarybuffer.h>
#include <target/algorithm.h>
#include <target/armv7m.h>
#include <target/cortex_m.h>

/* Nuvoton NuMicro register locations */
#define NUMICRO_SYS_BASE        0x50000000
#define NUMICRO_SYS_WRPROT      0x50000100
#define NUMICRO_SYS_IPRSTC1     0x50000008

#define NUMICRO_SYSCLK_BASE     0x50000200
#define NUMICRO_SYSCLK_PWRCON   0x50000200
#define NUMICRO_SYSCLK_CLKSEL0  0x50000210
#define NUMICRO_SYSCLK_CLKDIV   0x50000218
#define NUMICRO_SYSCLK_AHBCLK   0x50000204

#define NUMICRO_FLASH_BASE      0x5000C000
#define NUMICRO_FLASH_ISPCON    0x5000C000
#define NUMICRO_FLASH_ISPADR    0x5000C004
#define NUMICRO_FLASH_ISPDAT    0x5000C008
#define NUMICRO_FLASH_ISPCMD    0x5000C00C
#define NUMICRO_FLASH_ISPTRG    0x5000C010
#define NUMICRO_FLASH_CHEAT     0x5000C01C /* Undocumented isp register(may be cheat register) */

#define NUMICRO_SCS_BASE        0xE000E000
#define NUMICRO_SCS_AIRCR       0xE000ED0C
#define NUMICRO_SCS_DHCSR       0xE000EDF0
#define NUMICRO_SCS_DEMCR       0xE000EDFC
#define NUMICRO_CPUID           0xE000ED00

#define NUMICRO_APROM_BASE      0x00000000
#define NUMICRO_DATA_BASE       0x0001F000
#define NUMICRO_LDROM_BASE      0x00100000
#define NUMICRO_SPROM_BASE      0x00200000
#define NUMICRO_CONFIG_BASE     0x00300000

#define NUMICRO_CONFIG0         0x5000C000
#define NUMICRO_CONFIG1         0x5000C004

/* Command register bits */
#define PWRCON_OSC22M         (1 << 2)
#define PWRCON_XTL12M         (1 << 0)

#define IPRSTC1_CPU_RST       (1 << 1)
#define IPRSTC1_CHIP_RST      (1 << 0)

#define AHBCLK_ISP_EN         (1 << 2)
#define AHBCLK_SRAM_EN        (1 << 4)
#define AHBCLK_TICK_EN        (1 << 5)

#define ISPCON_ISPEN          (1 << 0)
#define ISPCON_BS_AP          (0 << 1)
#define ISPCON_BS_LP          (1 << 1)
#define ISPCON_BS_MASK        (1 << 1)
#define ISPCON_APUEN          (1 << 3)
#define ISPCON_CFGUEN         (1 << 4)
#define ISPCON_LDUEN          (1 << 5)
#define ISPCON_ISPFF          (1 << 6)

#define CONFIG0_LOCK_MASK     (1 << 1)

#define DHCSR_S_SDE           (1 << 20)

/* isp commands */
#define ISPCMD_READ           0x00
#define ISPCMD_WRITE          0x21
#define ISPCMD_ERASE          0x22
#define ISPCMD_CHIPERASE      0x26   /* Undocumented isp "Chip-Erase" command */
#define ISPCMD_READ_CID       0x0B
#define ISPCMD_READ_UID       0x04
#define ISPCMD_VECMAP         0x2E
#define ISPTRG_ISPGO          (1 << 0)

/* access unlock keys */
#define REG_KEY1              0x59
#define REG_KEY2              0x16
#define REG_KEY3              0x88
#define REG_LOCK              0x00

/* flash pagesizes */
#define NUMICRO_PAGESIZE        512
/* flash MAX banks */
#define NUMICRO_MAX_FLASH_BANKS 4
/* flash mask */
#define NUMICRO_TZ_MASK         0xEFFFFFFF
#define NUMICRO_SPROM_MASK      0x00000001
#define NUMICRO_SPROM_ISPDAT    0x55AA03

/* flash bank structs */
struct numicro_flash_bank_type {
	uint32_t base;
	uint32_t size;
};

/* part structs */
struct numicro_cpu_type {
	char *partname;
	uint32_t partid;
	unsigned int n_banks;
	struct numicro_flash_bank_type bank[NUMICRO_MAX_FLASH_BANKS];
};

/* If DataFlash size equals zero, it means the actual size depends on config settings. */
#define NUMICRO_BANKS_GENERAL(aprom_size, data_size, ldrom_size, config_size) \
	.n_banks = 4, \
	{{NUMICRO_APROM_BASE,  (aprom_size)}, \
	 {NUMICRO_DATA_BASE,   (data_size)}, \
	 {NUMICRO_LDROM_BASE,  (ldrom_size)}, \
	 {NUMICRO_CONFIG_BASE, (config_size)}}

static const struct numicro_cpu_type NuMicroParts[] = {
	/*PART Name*//*PART ID*/ /*Banks*/
	/* M031 */
	{"M031LIAAE", 0x01131100, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 8*1024, 12)},
	{"M032LIAAE", 0x01132100, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 8*1024, 12)},
	{"M031SIAAE", 0x01131110, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 8*1024, 12)},
	{"M032SIAAE", 0x01132110, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 8*1024, 12)},
	{"M031KIAAE", 0x01131140, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 8*1024, 12)},
	{"M032KIAAE", 0x01132140, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 8*1024, 12)},
	{"M031LG8AE", 0x01131600, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M032LG8AE", 0x01132600, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M031SG8AE", 0x01131610, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M032SG8AE", 0x01132610, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M031KG8AE", 0x01131640, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M032KG8AE", 0x01132640, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M031LG6AE", 0x01131601, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M032LG6AE", 0x01132601, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M031SG6AE", 0x01131611, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M032SG6AE", 0x01132611, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M031KG6AE", 0x01131641, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M032KG6AE", 0x01132641, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M031LE3AE", 0x01131E00, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"M031SE3AE", 0x01131E10, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"M031BTYE3AN", 0x01131E90, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"M032LE3AE", 0x01132E00, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"M032SE3AE", 0x01132E10, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"M032TD2AE", 0x01132DE0, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 2*1024, 12)},
	{"M032LD2AE", 0x01132D00, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 2*1024, 12)},
	{"M032TC2AE", 0x01132DE1, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M032LC2AE", 0x01132D01, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M030TD2AE", 0x01130DE0, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 2*1024, 12)},
	{"M030LD2AE", 0x01130D00, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 2*1024, 12)},
	{"M032FC1AE", 0x01132CB0, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M032EC1AE", 0x01132CA0, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M032TC1AE", 0x01132CE0, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M031TD2AE", 0x01131DE0, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 2*1024, 12)},
	{"M031BTYD2AN", 0x01131D90, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 2*1024, 12)},
	{"M031LD2AE", 0x01131D00, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 2*1024, 12)},
	{"M031LC2AE", 0x01131D01, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M031SD2AE", 0x01131D10, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 2*1024, 12)},
	{"M031SC2AE", 0x01131D11, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M031FC1AE", 0x01131CB0, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M031EC1AE", 0x01131CA0, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M031TC1AE", 0x01131CE0, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M031FB0AE", 0x01131BB0, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 2*1024, 12)},
	{"M031EB0AE", 0x01131BA0, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 2*1024, 12)},
	{"M031TB0AE", 0x01131BE0, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 2*1024, 12)},

	/* M051AN */
	{"M052LAN", 0x00005200, NUMICRO_BANKS_GENERAL(8*1024, 4*1024, 4*1024, 4)},
	{"M052ZAN", 0x00005203, NUMICRO_BANKS_GENERAL(8*1024, 4*1024, 4*1024, 4)},
	{"M054LAN", 0x00005400, NUMICRO_BANKS_GENERAL(16*1024, 4*1024, 4*1024, 4)},
	{"M054ZAN", 0x00005403, NUMICRO_BANKS_GENERAL(16*1024, 4*1024, 4*1024, 4)},
	{"M058LAN", 0x00005800, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 4)},
	{"M058ZAN", 0x00005803, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 4)},
	{"M0516LAN", 0x00005A00, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 4)},
	{"M0516ZAN", 0x00005A03, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 4)},

	/* M051BN */
	{"M052LBN", 0x10005200, NUMICRO_BANKS_GENERAL(8*1024, 4*1024, 4*1024, 4)},
	{"M052ZBN", 0x10005203, NUMICRO_BANKS_GENERAL(8*1024, 4*1024, 4*1024, 4)},
	{"M054LBN", 0x10005400, NUMICRO_BANKS_GENERAL(16*1024, 4*1024, 4*1024, 4)},
	{"M054ZBN", 0x10005403, NUMICRO_BANKS_GENERAL(16*1024, 4*1024, 4*1024, 4)},
	{"M058LBN", 0x10005800, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 4)},
	{"M058ZBN", 0x10005803, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 4)},
	{"M0516LBN", 0x10005A00, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 4)},
	{"M0516ZBN", 0x10005A03, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 4)},

	/* M051DN */
	{"M052LDN", 0x20005200, NUMICRO_BANKS_GENERAL(8*1024, 4*1024, 4*1024, 4)},
	{"M052ZDN", 0x20005203, NUMICRO_BANKS_GENERAL(8*1024, 4*1024, 4*1024, 4)},
	{"M054LDN", 0x20005400, NUMICRO_BANKS_GENERAL(16*1024, 4*1024, 4*1024, 4)},
	{"M054ZDN", 0x20005403, NUMICRO_BANKS_GENERAL(16*1024, 4*1024, 4*1024, 4)},
	{"M058LDN", 0x20005800, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 4)},
	{"M058ZDN", 0x20005803, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 4)},
	{"M0516LDN", 0x20005A00, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 4)},
	{"M0516ZDN", 0x20005A03, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 4)},

	/* M051DE */
	{"M052LDE", 0x30005200, NUMICRO_BANKS_GENERAL(8*1024, 4*1024, 4*1024, 4)},
	{"M052ZDE", 0x30005203, NUMICRO_BANKS_GENERAL(8*1024, 4*1024, 4*1024, 4)},
	{"M054LDE", 0x30005400, NUMICRO_BANKS_GENERAL(16*1024, 4*1024, 4*1024, 4)},
	{"M054ZDE", 0x30005403, NUMICRO_BANKS_GENERAL(16*1024, 4*1024, 4*1024, 4)},
	{"M058LDE", 0x30005800, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 4)},
	{"M058ZDE", 0x30005803, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 4)},
	{"M0516LDE", 0x30005A00, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 4)},
	{"M0516ZDE", 0x30005A03, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 4)},

	/* M0518 */
	{"M0518LC2AE", 0x10051803, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"M0518LD2AE", 0x10051800, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"M0518SC2AE", 0x10051813, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"M0518SD2AE", 0x10051810, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},

	/* M0519 */
	{"M0519VE3AE", 0x00051930, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 8*1024, 8)},
	{"M0519SE3AE", 0x00051920, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 8*1024, 8)},
	{"M0519SD3AE", 0x00051922, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 8*1024, 8)},
	{"M0519LE3AE", 0x00051900, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 8*1024, 8)},
	{"M0519LD3AE", 0x00051902, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 8*1024, 8)},

	/* M058S */
	{"M058SFAN", 0x00005818, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 4)},
	{"M058SZAN", 0x00005813, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 4)},
	{"M058SLAN", 0x00005810, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 4)},
	{"M058SSAN", 0x00005816, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 4)},

	/* M0564 */
	{"M0564LE4AE", 0x00C56405, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"M0564LG4AE", 0x00C56404, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M0564SE4AE", 0x00C56413, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"M0564SG4AE", 0x00C56412, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M0564VG4AE", 0x00C56431, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M0564KG4AE", 0x00C56440, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},

	/* M05641 */
	{"M05641SG4AE", 0x01256412, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M05641SE4AE", 0x01256413, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M05641LG4AE", 0x01256404, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M05641LE4AE", 0x01256405, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},

	/* MINI51AN */
	{"MINI51LAN", 0x00205100, NUMICRO_BANKS_GENERAL(4*1024, 0*1024, 2*1024, 8)},
	{"MINI51ZAN", 0x00205103, NUMICRO_BANKS_GENERAL(4*1024, 0*1024, 2*1024, 8)},
	{"MINI51TAN", 0x00205104, NUMICRO_BANKS_GENERAL(4*1024, 0*1024, 2*1024, 8)},
	{"MINI52LAN", 0x00205200, NUMICRO_BANKS_GENERAL(8*1024, 0*1024, 2*1024, 8)},
	{"MINI52ZAN", 0x00205203, NUMICRO_BANKS_GENERAL(8*1024, 0*1024, 2*1024, 8)},
	{"MINI52TAN", 0x00205204, NUMICRO_BANKS_GENERAL(8*1024, 0*1024, 2*1024, 8)},
	{"MINI54LAN", 0x00205400, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 2*1024, 8)},
	{"MINI54ZAN", 0x00205403, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 2*1024, 8)},
	{"MINI54TAN", 0x00205404, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 2*1024, 8)},

	{"MINI51XLAE", 0x00505100, NUMICRO_BANKS_GENERAL(4*1024, 0*1024, 2*1024, 8)},
	{"MINI51XZAE", 0x00505102, NUMICRO_BANKS_GENERAL(4*1024, 0*1024, 2*1024, 8)},
	{"MINI52XLAE", 0x00505200, NUMICRO_BANKS_GENERAL(8*1024, 0*1024, 2*1024, 8)},
	{"MINI52XZAE", 0x00505203, NUMICRO_BANKS_GENERAL(8*1024, 0*1024, 2*1024, 8)},
	{"MINI54XLAE", 0x00505400, NUMICRO_BANKS_GENERAL(35*512, 0*1024, 2*1024, 8)},
	{"MINI54XZAE", 0x00505403, NUMICRO_BANKS_GENERAL(35*512, 0*1024, 2*1024, 8)},
	{"MINI54XFHC", 0x00505406, NUMICRO_BANKS_GENERAL(35*512, 0*1024, 2*1024, 8)},

	/* MINI51DE */
	{"MINI51LDE", 0x20205100, NUMICRO_BANKS_GENERAL(4*1024, 0*1024, 2*1024, 8)},
	{"MINI51QDE", 0x20205101, NUMICRO_BANKS_GENERAL(4*1024, 0*1024, 2*1024, 8)},
	{"MINI51ZDE", 0x20205103, NUMICRO_BANKS_GENERAL(4*1024, 0*1024, 2*1024, 8)},
	{"MINI51TDE", 0x20205104, NUMICRO_BANKS_GENERAL(4*1024, 0*1024, 2*1024, 8)},
	{"MINI51FDE", 0x20205105, NUMICRO_BANKS_GENERAL(4*1024, 0*1024, 2*1024, 8)},
	{"MINI52LDE", 0x20205200, NUMICRO_BANKS_GENERAL(8*1024, 0*1024, 2*1024, 8)},
	{"MINI52QDE", 0x20205201, NUMICRO_BANKS_GENERAL(8*1024, 0*1024, 2*1024, 8)},
	{"MINI52ZDE", 0x20205203, NUMICRO_BANKS_GENERAL(8*1024, 0*1024, 2*1024, 8)},
	{"MINI52TDE", 0x20205204, NUMICRO_BANKS_GENERAL(8*1024, 0*1024, 2*1024, 8)},
	{"MINI52FDE", 0x20205205, NUMICRO_BANKS_GENERAL(8*1024, 0*1024, 2*1024, 8)},
	{"MINI54LDE", 0x20205400, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 2*1024, 8)},
	{"MINI54QDE", 0x20205401, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 2*1024, 8)},
	{"MINI54ZDE", 0x20205403, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 2*1024, 8)},
	{"MINI54TDE", 0x20205404, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 2*1024, 8)},
	{"MINI54FDE", 0x20205405, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 2*1024, 8)},

	/* MINI55 */
	{"MINI55LDE", 0x00505500, NUMICRO_BANKS_GENERAL(35*512, 0*1024, 2*1024, 8)},
	{"MINI55ZDE", 0x00505503, NUMICRO_BANKS_GENERAL(35*512, 0*1024, 2*1024, 8)},
	{"MINI55TDE", 0x00505504, NUMICRO_BANKS_GENERAL(35*512, 0*1024, 2*1024, 8)},

	/* MINI58 */
	{"MINI58LDE", 0x00A05800, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 5*512, 12)},
	{"MINI58QDE", 0x00A05801, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 5*512, 12)},
	{"MINI58ZDE", 0x00A05803, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 5*512, 12)},
	{"MINI58TDE", 0x00A05804, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 5*512, 12)},
	{"MINI58FDE", 0x00A05805, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 5*512, 12)},

	/* NANO100AN */
	{"NANO100ZC2AN", 0x00110029, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"NANO100ZD2AN", 0x00110028, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO100ZD3AN", 0x00110027, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO100LC2AN", 0x00110025, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"NANO100LD2AN", 0x00110019, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO100LD3AN", 0x00110018, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO100SC2AN", 0x00110023, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"NANO100SD2AN", 0x00110016, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO100SD3AN", 0x00110015, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO100VD2AN", 0x00110013, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO100VD3AN", 0x00110012, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO120ZC2AN", 0x00112029, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"NANO120ZD2AN", 0x00112028, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO120ZD3AN", 0x00112027, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO120LC2AN", 0x00112025, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"NANO120LD2AN", 0x00112019, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO120LD3AN", 0x00112018, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO120SC2AN", 0x00112023, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"NANO120SD2AN", 0x00112016, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO120SD3AN", 0x00112015, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO120VD2AN", 0x00112013, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO120VD3AN", 0x00112012, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},

	/* NANO100BN */
	{"NANO100LC2BN", 0x00110043, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"NANO100LD2BN", 0x0011003F, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO100LD3BN", 0x0011003E, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO100LE3BN", 0x00110036, NUMICRO_BANKS_GENERAL(123*1024, 0*1024, 4*1024, 8)},
	{"NANO100SC2BN", 0x00110042, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"NANO100SD2BN", 0x0011003D, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO100SD3BN", 0x0011003C, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO100SE3BN", 0x00110034, NUMICRO_BANKS_GENERAL(123*1024, 0*1024, 4*1024, 8)},
	{"NANO100KC2BN", 0x00110040, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO100KD2BN", 0x00110039, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO100KD3BN", 0x00110038, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO100KE3BN", 0x00110030, NUMICRO_BANKS_GENERAL(123*1024, 0*1024, 4*1024, 8)},
	{"NANO100NE3BN", 0x00110044, NUMICRO_BANKS_GENERAL(123*1024, 0*1024, 4*1024, 8)},
	{"NANO100ND3BN", 0x00110045, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO100ND2BN", 0x00110046, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO100WE3BN", 0x00110047, NUMICRO_BANKS_GENERAL(123*1024, 0*1024, 4*1024, 8)},
	{"NANO110SC2BN", 0x00111042, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"NANO110SD2BN", 0x0011103D, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO110SD3BN", 0x0011103C, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO110SE3BN", 0x00111034, NUMICRO_BANKS_GENERAL(123*1024, 0*1024, 4*1024, 8)},
	{"NANO110RC2BN", 0x00111043, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"NANO110RD2BN", 0x00111044, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO110RD3BN", 0x00111045, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO110KC2BN", 0x00111040, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"NANO110KD2BN", 0x00111039, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO110KD3BN", 0x00111038, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO110KE3BN", 0x00111030, NUMICRO_BANKS_GENERAL(123*1024, 0*1024, 4*1024, 8)},
	{"NANO120LC2BN", 0x00112043, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"NANO120LD2BN", 0x0011203F, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO120LD3BN", 0x0011203E, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO120LE3BN", 0x00112036, NUMICRO_BANKS_GENERAL(123*1024, 0*1024, 4*1024, 8)},
	{"NANO120SC2BN", 0x00112042, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"NANO120SD2BN", 0x0011203D, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO120SD3BN", 0x0011203C, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO120SE3BN", 0x00112034, NUMICRO_BANKS_GENERAL(123*1024, 0*1024, 4*1024, 8)},
	{"NANO120KC2BN", 0x00112040, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"NANO120KD2BN", 0x00112039, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO120KD3BN", 0x00112038, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO120KE3BN", 0x00112030, NUMICRO_BANKS_GENERAL(123*1024, 0*1024, 4*1024, 8)},
	{"NANO130SC2BN", 0x00113042, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"NANO130SD2BN", 0x0011303D, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO130SD3BN", 0x0011303C, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO130SE3BN", 0x00113034, NUMICRO_BANKS_GENERAL(123*1024, 0*1024, 4*1024, 8)},
	{"NANO130KC2BN", 0x00113040, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"NANO130KD2BN", 0x00113039, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO130KD3BN", 0x00113038, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"NANO130KE3BN", 0x00113030, NUMICRO_BANKS_GENERAL(123*1024, 0*1024, 4*1024, 8)},

	/* NANO103 */
	{"Nano103SD3AE", 0x00110301, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"Nano103SD2AE", 0x00110302, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"Nano103SD1AE", 0x00110303, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"Nano103LD3AE", 0x00110304, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"Nano103LD2AE", 0x00110305, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"Nano103LD1AE", 0x00110306, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"Nano103ZD3AE", 0x00110307, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"Nano103ZD2AE", 0x00110308, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"Nano103ZD1AE", 0x00110309, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"Nano103SC3AE", 0x00110316, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 12)},
	{"Nano103SC2AE", 0x00110310, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 12)},
	{"Nano103SC1AE", 0x00110311, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 12)},
	{"Nano103LC3AE", 0x00110317, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 12)},
	{"Nano103LC2AE", 0x00110312, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 12)},
	{"Nano103LC1AE", 0x00110313, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 12)},
	{"Nano103ZC3AE", 0x00110318, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 12)},
	{"Nano103ZC2AE", 0x00110314, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 12)},
	{"Nano103ZC1AE", 0x00110315, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 12)},

	/* NANO112AN */
	{"NANO102ZB1AN", 0x00110202, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 4*1024, 8)},
	{"NANO102ZC2AN", 0x00110204, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"NANO102LB1AN", 0x00110206, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 4*1024, 8)},
	{"NANO102LC2AN", 0x00110208, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"NANO102SC2AN", 0x00110212, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"NANO112LB1AN", 0x00111202, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 4*1024, 8)},
	{"NANO112LC2AN", 0x00111204, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"NANO112SB1AN", 0x00111206, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 4*1024, 8)},
	{"NANO112SC2AN", 0x00111208, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"NANO112RB1AN", 0x00111210, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 4*1024, 8)},
	{"NANO112RC2AN", 0x00111212, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"NANO112VC2AN", 0x00111216, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},

	/* NUC029 */
	{"NUC029LAN", 0x00295A00, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 4)},
	{"NUC029TAN", 0x00295804, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 4)},

	{"NUC029FAE", 0x00295415, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 2*1024, 8)},
	{"NUC029TAE", 0x30295804, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},

	{"NUC029CIG1", 0x00295824, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC029ZAN", 0x00295A03, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 4)},
	{"NUC029LDE", 0x00295A30, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC029SDE", 0x00295A31, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC029LEE", 0x00295B40, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 8*1024, 8)},
	{"NUC029SEE", 0x00295B41, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 8*1024, 8)},
	{"NUC029KGE", 0x00295C52, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"NUC029LGE", 0x00295C50, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"NUC029SGE", 0x00295C51, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},

	/* NUC100AN */
	{"NUC100LD3AN", 0x00010003, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100LE3AN", 0x00010000, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC100RD3AN", 0x00010012, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100RE3AN", 0x00010009, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC100VD2AN", 0x00010022, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100VD3AN", 0x00010021, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100VE3AN", 0x00100018, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC120LD3AN", 0x00012003, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120LE3AN", 0x00120000, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC120RD3AN", 0x00012012, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120RE3AN", 0x00012009, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC120VD2AN", 0x00012022, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120VD3AN", 0x00012021, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120VE3AN", 0x00012018, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},

	/* NUC100BN */
	{"NUC100LC1BN", 0x10010008, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC100LD1BN", 0x10010005, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100LD2BN", 0x10010004, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100RC1BN", 0x10010017, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC100RD1BN", 0x10010014, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100RD2BN", 0x10010013, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120LC1BN", 0x10012008, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC120LD1BN", 0x10012005, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120LD2BN", 0x10012004, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120RC1BN", 0x10012017, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC120RD1BN", 0x10012014, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120RD2BN", 0x10012013, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},

	/* NUC100CN */
	{"NUC130LC1CN", 0x20013008, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC130LD2CN", 0x20013004, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC130LE3CN", 0x20013000, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC130RC1CN", 0x20013017, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC130RD2CN", 0x20013013, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC130RE3CN", 0x20013009, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC130VE3CN", 0x20013018, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC140LC1CN", 0x20014008, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC140LD2CN", 0x20014004, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC140LE3CN", 0x20014000, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC140RC1CN", 0x20014017, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC140RD2CN", 0x20014013, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC140RE3CN", 0x20014009, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC140VE3CN", 0x20014018, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},

	/* NUC100DN */
	{"NUC100LC1DN", 0x30010008, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC100LD1DN", 0x30010005, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100LD2DN", 0x30010004, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100LD3DN", 0x30010003, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100LE3DN", 0x30010000, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC100RC1DN", 0x30010017, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC100RD1DN", 0x30010014, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100RD2DN", 0x30010013, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100RD3DN", 0x30010012, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100RE3DN", 0x30010009, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC100VD2DN", 0x30010022, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100VD3DN", 0x30010021, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100VE3DN", 0x30010018, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC100VE3DE", 0x40010018, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC120LC1DN", 0x30012008, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC120LD1DN", 0x30012005, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120LD2DN", 0x30012004, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120LD2DE", 0x40012004, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120LD3DN", 0x30012003, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120LE3DN", 0x30012000, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC120RC1DN", 0x30012035, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC120RD1DN", 0x30012032, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120RD2DN", 0x30012031, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120RD3DN", 0x30012030, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120RE3DN", 0x30012027, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC120VD2DN", 0x30012022, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120VD3DN", 0x30012021, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120VE3DN", 0x30012018, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},

	/* NUC121 */
	{"NUC121WC2AE", 0x00012180, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 9*512, 12)},
	{"NUC121Y25CN", 0x00012160, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 9*512, 12)},
	{"NUC121ZC2AE", 0x00012145, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 9*512, 12)},
	{"NUC121LC2AE", 0x00012125, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 9*512, 12)},
	{"NUC121SC2AE", 0x00012105, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 9*512, 12)},
	{"NUC125ZC2AE", 0x00012545, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 9*512, 12)},
	{"NUC125LC2AE", 0x00012525, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 9*512, 12)},
	{"NUC125SC2AE", 0x00012505, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 9*512, 12)},

	/* NUC122 */
	{"NUC122ZC1AN", 0x00012235, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024,4)},
	{"NUC122ZD2AN", 0x00012231, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024,4)},
	{"NUC122LC1AN", 0x00012208, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024,4)},
	{"NUC122LD2AN", 0x00012204, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024,4)},
	{"NUC122SC1AN", 0x00012226, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024,4)},
	{"NUC122SD2AN", 0x00012222, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024,4)},

	/* NUC123 */
	{"NUC123ZC2AN1", 0x00012345, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC123ZD4AN0", 0x00012355, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC123LC2AN1", 0x00012325, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC123LD4AN0", 0x00012335, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC123SC2AN1", 0x00012305, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC123SD4AN0", 0x00012315, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC123ZC2AE1", 0x10012345, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC123ZD4AE0", 0x10012355, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC123LC2AE1", 0x10012325, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC123LD4AE0", 0x10012335, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC123SC2AE1", 0x10012305, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC123SD4AE0", 0x10012315, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},

	/* NUC126 */
	{"NUC126NE4AE", 0x00C05206, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"NUC126LE4AE", 0x00C05205, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"NUC126LG4AE", 0x00C05204, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"NUC126SE4AE", 0x00C05213, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"NUC126SG4AE", 0x00C05212, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"NUC126VG4AE", 0x00C05231, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"NUC126KG4AE", 0x00C05230, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},

	/* NUC1261 */
	{"NUC1261SG4AE", 0x01205212, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"NUC1261SE4AE", 0x01205213, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"NUC1261LG4AE", 0x01205204, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"NUC1261LE4AE", 0x01205205, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"NUC1261NE4AE", 0x01205206, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},

	/* NUC131AE */
	{"NUC131LC2AE", 0x10013103, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC131LD2AE", 0x10013100, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC131SC2AE", 0x10013113, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC131SD2AE", 0x10013110, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},

	/* NUC1311 */
	{"NUC1311LD2AE", 0x11413100, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},

	/* NUC200/220AN */
	{"NUC200LC2AN", 0x00020007, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC200LD2AN", 0x00020004, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC200LE3AN", 0x00020000, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC200SC2AN", 0x00020034, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC200SD2AN", 0x00020031, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC200SE3AN", 0x00020027, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC200VE3AN", 0x00020018, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC220LC2AN", 0x00022007, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC220LD2AN", 0x00022004, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC220LE3AN", 0x00022000, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC220SC2AN", 0x00022034, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC220SD2AN", 0x00022031, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC220SE3AN", 0x00022027, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC220VE3AN", 0x00022018, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC220LE3AE", 0x40022000, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},

	/* NUC230/240AE */
	{"NUC230RC1AE", 0x40013017, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 8*1024, 8)},
	{"NUC230LC2AE", 0x10023007, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 8*1024, 8)},
	{"NUC230LD2AE", 0x10023004, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 8*1024, 8)},
	{"NUC230LE3AE", 0x10023000, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 8*1024, 8)},
	{"NUC230SC2AE", 0x10023034, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 8*1024, 8)},
	{"NUC230SD2AE", 0x10023031, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 8*1024, 8)},
	{"NUC230SE3AE", 0x10023027, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 8*1024, 8)},
	{"NUC230VE3AE", 0x10023018, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 8*1024, 8)},
	{"NUC240LC2AE", 0x10024007, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 8*1024, 8)},
	{"NUC240LD2AE", 0x10024004, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 8*1024, 8)},
	{"NUC240LE3AE", 0x10024000, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 8*1024, 8)},
	{"NUC240SC2AE", 0x10024034, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 8*1024, 8)},
	{"NUC240SD2AE", 0x10024031, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 8*1024, 8)},
	{"NUC240SE3AE", 0x10024027, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 8*1024, 8)},
	{"NUC240VE3AE", 0x10024018, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 8*1024, 8)},

	/* NUC2201 */
	{"NUC2201LE3AE", 0x20024000, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 8*1024, 8)},
	{"NUC2201SE3AE", 0x20024027, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 8*1024, 8)},

	/* M451 */
	{"M451VG6AE", 0x00845130, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M451VE6AE", 0x00845131, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M451RG6AE", 0x00845120, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M451RE6AE", 0x00845121, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M451LG6AE", 0x00845100, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M451LE6AE", 0x00845101, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M451VD3AE", 0x00945130, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M451VC3AE", 0x00945131, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M451RD3AE", 0x00945120, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M451RC3AE", 0x00945121, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M451SD3AE", 0x00945110, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M451SC3AE", 0x00945111, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M451LD3AE", 0x00945100, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M451LC3AE", 0x00945101, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M451YD3AE", 0x009451F0, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M451YC3AE", 0x009451F1, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M452VG6AE", 0x00845230, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M452VE6AE", 0x00845231, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M452RG6AE", 0x00845220, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M452RE6AE", 0x00845221, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M452SG6AE", 0x00845210, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M452SE6AE", 0x00845211, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M452LG6AE", 0x00845200, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M452LE6AE", 0x00845201, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M452VD3AE", 0x00945230, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M452VC3AE", 0x00945231, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M452RD3AE", 0x00945220, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M452RC3AE", 0x00945221, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M452SD3AE", 0x00945210, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M452SC3AE", 0x00945211, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M452LD3AE", 0x00945200, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M452LC3AE", 0x00945201, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M452YD3AE", 0x009452F0, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M452YC3AE", 0x009452F1, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M453VG6AE", 0x00845330, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M453VE6AE", 0x00845331, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M453RG6AE", 0x00845320, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M453RE6AE", 0x00845321, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M453LG6AE", 0x00845300, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M453LE6AE", 0x00845301, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M453VD3AE", 0x00945330, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M453VC3AE", 0x00945331, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M453RD3AE", 0x00945320, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M453RC3AE", 0x00945321, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M453SD3AE", 0x00945310, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M453SC3AE", 0x00945311, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M453LD3AE", 0x00945300, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M453LC3AE", 0x00945301, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M453YD3AE", 0x009453F0, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M453YC3AE", 0x009453F1, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M451MRG6AE", 0x00845020, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M451MRE6AE", 0x00845021, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M451MLG6AE", 0x00845000, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M451MLE6AE", 0x00845001, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M451MRD3AE", 0x00945020, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M451MRC3AE", 0x00945021, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M451MSD3AE", 0x00945010, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M451MSC3AE", 0x00945011, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M451MLD3AE", 0x00945000, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M451MLC3AE", 0x00945001, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M4LEDLG6AE", 0x00845700, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M4LEDLE6AE", 0x00845701, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M4LEDRG6AE", 0x00845720, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M4LEDRE6AE", 0x00845721, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M4TKLE6AE", 0x00845401, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M4TKLG6AE", 0x00845400, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M4TKRE6AE", 0x00845421, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M4TKRG6AE", 0x00845420, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M4TKVE6AE", 0x00845431, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M4TKVG6AE", 0x00845430, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},

	/* M4521 */
	{"M4521RE6AE", 0x00E45220, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M4521RD6AE", 0x00E45221, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"M4521SE6AE", 0x00E45210, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M4521SD6AE", 0x00E45211, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"M4521LE6AE", 0x00E45200, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M4521LD6AE", 0x00E45201, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},

	/* NUC442_472 */
	{"NUC442RG8AE", 0x00044212, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 16*1024, 8)},
	{"NUC442RI8AE", 0x00044210, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 16*1024, 8)},
	{"NUC442VG8AE", 0x00044209, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 16*1024, 8)},
	{"NUC442VI8AE", 0x00044207, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 16*1024, 8)},
	{"NUC442KG8AE", 0x00044206, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 16*1024, 8)},
	{"NUC442KI8AE", 0x00044204, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 16*1024, 8)},
	{"NUC442JG8AE", 0x00044203, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 16*1024, 8)},
	{"NUC442JI8AE", 0x00044201, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 16*1024, 8)},
	{"NUC472VG8AE", 0x00047212, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 16*1024, 8)},
	{"NUC472VI8AE", 0x00047210, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 16*1024, 8)},
	{"NUC472KG8AE", 0x00047209, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 16*1024, 8)},
	{"NUC472KI8AE", 0x00047207, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 16*1024, 8)},
	{"NUC472JG8AE", 0x00047206, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 16*1024, 8)},
	{"NUC472JI8AE", 0x00047204, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 16*1024, 8)},
	{"NUC472HG8AE", 0x00047203, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 16*1024, 8)},
	{"NUC472HI8AE", 0x00047201, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 16*1024, 8)},

	/* M480 */
	{"M481KIDAE", 0x00D48140, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M481KGAAE", 0x00D48141, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M481SIDAE", 0x00D48110, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M481SGAAE", 0x00D48111, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M481LIDAE", 0x00D48100, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M481LGAAE", 0x00D48101, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M481ZIDAE", 0x00D481E0, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M481ZGAAE", 0x00D481E1, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M481ZGDAE", 0x00D481E2, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M482JIDAE", 0x00D48250, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M482JGAAE", 0x00D48251, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M482KIDAE", 0x00D48240, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M482KGAAE", 0x00D48241, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M482VIDAE", 0x00D48230, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M482VGAAE", 0x00D48231, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M482SIDAE", 0x00D48210, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M482SGAAE", 0x00D48211, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M482SIDAE3O", 0x00D48212, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M482LIDAE", 0x00D48200, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M482LGAAE", 0x00D48201, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M482ZIDAE", 0x00D482E0, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M483JIDAE", 0x00D48350, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M483JGAAE", 0x00D48351, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M483KIDAE", 0x00D48340, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M483KGAAE", 0x00D48341, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M483VIDAE", 0x00D48330, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M483VGAAE", 0x00D48331, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M483SIDAE", 0x00D48310, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M483SGAAE", 0x00D48311, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M483LIDAE", 0x00D48300, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M483LGAAE", 0x00D48301, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M484KIDAE", 0x00D48440, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M484KGAAE", 0x00D48441, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M484SIDAE", 0x00D48410, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M484SGAAE", 0x00D48411, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M484SIDAE2U", 0x00D48412, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M484SGAAE2U", 0x00D48413, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M485JIDAE", 0x00D48550, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M485JGAAE", 0x00D48551, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M485KIDAE", 0x00D48540, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M485KGAAE", 0x00D48541, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M485VIDAE", 0x00D48530, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M485VGAAE", 0x00D48531, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M485OIDAE", 0x00D48580, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M485OGAAE", 0x00D48581, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M485SIDAE", 0x00D48510, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M485SGAAE", 0x00D48511, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M485LIDAE", 0x00D48500, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M485ZIDAE", 0x00D485E0, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M486JIDAE", 0x00D48650, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M486KIDAE", 0x00D48640, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M487JIDAE", 0x00D48750, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M487JGAAE", 0x00D48751, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M487KIDAE", 0x00D48740, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M487KGAAE", 0x00D48741, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M487SIDAE", 0x00D48710, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M487SGAAE", 0x00D48711, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M480TEST", 0x00D480FF, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	/* M480LD */
	{"M481SGCAE", 0x01348110, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M481SG8AE", 0x01348111, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M481SG8AE2A", 0x01348115, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M481LGCAE", 0x01348100, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M481LG8AE", 0x01348101, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M481ZGCAE", 0x013481E0, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M481ZG8AE", 0x013481E1, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M482KGCAE", 0x01348240, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M482KG8AE", 0x01348241, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M482SGCAE", 0x01348210, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M482SG8AE", 0x01348211, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M482LGCAE", 0x01348200, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M482LG8AE", 0x01348201, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M482ZGCAE", 0x013482E0, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M482ZG8AE", 0x013482E1, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M483KGCAE", 0x01348340, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M483KG8AE", 0x01348341, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M483SGCAE", 0x01348310, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M483SG8AE", 0x01348311, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M483KGCAE2A", 0x01348344, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M483KG8AE2A", 0x01348345, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M483SGCAE2A", 0x01348314, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M483SG8AE2A", 0x01348315, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},

	/* M479 */
	{"M479SG8AE", 0x01347911, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M479LG8AE", 0x01347901, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M479NG8AE", 0x01347991, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},

	/* NUC505 */
	{"NUC505", 0x00550505, NUMICRO_BANKS_GENERAL(0x1000000, 0*1024, 0*1024, 0)},

	/* M251 */
	{"M252FC2AE", 0x00F252B0, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"M252EC2AE", 0x00F252A1, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"M252ZC2AE", 0x00F252E2, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"M251FC2AE", 0x00F251B0, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"M251EC2AE", 0x00F251A1, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"M251ZC2AE", 0x00F251E2, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"M251FB2AE", 0x00F251B3, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 4*1024, 8)},
	{"M251EB2AE", 0x00F251A4, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 4*1024, 8)},
	{"M251ZB2AE", 0x00F251E5, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 4*1024, 8)},
	{"M251SD2AE", 0x00F25110, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"M251LD2AE", 0x00F25101, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"M251ZD2AE", 0x00F251C2, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"M251SC2AE", 0x00F25113, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"M251LC2AE", 0x00F25104, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"M252SD2AE", 0x00F25210, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"M252LD2AE", 0x00F25201, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"M252ZD2AE", 0x00F252C2, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"M252SC2AE", 0x00F25213, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"M252LC2AE", 0x00F25204, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"M252KG6AE", 0x00F25240, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M252SG6AE", 0x00F25211, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M252LG6AE", 0x00F25202, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M251KG6AE", 0x00F25140, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M251SG6AE", 0x00F25111, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M251LG6AE", 0x00F25102, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},

	{"M252KE3AE", 0x00F25243, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M252SE3AE", 0x00F25214, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M252LE3AE", 0x00F25205, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M251KE3AE", 0x00F25143, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M251SE3AE", 0x00F25114, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M251LE3AE", 0x00F25105, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},

	/* M2351 */
	{"M2351XXXX1", 0x00082340, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M2351XXXX2", 0x10008234, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M2351KIAAE", 0x00235100, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M2351SIAAE", 0x00235101, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M2351CIAAE", 0x00235102, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M2351ZIAAE", 0x00235103, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M2353SIAAE", 0x00235300, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},

	/* M2354 */
	{"M2354TEST", 0x00235500, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},

	/* M261 */
	{"M261ZIAAE", 0x00261000, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M261SIAAE", 0x00261001, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M261KIAAE", 0x00261002, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M262ZIAAE", 0x00262000, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M262SIAAE", 0x00262001, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M262KIAAE", 0x00262002, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M263ZIAAE", 0x00263000, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M263SIAAE", 0x00263001, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M263KIAAE", 0x00263002, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},

	{"UNKNOWN", 0x00000000, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
};

/* Private bank information for NuMicro. */
struct  numicro_flash_bank {
	struct working_area *write_algorithm;
	int probed;
	const struct numicro_cpu_type *cpu;
};

/* Private variables */
uint32_t m_pageSize = NUMICRO_PAGESIZE;
uint32_t m_addressMinusOffset = 0;
uint32_t m_M23SecureDebugState = 0; /* 0:Normal; 1:M23 and Secure Debug Enabled(S); 2:M23 and Secure Debug Disabled(NS) */
uint32_t m_flashInfo = 0; /* bit 0:SPROM exists; */
char *m_target_name = "";

/* Private methods */
static int numicro_get_arm_arch(struct target *target)
{
	struct armv7m_common *armv7m = target_to_armv7m(target);

	if (armv7m->arm.is_armv6m) {
		LOG_DEBUG("NuMicro arm architecture: armv6m");

		if (armv7m->arm.is_NUC_M0_FMC_MSB4) {
			m_addressMinusOffset = 0x10000000;
		}
		else {
			m_addressMinusOffset = 0;
		}

		m_M23SecureDebugState = 0;
	}
	else if (armv7m->arm.is_armv8m) {
		LOG_DEBUG("NuMicro arm architecture: armv8m");
		m_addressMinusOffset = 0x10000000;
		if (armv7m->arm.is_armv8mSecureExtend) {
			// M2351/M2354
			if (armv7m->arm.is_armv8mSecureInvasiveDebugAllowed) {
				m_M23SecureDebugState = 1;
			}
			else {
				m_M23SecureDebugState = 2;
			}
		}
		else {
			// M251
			m_M23SecureDebugState = 0;
		}

	}
	else {
		LOG_DEBUG("NuMicro arm architecture: armv7m");
		m_addressMinusOffset = 0x10000000;
		m_M23SecureDebugState = 0;
	}

	return ERROR_OK;
}

static int numicro_reg_unlock(struct target *target)
{
	uint32_t is_protected;
	int retval = ERROR_OK;

	/* Check to see if NUC is register unlocked or not */
	retval = target_read_u32(target, NUMICRO_SYS_WRPROT - m_addressMinusOffset, &is_protected);
	if (retval != ERROR_OK)
		return retval;

	LOG_DEBUG("protected = 0x%08" PRIx32 "", is_protected);
	if (is_protected == 0) {	/* means protected - so unlock it */
		/* unlock flash registers */
		retval = target_write_u32(target, NUMICRO_SYS_WRPROT - m_addressMinusOffset, REG_KEY1);
		if (retval != ERROR_OK)
			return retval;
		retval = target_write_u32(target, NUMICRO_SYS_WRPROT - m_addressMinusOffset, REG_KEY2);
		if (retval != ERROR_OK)
			return retval;
		retval = target_write_u32(target, NUMICRO_SYS_WRPROT - m_addressMinusOffset, REG_KEY3);
		if (retval != ERROR_OK)
			return retval;
	}
	/* Check that unlock worked */
	retval = target_read_u32(target, NUMICRO_SYS_WRPROT - m_addressMinusOffset, &is_protected);
	if (retval != ERROR_OK)
		return retval;

	if (is_protected == 1) {	/* means unprotected */
		LOG_DEBUG("protection removed");
	}
	else {
		LOG_DEBUG("still protected!!");
	}

	return ERROR_OK;
}

static uint32_t numicro_fmc_cmd(struct target *target, uint32_t cmd, uint32_t addr, uint32_t wdata, uint32_t* rdata)
{
	uint32_t timeout, status;
	int retval = ERROR_OK;

	retval = target_write_u32(target, NUMICRO_FLASH_ISPCMD - m_addressMinusOffset, cmd);
	if (retval != ERROR_OK)
		return retval;

	retval = target_write_u32(target, NUMICRO_FLASH_ISPDAT - m_addressMinusOffset, wdata);
	if (retval != ERROR_OK)
		return retval;

	retval = target_write_u32(target, NUMICRO_FLASH_ISPADR - m_addressMinusOffset, addr);
	if (retval != ERROR_OK)
		return retval;

	retval = target_write_u32(target, NUMICRO_FLASH_ISPTRG - m_addressMinusOffset, ISPTRG_ISPGO);
	if (retval != ERROR_OK)
		return retval;

	/* Wait for busy to clear - check the GO flag */
	timeout = 100;
	for (;;) {
		retval = target_read_u32(target, NUMICRO_FLASH_ISPTRG - m_addressMinusOffset, &status);
		if (retval != ERROR_OK)
			return retval;
			LOG_DEBUG("status: 0x%" PRIx32 "", status);
		if ((status & (ISPTRG_ISPGO)) == 0)
			break;
		if (timeout-- <= 0) {
			LOG_DEBUG("timed out waiting for flash");
			return ERROR_FAIL;
		}
		busy_sleep(1);	/* can use busy sleep for short times. */
	}

	retval = target_read_u32(target, NUMICRO_FLASH_ISPDAT - m_addressMinusOffset, rdata);
	if (retval != ERROR_OK)
		return retval;

	return ERROR_OK;
}

/* NuMicro Program-LongWord Microcodes */
static const uint8_t numicro_M0_flash_write_code[] = {
	/* Params:
	 * r0 - workarea buffer / result
	 * r1 - target address
	 * r2 - wordcount
	 * Clobbered:
	 * r4 - tmp
	 * r5 - tmp
	 * r6 - tmp
	 * r7 - tmp
	 */

	/* .L1: */
	/* for(register uint32_t i=0;i<wcount;i++){ */
	0x04, 0x1C,				/* mov    r4, r0          */
	0x00, 0x23,				/* mov    r3, #0          */
	/* .L2: */
	0x0D, 0x1A,				/* sub    r5, r1, r0      */
	0x67, 0x19,				/* add    r7, r4, r7      */
	0x93, 0x42,				/* cmp	  r3, r2		  */
	0x0C, 0xD0,				/* beq    .L7             */
	/* .L4: */
	/* NUMICRO_FLASH_ISPADR = faddr; */
	0x08, 0x4E,				/* ldr	r6, .L8           */
	0x37, 0x60,				/* str	r7, [r6]          */
	/* NUMICRO_FLASH_ISPDAT = *pLW; */
	0x80, 0xCC,				/* ldmia	r4!, {r7}     */
	0x08, 0x4D,				/* ldr	r5, .L8+4         */
	0x2F, 0x60,				/* str	r7, [r5]		  */
	/* faddr += 4; */
	/* pLW++; */
	/*  Trigger write action  */
	/* NUMICRO_FLASH_ISPTRG = ISPTRG_ISPGO; */
	0x08, 0x4D,				/* ldr	r5, .L8+8         */
	0x01, 0x26,				/* mov	r6, #1            */
	0x2E, 0x60,				/* str	r6, [r5]          */
	/* .L3: */
	/* while((NUMICRO_FLASH_ISPTRG & ISPTRG_ISPGO) == ISPTRG_ISPGO){}; */
	0x2F, 0x68,				/* ldr	r7, [r5]          */
	0xFF, 0x07,				/* lsl	r7, r7, #31       */
	0xFC, 0xD4,				/* bmi	.L3               */

	0x01, 0x33,				/* add	r3, r3, #1        */
	0xEE, 0xE7,				/* b	.L2               */
	/* .L7: */
	/* return (NUMICRO_FLASH_ISPCON & ISPCON_ISPFF); */
	0x05, 0x4B,				/* ldr	r3, .L8+12        */
	0x18, 0x68,				/* ldr	r0, [r3]          */
	0x40, 0x21,				/* mov	r1, #64           */
	0x08, 0x40,				/* and	r0, r1            */
	/* .L9: */
	0x00, 0xBE,				/* bkpt    #0             */
	/* .L8: */
	0x04, 0xC0, 0x00, 0x50,/* .word	1342226436    */
	0x08, 0xC0, 0x00, 0x50,/* .word	1342226440    */
	0x10, 0xC0, 0x00, 0x50,/* .word	1342226448    */
	0x00, 0xC0, 0x00, 0x50 /* .word	1342226432    */
};

static const uint8_t numicro_M4_M23_flash_write_code[] = {
	/* Params:
	* r0 - workarea buffer / result
	* r1 - target address
	* r2 - wordcount
	* Clobbered:
	* r4 - tmp
	* r5 - tmp
	* r6 - tmp
	* r7 - tmp
	*/

	/* .L1: */
	/* for(register uint32_t i=0;i<wcount;i++){ */
	0x04, 0x1C,				/* mov    r4, r0          */
	0x00, 0x23,				/* mov    r3, #0          */
	/* .L2: */
	0x0D, 0x1A,				/* sub    r5, r1, r0      */
	0x67, 0x19,				/* add    r7, r4, r7      */
	0x93, 0x42,				/* cmp	  r3, r2		  */
	0x0C, 0xD0,				/* beq    .L7             */
	/* .L4: */
	/* NUMICRO_FLASH_ISPADR = faddr; */
	0x08, 0x4E,				/* ldr	r6, .L8           */
	0x37, 0x60,				/* str	r7, [r6]          */
	/* NUMICRO_FLASH_ISPDAT = *pLW; */
	0x80, 0xCC,				/* ldmia	r4!, {r7}     */
	0x08, 0x4D,				/* ldr	r5, .L8+4         */
	0x2F, 0x60,				/* str	r7, [r5]		  */
	/* faddr += 4; */
	/* pLW++; */
	/*  Trigger write action  */
	/* NUMICRO_FLASH_ISPTRG = ISPTRG_ISPGO; */
	0x08, 0x4D,				/* ldr	r5, .L8+8         */
	0x01, 0x26,				/* mov	r6, #1            */
	0x2E, 0x60,				/* str	r6, [r5]          */
	/* .L3: */
	/* while((NUMICRO_FLASH_ISPTRG & ISPTRG_ISPGO) == ISPTRG_ISPGO){}; */
	0x2F, 0x68,				/* ldr	r7, [r5]          */
	0xFF, 0x07,				/* lsl	r7, r7, #31       */
	0xFC, 0xD4,				/* bmi	.L3               */

	0x01, 0x33,				/* add	r3, r3, #1        */
	0xEE, 0xE7,				/* b	.L2               */
	/* .L7: */
	/* return (NUMICRO_FLASH_ISPCON & ISPCON_ISPFF); */
	0x05, 0x4B,				/* ldr	r3, .L8+12        */
	0x18, 0x68,				/* ldr	r0, [r3]          */
	0x40, 0x21,				/* mov	r1, #64           */
	0x08, 0x40,				/* and	r0, r1            */
	/* .L9: */
	0x00, 0xBE,				/* bkpt    #0             */
	/* .L8: */
	0x04, 0xC0, 0x00, 0x40,/* .word	0x4000C004    */
	0x08, 0xC0, 0x00, 0x40,/* .word	0x4000C008    */
	0x10, 0xC0, 0x00, 0x40,/* .word	0x4000C010    */
	0x00, 0xC0, 0x00, 0x40 /* .word	0x4000C000    */
};

static const uint8_t numicro_M2351_NS_flash_write_code[] = {
	/* Params:
	* r0 - workarea buffer / result
	* r1 - target address
	* r2 - wordcount
	* Clobbered:
	* r4 - tmp
	* r5 - tmp
	* r6 - tmp
	* r7 - tmp
	*/
	0xb0, 0xb5, 0x92, 0xb0, 0x13, 0x46, 0x0c, 0x46, 0x05, 0x46, 0x10, 0x90, 0x0f,
	0x91, 0x0e, 0x92, 0x00, 0x20, 0x0d, 0x90, 0x06, 0x93, 0x05, 0x94, 0x04, 0x95,
	0x00, 0xf0, 0xb3, 0xf8, 0x0f, 0x99, 0x01, 0x22, 0x12, 0x07, 0x11, 0x43, 0x0f,
	0x91, 0x0e, 0x99, 0x89, 0x00, 0x0d, 0x91, 0x0f, 0x99, 0x09, 0x0f, 0x01, 0x29,
	0x03, 0x90, 0x3b, 0xd1, 0xff, 0xe7, 0xff, 0xe7, 0x0d, 0x98, 0x00, 0x28, 0x35,
	0xdb, 0xff, 0xe7, 0x0d, 0x98, 0x40, 0xf6, 0x00, 0x01, 0x88, 0x42, 0x15, 0xdb,
	0xff, 0xe7, 0x0f, 0x98, 0x10, 0x99, 0x40, 0xf6, 0x00, 0x02, 0x00, 0xf0, 0x9a,
	0xf8, 0x00, 0x28, 0x03, 0xd0, 0xff, 0xe7, 0x01, 0x20, 0x11, 0x90, 0x8a, 0xe0,
	0x0f, 0x98, 0x40, 0xf6, 0x00, 0x01, 0x40, 0x18, 0x0f, 0x90, 0x10, 0x98, 0x40,
	0x18, 0x10, 0x90, 0x10, 0xe0, 0x0d, 0x98, 0x00, 0x28, 0x0c, 0xd0, 0xff, 0xe7,
	0x0f, 0x98, 0x10, 0x99, 0x0d, 0x9a, 0x00, 0xf0, 0x82, 0xf8, 0x00, 0x28, 0x03,
	0xd0, 0xff, 0xe7, 0x01, 0x20, 0x11, 0x90, 0x72, 0xe0, 0xff, 0xe7, 0xff, 0xe7,
	0xff, 0xe7, 0x0d, 0x98, 0x4f, 0xf6, 0x00, 0x01, 0xcf, 0xf6, 0xff, 0x71, 0x40,
	0x18, 0x0d, 0x90, 0xc6, 0xe7, 0x63, 0xe0, 0x0f, 0x98, 0x01, 0x21, 0x49, 0x05,
	0x88, 0x42, 0x24, 0xd1, 0xff, 0xe7, 0x10, 0x98, 0x0a, 0x90, 0x00, 0x20, 0x0c,
	0x90, 0xff, 0xe7, 0x0c, 0x98, 0x0e, 0x99, 0x89, 0x08, 0x88, 0x42, 0x18, 0xd2,
	0xff, 0xe7, 0x0a, 0x98, 0x0c, 0x99, 0x89, 0x00, 0x42, 0x18, 0x40, 0x58, 0x51,
	0x68, 0x93, 0x68, 0xd2, 0x68, 0x02, 0x92, 0x1a, 0x46, 0x02, 0x9b, 0x00, 0xf0,
	0x58, 0xf8, 0x00, 0x28, 0x03, 0xd0, 0xff, 0xe7, 0x01, 0x20, 0x11, 0x90, 0x42,
	0xe0, 0xff, 0xe7, 0x0c, 0x98, 0x00, 0x1d, 0x0c, 0x90, 0xe1, 0xe7, 0x38, 0xe0,
	0x0f, 0x98, 0x41, 0xf2, 0x00, 0x01, 0xc0, 0xf2, 0x31, 0x01, 0x88, 0x42, 0x23,
	0xd1, 0xff, 0xe7, 0x10, 0x98, 0x08, 0x90, 0x08, 0x98, 0x01, 0x68, 0x42, 0x68,
	0x80, 0x68, 0x01, 0x90, 0x08, 0x46, 0x11, 0x46, 0x01, 0x9a, 0x00, 0xf0, 0x3e,
	0xf8, 0x09, 0x90, 0x09, 0x98, 0x00, 0x28, 0x11, 0xd0, 0xff, 0xe7, 0x08, 0x98,
	0xc0, 0x68, 0x07, 0x90, 0x09, 0x98, 0x07, 0x99, 0x08, 0x60, 0x00, 0xf0, 0x37,
	0xf8, 0x07, 0x99, 0x48, 0x60, 0x00, 0xf0, 0x39, 0xf8, 0x07, 0x99, 0x88, 0x60,
	0x01, 0x20, 0x11, 0x90, 0x12, 0xe0, 0x0c, 0xe0, 0x0f, 0x98, 0x40, 0xf6, 0x00,
	0x01, 0xc0, 0xf2, 0x21, 0x01, 0x88, 0x42, 0x04, 0xd1, 0xff, 0xe7, 0x00, 0xf0,
	0x2f, 0xf8, 0x00, 0x90, 0xff, 0xe7, 0xff, 0xe7, 0xff, 0xe7, 0xff, 0xe7, 0x00,
	0x20, 0x11, 0x90, 0xff, 0xe7, 0x11, 0x98, 0x12, 0xb0, 0x00, 0xbe, 0x03, 0xb4,
	0x01, 0x48, 0x01, 0x90, 0x01, 0xbd, 0x19, 0x7e, 0x80, 0x00, 0x03, 0xb4, 0x01,
	0x48, 0x01, 0x90, 0x01, 0xbd, 0x39, 0x7e, 0x80, 0x00, 0x03, 0xb4, 0x01, 0x48,
	0x01, 0x90, 0x01, 0xbd, 0x29, 0x7f, 0x80, 0x00, 0x03, 0xb4, 0x01, 0x48, 0x01,
	0x90, 0x01, 0xbd, 0x31, 0x7f, 0x80, 0x00, 0x03, 0xb4, 0x01, 0x48, 0x01, 0x90,
	0x01, 0xbd, 0x79, 0x7e, 0x80, 0x00, 0x03, 0xb4, 0x01, 0x48, 0x01, 0x90, 0x01,
	0xbd, 0x69, 0x7e, 0x80, 0x00, 0x03, 0xb4, 0x01, 0x48, 0x01, 0x90, 0x01, 0xbd,
	0x19, 0x7f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static const uint8_t numicro_M2351_NS_flash_erase_code[] = {
	/* Params:
	* r0 - target address
	*/

	0x80, 0xb5, 0x84, 0xb0, 0x01, 0x46, 0x03, 0x90, 0x01, 0x91, 0x00, 0xf0, 0x27,
	0xf8, 0x03, 0x99, 0x01, 0x22, 0x13, 0x07, 0x19, 0x43, 0x03, 0x91, 0x03, 0x99,
	0x4f, 0xf6, 0x00, 0x03, 0xcf, 0xf6, 0xff, 0x73, 0x19, 0x40, 0x03, 0x91, 0x03,
	0x99, 0x0f, 0x23, 0x1b, 0x05, 0x19, 0x40, 0x52, 0x05, 0x91, 0x42, 0x00, 0x90,
	0x0a, 0xd1, 0xff, 0xe7, 0x03, 0x98, 0x40, 0xf2, 0x00, 0x01, 0xcf, 0xf6, 0xe0,
	0x71, 0x40, 0x18, 0x00, 0xf0, 0x10, 0xf8, 0x02, 0x90, 0x04, 0xe0, 0x03, 0x98,
	0x00, 0xf0, 0x11, 0xf8, 0x02, 0x90, 0xff, 0xe7, 0x02, 0x98, 0x04, 0xb0, 0x00,
	0xbe, 0x03, 0xb4, 0x01, 0x48, 0x01, 0x90, 0x01, 0xbd, 0x19, 0x7e, 0x80, 0x00,
	0x03, 0xb4, 0x01, 0x48, 0x01, 0x90, 0x01, 0xbd, 0x21, 0x7e, 0x80, 0x00, 0x03,
	0xb4, 0x01, 0x48, 0x01, 0x90, 0x01, 0xbd, 0x41, 0x7e, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x00,
};

static const uint8_t numicro_M2351_NS_init_info_code[] = {
	/* Params:
	* r0 - address to place info (In fact, the actual location will be the address plus one word)
	*/
	0xb0, 0xb5, 0x8e, 0xb0, 0x13, 0x46, 0x0c, 0x46, 0x05, 0x46, 0x0d, 0x90, 0x0c,
	0x91, 0x0b, 0x92, 0x06, 0x93, 0x05, 0x94, 0x04, 0x95, 0x00, 0xf0, 0xa5, 0xf8,
	0x03, 0x90, 0x00, 0xf0, 0xa8, 0xf8, 0x09, 0x90, 0x09, 0x98, 0x0d, 0x99, 0x08,
	0x60, 0x0d, 0x98, 0x00, 0x1d, 0x0d, 0x90, 0x0d, 0x98, 0x00, 0x28, 0x00, 0xd1,
	0x82, 0xe0, 0x00, 0xf0, 0xa1, 0xf8, 0x09, 0x90, 0x09, 0x98, 0x0d, 0x99, 0x08,
	0x60, 0x0d, 0x98, 0x00, 0x1d, 0x0d, 0x90, 0x00, 0xf0, 0x9e, 0xf8, 0x09, 0x90,
	0x09, 0x98, 0x0d, 0x99, 0x08, 0x60, 0x0d, 0x98, 0x00, 0x1d, 0x0d, 0x90, 0x00,
	0x20, 0x02, 0x90, 0x00, 0xf0, 0x99, 0xf8, 0x09, 0x90, 0x09, 0x98, 0x0d, 0x99,
	0x08, 0x60, 0x0d, 0x98, 0x00, 0x1d, 0x0d, 0x90, 0x01, 0x20, 0x00, 0xf0, 0x8f,
	0xf8, 0x09, 0x90, 0x09, 0x98, 0x0d, 0x99, 0x08, 0x60, 0x0d, 0x98, 0x00, 0x1d,
	0x0d, 0x90, 0x02, 0x20, 0x00, 0xf0, 0x85, 0xf8, 0x09, 0x90, 0x09, 0x98, 0x0d,
	0x99, 0x08, 0x60, 0x0d, 0x98, 0x00, 0x1d, 0x0d, 0x90, 0x00, 0xf0, 0x82, 0xf8,
	0x09, 0x90, 0x09, 0x98, 0x0d, 0x99, 0x08, 0x60, 0x0d, 0x98, 0x00, 0x1d, 0x0d,
	0x90, 0x00, 0xf0, 0x7f, 0xf8, 0x09, 0x90, 0x09, 0x98, 0x0d, 0x99, 0x08, 0x60,
	0x0d, 0x98, 0x00, 0x1d, 0x0d, 0x90, 0x00, 0xf0, 0x7c, 0xf8, 0x80, 0xb2, 0x09,
	0x90, 0x09, 0x98, 0x00, 0x04, 0x01, 0x90, 0x00, 0xf0, 0x7b, 0xf8, 0x80, 0xb2,
	0x01, 0x99, 0x01, 0x43, 0x09, 0x91, 0x09, 0x98, 0x0d, 0x99, 0x08, 0x60, 0x0d,
	0x98, 0x00, 0x1d, 0x0d, 0x90, 0x02, 0x98, 0x0a, 0x90, 0xff, 0xe7, 0x0a, 0x98,
	0x03, 0x28, 0x25, 0xd8, 0xff, 0xe7, 0x00, 0x20, 0x09, 0x90, 0x0a, 0x98, 0x00,
	0xf0, 0x6b, 0xf8, 0x00, 0x28, 0x12, 0xd0, 0xff, 0xe7, 0x0a, 0x98, 0x08, 0xa9,
	0x07, 0xaa, 0x00, 0xf0, 0x69, 0xf8, 0x09, 0x90, 0x09, 0x98, 0x00, 0x28, 0x07,
	0xd1, 0xff, 0xe7, 0x08, 0x98, 0x00, 0x02, 0x07, 0xa9, 0x09, 0x78, 0x08, 0x43,
	0x09, 0x90, 0xff, 0xe7, 0xff, 0xe7, 0x09, 0x98, 0x0d, 0x99, 0x08, 0x60, 0x0d,
	0x98, 0x00, 0x1d, 0x0d, 0x90, 0xff, 0xe7, 0x0a, 0x98, 0x40, 0x1c, 0x0a, 0x90,
	0xd6, 0xe7, 0xff, 0xe7, 0x00, 0x20, 0x0e, 0xb0, 0x00, 0xbe, 0xc0, 0x46, 0xc0,
	0x46, 0xc0, 0x46, 0xc0, 0x46, 0xc0, 0x46, 0xc0, 0x46, 0xc0, 0x46, 0x80, 0xb5,
	0x82, 0xb0, 0x01, 0x46, 0x01, 0x90, 0x00, 0x91, 0x00, 0xf0, 0x45, 0xf8, 0x00,
	0x20, 0x02, 0xb0, 0x00, 0xbe, 0x03, 0xb4, 0x01, 0x48, 0x01, 0x90, 0x01, 0xbd,
	0x19, 0x7e, 0x80, 0x00, 0x03, 0xb4, 0x01, 0x48, 0x01, 0x90, 0x01, 0xbd, 0x89,
	0x7e, 0x80, 0x00, 0x03, 0xb4, 0x01, 0x48, 0x01, 0x90, 0x01, 0xbd, 0xf1, 0x7e,
	0x80, 0x00, 0x03, 0xb4, 0x01, 0x48, 0x01, 0x90, 0x01, 0xbd, 0xe1, 0x7e, 0x80,
	0x00, 0x03, 0xb4, 0x01, 0x48, 0x01, 0x90, 0x01, 0xbd, 0x01, 0x7f, 0x80, 0x00,
	0x03, 0xb4, 0x01, 0x48, 0x01, 0x90, 0x01, 0xbd, 0x81, 0x7e, 0x80, 0x00, 0x03,
	0xb4, 0x01, 0x48, 0x01, 0x90, 0x01, 0xbd, 0x79, 0x7e, 0x80, 0x00, 0x03, 0xb4,
	0x01, 0x48, 0x01, 0x90, 0x01, 0xbd, 0x71, 0x7e, 0x80, 0x00, 0x03, 0xb4, 0x01,
	0x48, 0x01, 0x90, 0x01, 0xbd, 0x69, 0x7e, 0x80, 0x00, 0x03, 0xb4, 0x01, 0x48,
	0x01, 0x90, 0x01, 0xbd, 0x91, 0x7e, 0x80, 0x00, 0x03, 0xb4, 0x01, 0x48, 0x01,
	0x90, 0x01, 0xbd, 0x09, 0x7f, 0x80, 0x00, 0x03, 0xb4, 0x01, 0x48, 0x01, 0x90,
	0x01, 0xbd, 0x11, 0x7f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static const uint32_t numicro_M2354_flash_algorithm_code[] = {
	0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
	0x9002b084, 0x92009101, 0x4820e7ff, 0x07c06800, 0xd0012800, 0xe7f8e7ff, 0x6801481d, 0x43112240,
	0x98026001, 0x6008491b, 0x491b9801, 0x98006008, 0xd1052800, 0x2000e7ff, 0x491843c0, 0xe0036008,
	0x49174816, 0xe7ff6001, 0x21014816, 0xf3bf6001, 0xe7ff8f6f, 0x6800480d, 0x280007c0, 0xe7ffd001,
	0x480be7f8, 0x06406800, 0xd5082800, 0x4808e7ff, 0x22406801, 0x60014311, 0x90032001, 0x2000e002,
	0xe7ff9003, 0xb0049803, 0x46c04770, 0x5000c040, 0x5000c000, 0x5000c00c, 0x5000c004, 0x5000c008,
	0x0055aa03, 0x5000c010, 0x9002b084, 0x92009101, 0x07002005, 0x28006800, 0xe7ffd103, 0x90032001,
	0x480fe01b, 0x60012159, 0x60012116, 0x60012188, 0x07c06800, 0xd1032800, 0x2001e7ff, 0xe00c9003,
	0x21494808, 0x68006001, 0xd1032800, 0x2001e7ff, 0xe0029003, 0x90032000, 0x9803e7ff, 0x4770b004,
	0x50000100, 0x5000c000, 0x9000b081, 0x4806e7ff, 0x07c06800, 0xd0012800, 0xe7f8e7ff, 0x21004803,
	0x46086001, 0x4770b001, 0x5000c040, 0x5000c000, 0xb082b580, 0x98019001, 0x070a2101, 0x90014390,
	0x4a0e9801, 0x90014010, 0x220f9801, 0x40100512, 0x42880549, 0xe7ffd107, 0x49099801, 0x90011840,
	0x90002001, 0x2000e002, 0xe7ff9000, 0x9a009901, 0xf7ff2022, 0xb002ff45, 0x46c0bd80, 0xfffff800,
	0xffe00000, 0xb084b580, 0x91019002, 0x90002000, 0x9800e7ff, 0x42889901, 0xe7ffd20f, 0x99009802,
	0x92001c4a, 0x58400089, 0xffc2f7ff, 0xd0032800, 0x2001e7ff, 0xe0039003, 0x2000e7eb, 0xe7ff9003,
	0xb0049803, 0x46c0bd80, 0x9002b084, 0x92009101, 0x1cc09801, 0x43882103, 0x98029001, 0x07092101,
	0x90024388, 0x4823e7ff, 0x07c06800, 0xd0012800, 0xe7f8e7ff, 0x68014820, 0x43112240, 0x481f6001,
	0x60012121, 0x9801e7ff, 0xd02c2800, 0x9802e7ff, 0x6008491b, 0x68009800, 0x6008491a, 0x2101481a,
	0xf3bf6001, 0xe7ff8f6f, 0x68004812, 0x280007c0, 0xe7ffd001, 0x4810e7f8, 0x06406800, 0xd5082800,
	0x480de7ff, 0x22406801, 0x60014311, 0x90032001, 0x9802e00c, 0x90021d00, 0x1d009800, 0x98019000,
	0x90011f00, 0x2000e7cf, 0xe7ff9003, 0xb0049803, 0x46c04770, 0x5000c040, 0x5000c000, 0x5000c00c,
	0x5000c004, 0x5000c008, 0x5000c010, 0x9003b084, 0x92019102, 0x1cc09802, 0x43882103, 0x98039002,
	0x07092101, 0x90004008, 0x43889803, 0xe7ff9003, 0x68004823, 0x280007c0, 0xe7ffd001, 0x4821e7f8,
	0x22406801, 0x60014311, 0x2100481f, 0xe7ff6001, 0x28009802, 0xe7ffd02e, 0x491c9803, 0x481c6008,
	0x60012101, 0x8f6ff3bf, 0x4815e7ff, 0x07c06800, 0xd0012800, 0xe7f8e7ff, 0x68004812, 0x28000640,
	0xe7ffd506, 0x6801480f, 0x43112240, 0xe0116001, 0x68004810, 0x68099901, 0xd0014288, 0xe009e7ff,
	0x1d009803, 0x98019003, 0x90011d00, 0x1f009802, 0xe7cd9002, 0x99009803, 0xb0044308, 0x46c04770,
	0x5000c040, 0x5000c000, 0x5000c00c, 0x5000c004, 0x5000c010, 0x5000c008, 0x00000000
};

static const uint32_t numicro_M480_flash_algorithm_code[] = {
	0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
	0x4603b530, 0x2164460c, 0x4dfe2059, 0xf04f6028, 0xf04f0016, 0xf8c54580, 0xf04f0100, 0xf8c50088,
	0xf04f0100, 0xf8d04080, 0xf0100100, 0xd1010f01, 0xbd302001, 0x680048f4, 0x0004f040, 0x4580f04f,
	0x0200f8c5, 0xf8d04628, 0xf0400204, 0xf8c50004, 0xbf000204, 0xf1a10008, 0xd1fb0101, 0x680048eb,
	0x0021f040, 0x60284de9, 0x69c04628, 0x0001f040, 0x462861e8, 0xf0106800, 0xd1010f01, 0xe7d82001,
	0x680048e2, 0x0040f040, 0x60284de0, 0xe7d02000, 0xbf004601, 0x690048dd, 0x0f01f010, 0x48dbd1fa,
	0xf0206800, 0x4ad90021, 0x46106010, 0xf02069c0, 0x61d00001, 0x47702000, 0xbf004601, 0x690048d3,
	0x0f01f010, 0x48d1d1fa, 0xf0406800, 0x4acf0040, 0x20226010, 0xf02160d0, 0x60500003, 0x1f00f5b1,
	0x48cbd101, 0x20016090, 0x61104ac8, 0x8f60f3bf, 0x48c6bf00, 0xf0106900, 0xd1fa0f01, 0x680048c3,
	0x0f40f010, 0x48c1d007, 0xf0406800, 0x4abf0040, 0x20016010, 0x20004770, 0x4601e7fc, 0x48bbbf00,
	0xf0106900, 0xd1fa0f01, 0x680048b8, 0x0040f040, 0x60104ab6, 0x60d02025, 0x60414610, 0x1f00f5b1,
	0x48b3d101, 0x20016090, 0x61104ab0, 0x8f60f3bf, 0x48aebf00, 0xf0106900, 0xd1fa0f01, 0x680048ab,
	0x0f40f010, 0x48a9d007, 0xf0406800, 0x4aa70040, 0x20016010, 0x20004770, 0xb570e7fc, 0x460d4604,
	0xe01a2300, 0x0023f854, 0x0c800480, 0x1ae8d10c, 0xd3092804, 0x0023f854, 0xffbff7ff, 0xd0010006,
	0xbd704630, 0xe0081d1b, 0x0023f854, 0xff84f7ff, 0xd0010006, 0xe7f44630, 0x42ab1c5b, 0x2000d3e2,
	0xb570e7ef, 0x460b4604, 0x22004615, 0xf1034629, 0xf020000f, 0xbf00030f, 0x6900488c, 0x0f01f010,
	0x488ad1fa, 0xf0406800, 0x4e880040, 0xf0246030, 0x6070000f, 0x60f02027, 0x1c524610, 0x0020f851,
	0x60304e84, 0xf1024610, 0xf8510201, 0x4e7f0020, 0x0084f8c6, 0xf1024610, 0xf8510201, 0x4e7e0020,
	0x46106030, 0x0201f102, 0x0020f851, 0x0604f106, 0xf04f6030, 0x4e750001, 0xf1a36130, 0xe0290310,
	0x4876bf00, 0xf0106800, 0xd1fa0f30, 0x1c524610, 0x0020f851, 0x60304e6f, 0xf1024610, 0xf8510201,
	0x4e6a0020, 0x0084f8c6, 0x486cbf00, 0xf0106800, 0xd1fa0fc0, 0x1c524610, 0x0020f851, 0x60304e66,
	0xf1024610, 0xf8510201, 0x4e600020, 0x008cf8c6, 0x0310f1a3, 0xd1d32b00, 0x485cbf00, 0xf0106900,
	0xd1fa0f01, 0xbd702000, 0x4603b510, 0xf0201cc8, 0xbf000103, 0x69004855, 0x0f01f010, 0x4853d1fa,
	0xf0406800, 0x4c510040, 0x20216020, 0xe01f60e0, 0x0003f023, 0x60604c4d, 0x60a06810, 0x61202001,
	0x8f60f3bf, 0x4849bf00, 0xf0106900, 0xd1fa0f01, 0x68004846, 0x0f40f010, 0x4844d007, 0xf0406800,
	0x4c420040, 0x20016020, 0x1d1bbd10, 0x1f091d12, 0xd1dd2900, 0xe7f72000, 0x47f0e92d, 0x460c4605,
	0xf04f4616, 0x46c20800, 0x4838bf00, 0xf0106900, 0xd1fa0f01, 0x68004835, 0x0040f040, 0x60084933,
	0xf0201ce0, 0xe02f0403, 0x0dc005e8, 0xf5b4d10c, 0xd3097f00, 0x7700f44f, 0x0208eb06, 0x46284639,
	0xff2ff7ff, 0xe0164682, 0x0dc005e8, 0x2c10d10b, 0xf024d309, 0xeb06070f, 0x46390208, 0xf7ff4628,
	0x4682ff20, 0x4627e007, 0x0208eb06, 0x46284639, 0xff8af7ff, 0x443d4682, 0x1be444b8, 0x0f00f1ba,
	0x2001d002, 0x87f0e8bd, 0xd1cd2c00, 0xe7f92000, 0x1ccbb510, 0x0103f023, 0x4b14bf00, 0xf013691b,
	0xd1fa0f01, 0x681b4b11, 0x0340f043, 0x60234c0f, 0x60e32300, 0xf020e033, 0x4c0c0303, 0x23006063,
	0x230160a3, 0xf3bf6123, 0xbf008f60, 0x691b4b07, 0x0f01f013, 0x4b05d1fa, 0xf013681b, 0xd0150f40,
	0xe00d4b02, 0x40000100, 0x40000200, 0x4000c000, 0x0055aa03, 0x4000c080, 0x4000c088, 0x4000c0c0,
	0xf043681b, 0x4c1a0340, 0xbd106023, 0x689b4b18, 0x42a36814, 0xe7f8d000, 0x1d121d00, 0x29001f09,
	0xbf00d1c9, 0xb510e7f1, 0x48114603, 0xf0106e00, 0xd00c0f02, 0x6503480e, 0x65826541, 0x4c0c2001,
	0xbf0065e0, 0x6e00480a, 0x0f01f010, 0x4808d1fa, 0xf0106e00, 0xd1010f04, 0xbd102002, 0x6e004804,
	0x0f02f010, 0x2001d001, 0x2000e7f7, 0x0000e7f5, 0x4000c000, 0x00000000
};

static const uint32_t numicro_NUC505_flash_algorithm_code[] = {
	0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
	0x4770ba40, 0x4770bac0, 0x0030ea4f, 0x00004770, 0x684a49ba, 0x0210f022, 0x1000ea42, 0x47706048,
	0x684a49b6, 0xd1fc07d2, 0x4207f44f, 0x6208600a, 0xf0406848, 0x60480001, 0x07c06848, 0x4770d1fc,
	0x684148ae, 0xd1fc07c9, 0x61e0f44f, 0x68416001, 0x0101f041, 0x68416041, 0xd1fc07c9, 0xb2c06900,
	0xb5004770, 0xf7ff2000, 0x2006ffd3, 0xffd8f7ff, 0xf85d2001, 0xe7cbeb04, 0x2000b500, 0xffc8f7ff,
	0xf7ff2005, 0xf7ffffcd, 0x07c0ffdb, 0x2001d1fb, 0xeb04f85d, 0xb500e7bc, 0xf7ff4603, 0x2000ffe2,
	0xffb6f7ff, 0xf7ff2020, 0xf3c3ffbb, 0xf7ff4007, 0xf3c3ffb7, 0xf7ff2007, 0xb2d8ffb3, 0xffb0f7ff,
	0xf7ff2001, 0xf85dffa5, 0xe7d5eb04, 0xf7ffb500, 0x2000ffc8, 0xff9cf7ff, 0xf7ff20c7, 0x2001ffa1,
	0xff96f7ff, 0xeb04f85d, 0xb570e7c6, 0x460e4615, 0xf7ff4604, 0x2000ffb6, 0xff8af7ff, 0x631c4b7f,
	0x639e635d, 0x7010f04f, 0x68586018, 0x0001f040, 0x68586058, 0xd1fc07c0, 0xf7ff2001, 0xe8bdff79,
	0xe7a94070, 0x4604b570, 0x460e4615, 0xf7ff2000, 0x4b72ff6f, 0x635d631c, 0x02d8639e, 0x68586018,
	0x0001f040, 0x68586058, 0xd1fc07c0, 0x4070e8bd, 0xe75d2001, 0x4603b500, 0xf7ff2000, 0x209fff59,
	0xff5ef7ff, 0xff6cf7ff, 0xf7ff7098, 0x7058ff69, 0xff66f7ff, 0x20017018, 0xeb04f85d, 0xf04fe748,
	0xf8d04080, 0xf0411204, 0xf8c00108, 0x495b1204, 0x6943684a, 0x020ff36f, 0x6380f443, 0x69436143,
	0x6380f423, 0x68486143, 0x4310b280, 0x68486048, 0x0020f020, 0x0010f040, 0x47706048, 0x2300b578,
	0x4180f04f, 0x68499300, 0xf0014d4d, 0x444d010f, 0xd0022907, 0xd0032906, 0x2101e030, 0xe0006069,
	0x2a01606b, 0x6028d100, 0xffc9f7ff, 0x68704e43, 0xf0206869, 0xea4000c0, 0x60701081, 0xf7ff4668,
	0x9800ffa9, 0x447ff06f, 0x407ff030, 0xd0019000, 0xd11442a0, 0xb1886868, 0x60681c40, 0xf0216871,
	0xea4101c0, 0x60701080, 0xf7ff4668, 0x9800ff93, 0x407ff030, 0xd0019000, 0xd10042a0, 0xbd782001,
	0xf7ffb500, 0x482dff9c, 0x4a2d6841, 0x01c0f021, 0x6852444a, 0x1182ea41, 0x20006041, 0x2001bd00,
	0x49274770, 0x4449b500, 0x1a406809, 0xff13f7ff, 0xbd002000, 0x41f0e92d, 0xf8df2700, 0x1cc98084,
	0x46064694, 0x0403f021, 0xe01944c8, 0x0ffff016, 0x2cffd10a, 0xf8d8d908, 0xf44f0000, 0x1a317580,
	0x0007eb0c, 0xe006462a, 0x0000f8d8, 0x1a314625, 0x0007eb0c, 0xf7ff4622, 0x442eff18, 0x1b64442f,
	0xd1e32c00, 0xe8bd2000, 0xb57081f0, 0x460c4616, 0x4605460a, 0x480b4601, 0xf7ff4448, 0x4809ff23,
	0x44482100, 0x5c42e006, 0x429a5c73, 0x1868d001, 0x1c49bd70, 0xd3f642a1, 0xbd701928, 0x40007000,
	0x00000004, 0x0000000c, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000
};

static int numicro_init_isp(struct target *target)
{
	struct working_area *init_algorithm;
	struct reg_param reg_params[6];
	struct armv7m_common *armv7m = target_to_armv7m(target);
	struct armv7m_algorithm armv7m_info;
	uint32_t algorithm_init_entry_offset = 0;
	uint32_t algorithm_lr = 0;
	int retval = ERROR_OK;
	uint32_t reg_stat;

	if (target->state != TARGET_HALTED) {
		LOG_ERROR("Target not halted");
		return ERROR_TARGET_NOT_HALTED;
	}

	if (m_M23SecureDebugState == 2) {
		if (strcmp(m_target_name, "M2354") == 0) {
			algorithm_init_entry_offset = 0xC9;
			algorithm_lr = 0x30010001;

			/* allocate working area with init info code */
			if (target_alloc_working_area(target, sizeof(numicro_M2354_flash_algorithm_code),
				&init_algorithm) != ERROR_OK) {
				LOG_WARNING("no working area available, can't do block memory erase");
				return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
			}

			retval = target_write_buffer(target, init_algorithm->address,
				sizeof(numicro_M2354_flash_algorithm_code), numicro_M2354_flash_algorithm_code);
			if (retval != ERROR_OK)
				return retval;

			armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
			armv7m_info.core_mode = ARM_MODE_THREAD;
			if (armv7m == NULL) {
				/* something is very wrong if armv7m is NULL */
				LOG_ERROR("unable to get armv7m target");
				return retval;
			}

			init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);    /* faddr */
			init_reg_param(&reg_params[1], "sp", 32, PARAM_OUT);    /* update SP */
			init_reg_param(&reg_params[2], "lr", 32, PARAM_OUT);

			buf_set_u32(reg_params[0].value, 0, 32, 0);
			buf_set_u32(reg_params[1].value, 0, 32, init_algorithm->address + target->working_area_size);
			buf_set_u32(reg_params[2].value, 0, 32, algorithm_lr);

			retval = target_run_algorithm(target, 0, NULL, 3, reg_params,
				init_algorithm->address + algorithm_init_entry_offset, 0, 100000, &armv7m_info);
			if (retval != ERROR_OK) {
				LOG_ERROR("Error executing NuMicro Flash erase algorithm");
				retval = ERROR_FLASH_OPERATION_FAILED;
			}

			target_free_working_area(target, init_algorithm);
			destroy_reg_param(&reg_params[0]);
			destroy_reg_param(&reg_params[1]);
			destroy_reg_param(&reg_params[2]);
		}
		else {
			LOG_DEBUG("numicro_init_isp skips since Secure invasive debug is prohibited.");
		}
		return ERROR_OK;
	}

	if (strcmp(m_target_name, "NUC505") == 0) {
		algorithm_init_entry_offset = 0x1DD;
		algorithm_lr = 0x20000001;

		/* allocate working area with init info code */
		if (target_alloc_working_area(target, sizeof(numicro_NUC505_flash_algorithm_code),
			&init_algorithm) != ERROR_OK) {
			LOG_WARNING("no working area available, can't do block memory erase");
			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
		}

		retval = target_write_buffer(target, init_algorithm->address,
			sizeof(numicro_NUC505_flash_algorithm_code), numicro_NUC505_flash_algorithm_code);
		if (retval != ERROR_OK)
			return retval;

		armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
		armv7m_info.core_mode = ARM_MODE_THREAD;
		if (armv7m == NULL) {
			/* something is very wrong if armv7m is NULL */
			LOG_ERROR("unable to get armv7m target");
			return retval;
		}

		init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
		init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
		init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT);
		init_reg_param(&reg_params[3], "r9", 32, PARAM_OUT);
		init_reg_param(&reg_params[4], "sp", 32, PARAM_OUT);    /* update SP */
		init_reg_param(&reg_params[5], "lr", 32, PARAM_OUT);    /* update LR */

		/* use init info code within NuMicro */
		buf_set_u32(reg_params[0].value, 0, 32, 0);
		buf_set_u32(reg_params[1].value, 0, 32, 0);
		buf_set_u32(reg_params[2].value, 0, 32, 0);
		buf_set_u32(reg_params[3].value, 0, 32, 0x2000032C);
		buf_set_u32(reg_params[4].value, 0, 32, init_algorithm->address + 126 * 1024);
		buf_set_u32(reg_params[5].value, 0, 32, algorithm_lr);

		retval = target_run_algorithm(target, 0, NULL, 6, reg_params,
			init_algorithm->address + algorithm_init_entry_offset, 0, 100000, &armv7m_info);
		if (retval != ERROR_OK) {
			LOG_ERROR("Error executing NuMicro init algorithm");
			retval = ERROR_FLASH_OPERATION_FAILED;
		}

		target_free_working_area(target, init_algorithm);
		destroy_reg_param(&reg_params[0]);
		destroy_reg_param(&reg_params[1]);
		destroy_reg_param(&reg_params[2]);
		destroy_reg_param(&reg_params[3]);
		destroy_reg_param(&reg_params[4]);
		destroy_reg_param(&reg_params[5]);
	}
	else {
		retval = numicro_reg_unlock(target);
		if (retval != ERROR_OK)
			return retval;

		/* Enable ISP/SRAM/TICK Clock */
		retval = target_read_u32(target, NUMICRO_SYSCLK_AHBCLK - m_addressMinusOffset, &reg_stat);
		if (retval != ERROR_OK)
			return retval;

		reg_stat |= AHBCLK_ISP_EN | AHBCLK_SRAM_EN | AHBCLK_TICK_EN;
		retval = target_write_u32(target, NUMICRO_SYSCLK_AHBCLK - m_addressMinusOffset, reg_stat);
		if (retval != ERROR_OK)
			return retval;

		/* Enable ISP */
		retval = target_read_u32(target, NUMICRO_FLASH_ISPCON - m_addressMinusOffset, &reg_stat);
		if (retval != ERROR_OK)
			return retval;

		reg_stat |= ISPCON_ISPFF | ISPCON_LDUEN | ISPCON_APUEN | ISPCON_CFGUEN | ISPCON_ISPEN;
		retval = target_write_u32(target, NUMICRO_FLASH_ISPCON - m_addressMinusOffset, reg_stat);
		if (retval != ERROR_OK)
			return retval;

		/* Write one to undocumented flash control register */
		retval = target_write_u32(target, NUMICRO_FLASH_CHEAT - m_addressMinusOffset, 1);
		if (retval != ERROR_OK)
			return retval;
	}

	LOG_DEBUG("numicro_init_isp is done.");
	return ERROR_OK;
}

/* Program LongWord Block Write */
static int numicro_writeblock(struct flash_bank *bank, const uint8_t *buffer,
		uint32_t offset, uint32_t count)
{
	struct target *target = bank->target;
	uint32_t buffer_size = 1024; /* Default minimum value */
	uint32_t totalCount = count;
	uint32_t thisrun_count;
	struct working_area *write_algorithm;
	struct working_area *source;
	struct working_area *source2;
	uint32_t address = bank->base + offset;
	struct reg_param reg_params[6];
	struct armv7m_common *armv7m = target_to_armv7m(target);
	struct armv7m_algorithm armv7m_info;
	uint32_t algorithm_programPage_entry_offset = 0;
	uint32_t algorithm_lr = 0;
	uint32_t status;
	int retval = ERROR_OK;

	/* Params:
	 * r0 - workarea buffer / result
	 * r1 - target address
	 * r2 - wordcount
	 * Clobbered:
	 * r4 - tmp
	 * r5 - tmp
	 * r6 - tmp
	 * r7 - tmp
	 */

	/* check code alignment */
	if (offset & 0x1) {
		LOG_WARNING("offset 0x%" PRIx32 " breaks required 2-byte alignment", offset);
		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
	}

	/* Difference between M0 and M4(M23) */
	if (armv7m->arm.is_armv6m) {
		/* allocate working area with flash programming code */
		if (armv7m->arm.is_NUC_M0_FMC_MSB4) {
			if (target_alloc_working_area(target, sizeof(numicro_M4_M23_flash_write_code),
				&write_algorithm) != ERROR_OK) {
				LOG_WARNING("no working area available, can't do block memory writes");
				return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
			}

			retval = target_write_buffer(target, write_algorithm->address,
				sizeof(numicro_M4_M23_flash_write_code), numicro_M4_M23_flash_write_code);
			if (retval != ERROR_OK)
				return retval;
		}
		else {
			if (target_alloc_working_area(target, sizeof(numicro_M0_flash_write_code),
				&write_algorithm) != ERROR_OK) {
				LOG_WARNING("no working area available, can't do block memory writes");
				return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
			}

			retval = target_write_buffer(target, write_algorithm->address,
				sizeof(numicro_M0_flash_write_code), numicro_M0_flash_write_code);
			if (retval != ERROR_OK)
				return retval;
		}
	}
	else { /* for M4 and M23 */
		if (strcmp(m_target_name, "M480") == 0) {
			algorithm_programPage_entry_offset = 0x339;
			algorithm_lr = 0x20000001;

			/* allocate working area with flash programming code */
			if (target_alloc_working_area(target, sizeof(numicro_M480_flash_algorithm_code),
				&write_algorithm) != ERROR_OK) {
				LOG_WARNING("no working area available, can't do block memory writes");
				return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
			}

			retval = target_write_buffer(target, write_algorithm->address,
				sizeof(numicro_M480_flash_algorithm_code), numicro_M480_flash_algorithm_code);
			if (retval != ERROR_OK)
				return retval;
		}
		else if (strcmp(m_target_name, "NUC505") == 0) {
			buffer_size = 0x1000;
			algorithm_programPage_entry_offset = 0x295;
			algorithm_lr = 0x20000001;

			/* allocate working area with flash programming code */
			if (target_alloc_working_area(target, sizeof(numicro_NUC505_flash_algorithm_code),
				&write_algorithm) != ERROR_OK) {
				LOG_WARNING("no working area available, can't do block memory writes");
				return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
			}

			retval = target_write_buffer(target, write_algorithm->address,
				sizeof(numicro_NUC505_flash_algorithm_code), numicro_NUC505_flash_algorithm_code);
			if (retval != ERROR_OK)
				return retval;
		}
		else if (m_M23SecureDebugState != 2) {
			/* allocate working area with flash programming code */
			if (target_alloc_working_area(target, sizeof(numicro_M4_M23_flash_write_code),
				&write_algorithm) != ERROR_OK) {
				LOG_WARNING("no working area available, can't do block memory writes");
				return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
			}

			retval = target_write_buffer(target, write_algorithm->address,
				sizeof(numicro_M4_M23_flash_write_code), numicro_M4_M23_flash_write_code);
			if (retval != ERROR_OK)
				return retval;
		}
		else {
			if (strcmp(m_target_name, "M2354") == 0) {
				algorithm_programPage_entry_offset = 0x1E9;
				algorithm_lr = 0x30010001;

				/* allocate working area with flash programming code */
				if (target_alloc_working_area(target, sizeof(numicro_M2354_flash_algorithm_code),
					&write_algorithm) != ERROR_OK) {
					LOG_WARNING("no working area available, can't do block memory writes");
					return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
				}

				retval = target_write_buffer(target, write_algorithm->address,
					sizeof(numicro_M2354_flash_algorithm_code), numicro_M2354_flash_algorithm_code);
				if (retval != ERROR_OK)
					return retval;
			}
			else {
				/* allocate working area with flash programming code */
				if (target_alloc_working_area(target, sizeof(numicro_M2351_NS_flash_write_code),
					&write_algorithm) != ERROR_OK) {
					LOG_WARNING("no working area available, can't do block memory writes");
					return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
				}

				retval = target_write_buffer(target, write_algorithm->address,
					sizeof(numicro_M2351_NS_flash_write_code), numicro_M2351_NS_flash_write_code);
				if (retval != ERROR_OK)
					return retval;
			}
		}
		/*buffer_size = m_pageSize; <- it doesn't matter because the flash alogrithm uses the word programming. */
	}

	/* Increase buffer_size if needed */
	if (buffer_size == 1024 /*&& buffer_size < ((target->working_area_size - write_algorithm->size)/2)*/) {
		buffer_size = (target->working_area_size - write_algorithm->size - 512) / 2; /* 512 bytes for stack */

		if (buffer_size & 0x1)
			buffer_size = buffer_size - 1;

		buffer_size = buffer_size - 10; /* buffer for alignment */
	}

	/* memory buffer */
	if ((target_alloc_working_area(target, buffer_size, &source) != ERROR_OK) ||
		(target_alloc_working_area(target, buffer_size, &source2) != ERROR_OK)) {
		/* free working area, write algorithm already allocated */
		target_free_working_area(target, write_algorithm);

		LOG_WARNING("No large enough working area available, can't do block memory writes");
		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
	}

	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
	armv7m_info.core_mode = ARM_MODE_THREAD;
	if (armv7m == NULL) {
		/* something is very wrong if armv7m is NULL */
		LOG_ERROR("unable to get armv7m target");
		return retval;
	}

	if ((strcmp(m_target_name, "M2354") == 0 && m_M23SecureDebugState == 2) ||
		 strcmp(m_target_name, "M480") == 0) {
		init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);    /* faddr */
		init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);    /* number of words to program */
		init_reg_param(&reg_params[2], "r2", 32, PARAM_IN_OUT); /* *pLW (*buffer) */
		init_reg_param(&reg_params[3], "sp", 32, PARAM_OUT);    /* update SP */
		init_reg_param(&reg_params[4], "lr", 32, PARAM_OUT);    /* update LR */

		/* write code buffer and use flash programming code within numicro */
		/* set breakpoint to 0 with time-out of 10000 ms                  */
		while (count > 0) {
			if (count == totalCount) {
				thisrun_count = (count > (buffer_size / 4)) ? (buffer_size / 4) : count;

				retval = target_write_buffer(target, source->address, thisrun_count * 4, buffer);
				if (retval != ERROR_OK)
					break;
			}

			buf_set_u32(reg_params[0].value, 0, 32, address/* & NUMICRO_TZ_MASK*/);
			buf_set_u32(reg_params[1].value, 0, 32, thisrun_count * 4);
			buf_set_u32(reg_params[2].value, 0, 32, source->address);
			buf_set_u32(reg_params[3].value, 0, 32, write_algorithm->address + target->working_area_size);
			buf_set_u32(reg_params[4].value, 0, 32, algorithm_lr);

			retval = target_start_algorithm(target, 0, NULL, 5, reg_params,
				write_algorithm->address + algorithm_programPage_entry_offset, 0, &armv7m_info);

			buffer  += thisrun_count * 4;
			address += thisrun_count * 4;
			count   -= thisrun_count;
			LOG_INFO("Have written %d%%", (totalCount - count) * 100 / totalCount);

			thisrun_count = (count > (buffer_size / 4)) ? (buffer_size / 4) : count;

			if (thisrun_count > 0) {
				retval = target_write_buffer(target, source2->address, thisrun_count * 4, buffer);
				if (retval != ERROR_OK)
					break;
			}

			retval = target_wait_algorithm(target, 0, NULL, 5, reg_params,
				0, 10000, &armv7m_info);

			if (thisrun_count == 0)
				break;

			buf_set_u32(reg_params[0].value, 0, 32, address/* & NUMICRO_TZ_MASK*/);
			buf_set_u32(reg_params[1].value, 0, 32, thisrun_count * 4);
			buf_set_u32(reg_params[2].value, 0, 32, source2->address);
			buf_set_u32(reg_params[3].value, 0, 32, write_algorithm->address + target->working_area_size);
			buf_set_u32(reg_params[4].value, 0, 32, algorithm_lr);

			retval = target_start_algorithm(target, 0, NULL, 5, reg_params,
				write_algorithm->address + algorithm_programPage_entry_offset, 0, &armv7m_info);

			buffer  += thisrun_count * 4;
			address += thisrun_count * 4;
			count   -= thisrun_count;
			LOG_INFO("Have written %d%%", (totalCount - count) * 100 / totalCount);

			if (count != 0) {
				thisrun_count = (count > (buffer_size / 4)) ? (buffer_size / 4) : count;

				retval = target_write_buffer(target, source->address, thisrun_count * 4, buffer);
				if (retval != ERROR_OK)
					break;
			}

			retval = target_wait_algorithm(target, 0, NULL, 5, reg_params,
				0, 10000, &armv7m_info);
		}

		target_free_working_area(target, source);
		target_free_working_area(target, source2);
		target_free_working_area(target, write_algorithm);
		destroy_reg_param(&reg_params[0]);
		destroy_reg_param(&reg_params[1]);
		destroy_reg_param(&reg_params[2]);
		destroy_reg_param(&reg_params[3]);
		destroy_reg_param(&reg_params[4]);
	}
	else if (strcmp(m_target_name, "NUC505") == 0) {
		init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);    /* faddr */
		init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);    /* number of words to program */
		init_reg_param(&reg_params[2], "r2", 32, PARAM_IN_OUT); /* *pLW (*buffer) */
		init_reg_param(&reg_params[3], "r9", 32, PARAM_OUT);
		init_reg_param(&reg_params[4], "sp", 32, PARAM_OUT);    /* update SP */
		init_reg_param(&reg_params[5], "lr", 32, PARAM_OUT);    /* update LR */

		/* write code buffer and use flash programming code within numicro */
		/* set breakpoint to 0 with time-out of 10000 ms                  */
		while (count > 0) {
			if (count == totalCount) {
				thisrun_count = (count > (buffer_size / 4)) ? (buffer_size / 4) : count;

				retval = target_write_buffer(target, source->address, thisrun_count * 4, buffer);
				if (retval != ERROR_OK)
					break;
			}

			buf_set_u32(reg_params[0].value, 0, 32, address & NUMICRO_TZ_MASK);
			buf_set_u32(reg_params[1].value, 0, 32, thisrun_count * 4);
			buf_set_u32(reg_params[2].value, 0, 32, source->address);
			buf_set_u32(reg_params[3].value, 0, 32, 0x2000032C);
			buf_set_u32(reg_params[4].value, 0, 32, write_algorithm->address + 126 * 1024);
			buf_set_u32(reg_params[5].value, 0, 32, algorithm_lr);

			retval = target_start_algorithm(target, 0, NULL, 6, reg_params,
				write_algorithm->address + algorithm_programPage_entry_offset, 0, &armv7m_info);

			buffer  += thisrun_count * 4;
			address += thisrun_count * 4;
			count   -= thisrun_count;
			LOG_INFO("Have written %d%%", (totalCount - count) * 100 / totalCount);

			thisrun_count = (count > (buffer_size / 4)) ? (buffer_size / 4) : count;

			if (thisrun_count > 0) {
				retval = target_write_buffer(target, source2->address, thisrun_count * 4, buffer);
				if (retval != ERROR_OK)
					break;
			}

			retval = target_wait_algorithm(target, 0, NULL, 6, reg_params,
				0, 10000, &armv7m_info);

			if (thisrun_count == 0)
				break;

			buf_set_u32(reg_params[0].value, 0, 32, address & NUMICRO_TZ_MASK);
			buf_set_u32(reg_params[1].value, 0, 32, thisrun_count * 4);
			buf_set_u32(reg_params[2].value, 0, 32, source2->address);
			buf_set_u32(reg_params[3].value, 0, 32, 0x2000032C);
			buf_set_u32(reg_params[4].value, 0, 32, write_algorithm->address + 126 * 1024);
			buf_set_u32(reg_params[5].value, 0, 32, algorithm_lr);

			retval = target_start_algorithm(target, 0, NULL, 6, reg_params,
				write_algorithm->address + algorithm_programPage_entry_offset, 0, &armv7m_info);

			buffer  += thisrun_count * 4;
			address += thisrun_count * 4;
			count   -= thisrun_count;
			LOG_INFO("Have written %d%%", (totalCount - count) * 100 / totalCount);

			if (count != 0) {
				thisrun_count = (count > (buffer_size / 4)) ? (buffer_size / 4) : count;

				retval = target_write_buffer(target, source->address, thisrun_count * 4, buffer);
				if (retval != ERROR_OK)
					break;
			}

			retval = target_wait_algorithm(target, 0, NULL, 6, reg_params,
				0, 10000, &armv7m_info);
		}

		// uninit
		algorithm_programPage_entry_offset = 0x261;
		algorithm_lr = 0x20000001;

		buf_set_u32(reg_params[0].value, 0, 32, 0);
		buf_set_u32(reg_params[1].value, 0, 32, 0);
		buf_set_u32(reg_params[2].value, 0, 32, 0);
		buf_set_u32(reg_params[3].value, 0, 32, 0x2000032C);
		buf_set_u32(reg_params[4].value, 0, 32, write_algorithm->address + 126 * 1024);
		buf_set_u32(reg_params[5].value, 0, 32, algorithm_lr);

		retval = target_run_algorithm(target, 0, NULL, 6, reg_params,
					write_algorithm->address + algorithm_programPage_entry_offset, 0, 100000, &armv7m_info);
		if (retval != ERROR_OK) {
			LOG_ERROR("Error executing NuMicro Flash programming algorithm");
			retval = ERROR_FLASH_OPERATION_FAILED;
		}

		target_free_working_area(target, source);
		target_free_working_area(target, source2);
		target_free_working_area(target, write_algorithm);
		destroy_reg_param(&reg_params[0]);
		destroy_reg_param(&reg_params[1]);
		destroy_reg_param(&reg_params[2]);
		destroy_reg_param(&reg_params[3]);
		destroy_reg_param(&reg_params[4]);
		destroy_reg_param(&reg_params[5]);

		/* chip reset */
		target_write_u32(target, 0x40000008, 0x2);
		/* wait for NUC505 IBR operations */
		busy_sleep(50);
	}
	else {
		init_reg_param(&reg_params[0], "r0", 32, PARAM_IN_OUT); /* *pLW (*buffer) */
		init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);    /* faddr */
		init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT);    /* number of words to program */
		init_reg_param(&reg_params[3], "sp", 32, PARAM_OUT);    /* update SP */

		/* write code buffer and use Flash programming code within NuMicro */
		/* set breakpoint to 0 with time-out of 10000 ms                  */
		while (count > 0) {
			if (count == totalCount) {
				thisrun_count = (count > (buffer_size / 4)) ? (buffer_size / 4) : count;

				retval = target_write_buffer(target, source->address, thisrun_count * 4, buffer);
				if (retval != ERROR_OK)
					break;
			}

			buf_set_u32(reg_params[0].value, 0, 32, source->address);
			buf_set_u32(reg_params[1].value, 0, 32, address & NUMICRO_TZ_MASK);
			buf_set_u32(reg_params[2].value, 0, 32, thisrun_count);
			buf_set_u32(reg_params[3].value, 0, 32, write_algorithm->address + target->working_area_size);

			retval = target_start_algorithm(target, 0, NULL, 4, reg_params,
				write_algorithm->address + algorithm_programPage_entry_offset, 0, &armv7m_info);

			buffer  += thisrun_count * 4;
			address += thisrun_count * 4;
			count   -= thisrun_count;
			LOG_INFO("Have written %d%%", (totalCount - count) * 100 / totalCount);

			thisrun_count = (count > (buffer_size / 4)) ? (buffer_size / 4) : count;

			if (thisrun_count > 0) {
				retval = target_write_buffer(target, source2->address, thisrun_count * 4, buffer);
				if (retval != ERROR_OK)
					break;
			}

			retval = target_wait_algorithm(target, 0, NULL, 4, reg_params,
				0, 10000, &armv7m_info);

			if (thisrun_count == 0)
				break;

			buf_set_u32(reg_params[0].value, 0, 32, source2->address);
			buf_set_u32(reg_params[1].value, 0, 32, address & NUMICRO_TZ_MASK);
			buf_set_u32(reg_params[2].value, 0, 32, thisrun_count);
			buf_set_u32(reg_params[3].value, 0, 32, write_algorithm->address + target->working_area_size);

			retval = target_start_algorithm(target, 0, NULL, 4, reg_params,
				write_algorithm->address + algorithm_programPage_entry_offset, 0, &armv7m_info);

			buffer  += thisrun_count * 4;
			address += thisrun_count * 4;
			count   -= thisrun_count;
			LOG_INFO("Have written %d%%", (totalCount - count) * 100 / totalCount);

			if (count != 0) {
				thisrun_count = (count > (buffer_size / 4)) ? (buffer_size / 4) : count;

				retval = target_write_buffer(target, source->address, thisrun_count * 4, buffer);
				if (retval != ERROR_OK)
					break;
			}

			retval = target_wait_algorithm(target, 0, NULL, 4, reg_params,
				0, 10000, &armv7m_info);
		}

		target_free_working_area(target, source);
		target_free_working_area(target, source2);
		target_free_working_area(target, write_algorithm);
		destroy_reg_param(&reg_params[0]);
		destroy_reg_param(&reg_params[1]);
		destroy_reg_param(&reg_params[2]);
		destroy_reg_param(&reg_params[3]);
	}

	return retval;
}

static int numicro_M2351_getinitinfo_ns(struct target *target, uint32_t *part_id)
{
	struct working_area *init_algorithm;
	uint32_t address;
	struct reg_param reg_params[2];
	struct armv7m_common *armv7m = target_to_armv7m(target);
	struct armv7m_algorithm armv7m_info;
	int retval = ERROR_OK;
	//int numberOfInfo = 1; /* info: 1. PID */

	/* Params:
	* r0 - address to place info (In fact, the actual location will be the address plus one word)
	*/

	if (m_M23SecureDebugState != 2) {
		LOG_DEBUG("Error executing NuMicro init-info algorithm because it is only used for M23 NS.");
		retval = ERROR_FLASH_OPERATION_FAILED;

		return retval;
	}

	/* allocate working area with init info code */
	if (target_alloc_working_area(target, sizeof(numicro_M2351_NS_init_info_code),
		&init_algorithm) != ERROR_OK) {
		LOG_WARNING("no working area available, can't do block memory erase");
		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
	}

	retval = target_write_buffer(target, init_algorithm->address,
		sizeof(numicro_M2351_NS_init_info_code), numicro_M2351_NS_init_info_code);
	if (retval != ERROR_OK)
		return retval;

	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
	armv7m_info.core_mode = ARM_MODE_THREAD;
	if (armv7m == NULL) {
		/* something is very wrong if armv7m is NULL */
		LOG_ERROR("unable to get armv7m target");
		return retval;
	}

	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);    /* faddr */
	init_reg_param(&reg_params[1], "sp", 32, PARAM_OUT);    /* update SP */

	/* use init info code within NuMicro              */
	/* set breakpoint to 0 with time-out of 100000 ms */
	address = init_algorithm->address + target->working_area_size/* - 4 * (numberOfInfo + 1) */;
	buf_set_u32(reg_params[0].value, 0, 32, address + 4);
	buf_set_u32(reg_params[1].value, 0, 32, address);

	retval = target_run_algorithm(target, 0, NULL, 2, reg_params,
		init_algorithm->address, 0, 100000, &armv7m_info);
	if (retval != ERROR_OK) {
		LOG_ERROR("Error executing NuMicro init info algorithm");
		retval = ERROR_FLASH_OPERATION_FAILED;
	}

	target_free_working_area(target, init_algorithm);
	destroy_reg_param(&reg_params[0]);
	destroy_reg_param(&reg_params[1]);

	/* get the result */
	if (retval == ERROR_OK) {
		retval = target_read_u32(target, address + 8, part_id);
		if (retval != ERROR_OK) {
			LOG_WARNING("NuMicro flash driver: Failed to Get PartID");
			retval = ERROR_FLASH_OPERATION_FAILED;
		}
	}

	return retval;
}

/* Flash Lock checking - examines the lock bit. */
static int numicro_protect_check(struct flash_bank *bank)
{
	struct target *target = bank->target;
	uint32_t set, config[2];
	int i, retval = ERROR_OK;

	if (target->state != TARGET_HALTED) {
		LOG_ERROR("Target not halted");
		return ERROR_TARGET_NOT_HALTED;
	}

	LOG_INFO("Nuvoton NuMicro: Flash Lock Check...");

	numicro_get_arm_arch(target);
	retval = numicro_init_isp(target);
	if (retval != ERROR_OK)
		return retval;

	/* TODO: how about M23 NS? */
	/* Read CONFIG0,CONFIG1 */
	numicro_fmc_cmd(target, ISPCMD_READ, NUMICRO_CONFIG0 - m_addressMinusOffset, 0, &config[0]);
	numicro_fmc_cmd(target, ISPCMD_READ, NUMICRO_CONFIG1 - m_addressMinusOffset, 0, &config[1]);

	LOG_DEBUG("CONFIG0: 0x%" PRIx32 ",CONFIG1: 0x%" PRIx32 "", config[0], config[1]);

	if ((config[0] & (1<<7)) == 0)
		LOG_INFO("CBS=0: Boot From LPROM");
	else
		LOG_INFO("CBS=1: Boot From APROM");

	if ((config[0] & CONFIG0_LOCK_MASK) == 0) {

		LOG_INFO("Flash is secure locked!");
		LOG_INFO("TO UNLOCK FLASH,EXECUTE chip_erase COMMAND!!");
		set = 1;
	}
	else {
		LOG_INFO("Flash is not locked!");
	    set = 0;
	}

	for (i = 0; i < bank->num_sectors; i++)
		bank->sectors[i].is_protected = set;

	return ERROR_OK;
}

static int numicro_erase(struct flash_bank *bank, int first, int last)
{
	struct target *target = bank->target;
	struct working_area *erase_algorithm;
	uint32_t address;
	struct reg_param reg_params[4];
	struct armv7m_common *armv7m = target_to_armv7m(target);
	struct armv7m_algorithm armv7m_info;
	uint32_t algorithm_eraseSector_entry_offset = 0;
	uint32_t algorithm_lr = 0;
	int i, retval = ERROR_OK;
	uint32_t timeout, status;

	if (target->state != TARGET_HALTED) {
		LOG_ERROR("Target not halted");
		return ERROR_TARGET_NOT_HALTED;
	}

	LOG_INFO("Nuvoton NuMicro: Sector Erase ... (%d to %d)", first, last);

	numicro_get_arm_arch(target);
	retval = numicro_init_isp(target);
	if (retval != ERROR_OK)
		return retval;

	if (strcmp(m_target_name, "NUC505") == 0) {
		algorithm_eraseSector_entry_offset = 0x283;
		algorithm_lr = 0x20000001;

		/* allocate working area with flash erase code */
		if (target_alloc_working_area(target, sizeof(numicro_NUC505_flash_algorithm_code),
			&erase_algorithm) != ERROR_OK) {
			LOG_WARNING("no working area available, can't do block memory erase");
			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
		}

		retval = target_write_buffer(target, erase_algorithm->address,
			sizeof(numicro_NUC505_flash_algorithm_code), numicro_NUC505_flash_algorithm_code);
		if (retval != ERROR_OK)
			return retval;

		armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
		armv7m_info.core_mode = ARM_MODE_THREAD;
		if (armv7m == NULL) {
			/* something is very wrong if armv7m is NULL */
			LOG_ERROR("unable to get armv7m target");
			return retval;
		}

		init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);    /* faddr */
		init_reg_param(&reg_params[1], "r9", 32, PARAM_OUT);
		init_reg_param(&reg_params[2], "sp", 32, PARAM_OUT);    /* update SP */
		init_reg_param(&reg_params[3], "lr", 32, PARAM_OUT);

		/* use Flash erase code within NuMicro            */
		/* set breakpoint to 0 with time-out of 100000 ms */
		for (i = first; i <= last; i++) {
			if (bank->sectors[i].is_erased == 1) {
				LOG_DEBUG("sector %d has been erased recently. Skip to the next sector.", i);
				continue;
			}

			address = (bank->base + bank->sectors[i].offset) /* & NUMICRO_TZ_MASK */;
			buf_set_u32(reg_params[0].value, 0, 32, address);
			buf_set_u32(reg_params[1].value, 0, 32, 0x2000032C);
			buf_set_u32(reg_params[2].value, 0, 32, erase_algorithm->address + 126 * 1024);
			buf_set_u32(reg_params[3].value, 0, 32, algorithm_lr);

			retval = target_run_algorithm(target, 0, NULL, 4, reg_params,
				erase_algorithm->address + algorithm_eraseSector_entry_offset, 0, 100000, &armv7m_info);
			if (retval != ERROR_OK) {
				LOG_ERROR("Error executing NuMicro Flash erase algorithm");
				retval = ERROR_FLASH_OPERATION_FAILED;
				break;
			}
			else {
				bank->sectors[i].is_erased = 1;
			}
		}

		// uninit
		algorithm_eraseSector_entry_offset = 0x261;
		algorithm_lr = 0x20000001;

		buf_set_u32(reg_params[0].value, 0, 32, 0);
		buf_set_u32(reg_params[1].value, 0, 32, 0x2000032C);
		buf_set_u32(reg_params[2].value, 0, 32, erase_algorithm->address + 126 * 1024);
		buf_set_u32(reg_params[3].value, 0, 32, algorithm_lr);

		retval = target_run_algorithm(target, 0, NULL, 4, reg_params,
					erase_algorithm->address + algorithm_eraseSector_entry_offset, 0, 100000, &armv7m_info);
		if (retval != ERROR_OK) {
			LOG_ERROR("Error executing NuMicro Flash programming algorithm");
			retval = ERROR_FLASH_OPERATION_FAILED;
		}

		target_free_working_area(target, erase_algorithm);
		destroy_reg_param(&reg_params[0]);
		destroy_reg_param(&reg_params[1]);
		destroy_reg_param(&reg_params[2]);
		destroy_reg_param(&reg_params[3]);
	}
	else if (m_M23SecureDebugState != 2) {
		retval = target_write_u32(target, NUMICRO_FLASH_ISPCMD - m_addressMinusOffset, ISPCMD_ERASE);
		if (retval != ERROR_OK)
			return retval;

		for (i = first; i <= last; i++) {
			if (bank->sectors[i].is_erased == 1) {
				LOG_DEBUG("sector %d has been erased recently. Skip to the next sector.", i);
				continue;
			}

			address = bank->base + bank->sectors[i].offset;
			LOG_DEBUG("erasing sector %d at address 0x%" PRIx32 "", i, address);
			if ((m_flashInfo & NUMICRO_SPROM_MASK) != 0 &&
				(address >= NUMICRO_SPROM_BASE) && (address < (NUMICRO_SPROM_BASE + m_pageSize))) {
				LOG_DEBUG("SPROM is erasing");
				retval = target_write_u32(target, NUMICRO_FLASH_ISPDAT - m_addressMinusOffset, NUMICRO_SPROM_ISPDAT);
				if (retval != ERROR_OK)
					return retval;

				retval = target_write_u32(target, NUMICRO_FLASH_ISPADR - m_addressMinusOffset, NUMICRO_SPROM_BASE);
				if (retval != ERROR_OK)
					return retval;
			}
			else {
				retval = target_write_u32(target, NUMICRO_FLASH_ISPADR - m_addressMinusOffset, address & NUMICRO_TZ_MASK);
				if (retval != ERROR_OK)
					return retval;
			}

			retval = target_write_u32(target, NUMICRO_FLASH_ISPTRG - m_addressMinusOffset, ISPTRG_ISPGO); /* This is the only bit available */
			if (retval != ERROR_OK)
				return retval;

			/* wait for busy to clear - check the GO flag */
			timeout = 100;
			for (;;) {
				retval = target_read_u32(target, NUMICRO_FLASH_ISPTRG - m_addressMinusOffset, &status);
				if (retval != ERROR_OK)
					return retval;
				LOG_DEBUG("status: 0x%" PRIx32 "", status);
				if (status == 0)
					break;
				if (timeout-- <= 0) {
					LOG_DEBUG("timed out waiting for flash");
					return ERROR_FAIL;
				}
				busy_sleep(1);	/* can use busy sleep for short times. */
			}

			/* check for failure */
			retval = target_read_u32(target, NUMICRO_FLASH_ISPCON - m_addressMinusOffset, &status);
			if (retval != ERROR_OK)
				return retval;
			if ((status & ISPCON_ISPFF) != 0) {
				LOG_DEBUG("failure: 0x%" PRIx32 "", status);
				/* if bit is set, then must write to it to clear it. */
				retval = target_write_u32(target, NUMICRO_FLASH_ISPCON - m_addressMinusOffset, (status | ISPCON_ISPFF));
				if (retval != ERROR_OK)
					return retval;
			}
			else {
				bank->sectors[i].is_erased = 1;
			}
		}
	}
	else { // m_M23SecureDebugState == 2
		if (strcmp(m_target_name, "M2354") == 0) {
			algorithm_eraseSector_entry_offset = 0x151;
			algorithm_lr = 0x30010001;

			/* allocate working area with flash erase code */
			if (target_alloc_working_area(target, sizeof(numicro_M2354_flash_algorithm_code),
				&erase_algorithm) != ERROR_OK) {
				LOG_WARNING("no working area available, can't do block memory erase");
				return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
			}

			retval = target_write_buffer(target, erase_algorithm->address,
				sizeof(numicro_M2354_flash_algorithm_code), numicro_M2354_flash_algorithm_code);
			if (retval != ERROR_OK)
				return retval;

			armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
			armv7m_info.core_mode = ARM_MODE_THREAD;
			if (armv7m == NULL) {
				/* something is very wrong if armv7m is NULL */
				LOG_ERROR("unable to get armv7m target");
				return retval;
			}

			init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);    /* faddr */
			init_reg_param(&reg_params[1], "sp", 32, PARAM_OUT);    /* update SP */
			init_reg_param(&reg_params[2], "lr", 32, PARAM_OUT);

			/* use Flash erase code within NuMicro            */
			/* set breakpoint to 0 with time-out of 100000 ms */
			for (i = first; i <= last; i++) {
				if (bank->sectors[i].is_erased == 1) {
					LOG_DEBUG("sector %d has been erased recently. Skip to the next sector.", i);
					continue;
				}

				address = (bank->base + bank->sectors[i].offset) /* & NUMICRO_TZ_MASK */;
				buf_set_u32(reg_params[0].value, 0, 32, address);
				buf_set_u32(reg_params[1].value, 0, 32, erase_algorithm->address + target->working_area_size);
				buf_set_u32(reg_params[2].value, 0, 32, algorithm_lr);

				retval = target_run_algorithm(target, 0, NULL, 3, reg_params,
					erase_algorithm->address + algorithm_eraseSector_entry_offset, 0, 100000, &armv7m_info);
				if (retval != ERROR_OK) {
					LOG_ERROR("Error executing NuMicro Flash erase algorithm");
					retval = ERROR_FLASH_OPERATION_FAILED;
					break;
				}
				else {
					bank->sectors[i].is_erased = 1;
				}
			}

			target_free_working_area(target, erase_algorithm);
			destroy_reg_param(&reg_params[0]);
			destroy_reg_param(&reg_params[1]);
			destroy_reg_param(&reg_params[2]);
		}
		else {
			/* allocate working area with flash erase code */
			if (target_alloc_working_area(target, sizeof(numicro_M2351_NS_flash_erase_code),
				&erase_algorithm) != ERROR_OK) {
				LOG_WARNING("no working area available, can't do block memory erase");
				return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
			}

			retval = target_write_buffer(target, erase_algorithm->address,
				sizeof(numicro_M2351_NS_flash_erase_code), numicro_M2351_NS_flash_erase_code);
			if (retval != ERROR_OK)
				return retval;

			armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
			armv7m_info.core_mode = ARM_MODE_THREAD;
			if (armv7m == NULL) {
				/* something is very wrong if armv7m is NULL */
				LOG_ERROR("unable to get armv7m target");
				return retval;
			}

			init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);    /* faddr */
			init_reg_param(&reg_params[1], "sp", 32, PARAM_OUT);    /* update SP */

			/* use Flash erase code within NuMicro            */
			/* set breakpoint to 0 with time-out of 100000 ms */
			for (i = first; i <= last; i++) {
				if (bank->sectors[i].is_erased == 1) {
					LOG_DEBUG("sector %d has been erased recently. Skip to the next sector.", i);
					continue;
				}

				address = (bank->base + bank->sectors[i].offset) /* & NUMICRO_TZ_MASK */;
				buf_set_u32(reg_params[0].value, 0, 32, address);
				buf_set_u32(reg_params[1].value, 0, 32, erase_algorithm->address + target->working_area_size);

				retval = target_run_algorithm(target, 0, NULL, 2, reg_params,
					erase_algorithm->address, 0, 100000, &armv7m_info);
				if (retval != ERROR_OK) {
					LOG_ERROR("Error executing NuMicro Flash erase algorithm");
					retval = ERROR_FLASH_OPERATION_FAILED;
					break;
				}
				else {
					bank->sectors[i].is_erased = 1;
				}
			}

			target_free_working_area(target, erase_algorithm);
			destroy_reg_param(&reg_params[0]);
			destroy_reg_param(&reg_params[1]);
		}
	}

	/* done */
	LOG_DEBUG("Erase done.");

	return ERROR_OK;
}

/* The write routine stub. */
static int numicro_write(struct flash_bank *bank, const uint8_t *buffer,
		uint32_t offset, uint32_t count)
{
	struct target *target = bank->target;
	uint32_t timeout, status;
	uint8_t *new_buffer = NULL;
	int retval = ERROR_OK;

	if (target->state != TARGET_HALTED) {
		LOG_ERROR("Target not halted");
		return ERROR_TARGET_NOT_HALTED;
	}

	LOG_INFO("Nuvoton NuMicro: Flash Write ...");

	numicro_get_arm_arch(target);
	retval = numicro_init_isp(target);
	if (retval != ERROR_OK)
		return retval;

	if (m_M23SecureDebugState != 2) {
		retval = target_write_u32(target, NUMICRO_FLASH_ISPCMD - m_addressMinusOffset, ISPCMD_WRITE);
		if (retval != ERROR_OK)
			return retval;
	}

	if (count & 0x3) {
		uint32_t old_count = count;
		count = (old_count | 3) + 1;
		new_buffer = malloc(count);
		if (new_buffer == NULL) {
			LOG_ERROR("odd number of bytes to write and no memory "
				"for padding buffer");
			return ERROR_FAIL;
		}
		LOG_INFO("odd number of bytes to write (%d), extending to %d "
			"and padding with 0xff", old_count, count);
		memset(new_buffer, 0xff, count);
		buffer = memcpy(new_buffer, buffer, old_count);
	}

	uint32_t words_remaining = count / 4;

	/* try using a block write */
	retval = numicro_writeblock(bank, buffer, offset, words_remaining);

	if ((retval == ERROR_TARGET_RESOURCE_NOT_AVAILABLE) && (m_M23SecureDebugState != 2)) {
		/* if block write failed (no sufficient working area),
		 * we use normal (slow) single word accesses */
		LOG_WARNING("couldn't use block writes, falling back to single "
			"memory accesses");

		/* program command */
		for (uint32_t i = 0; i < count; i += 4) {

			LOG_DEBUG("write longword @ %08X", offset + i);

			uint8_t padding[4] = {0xff, 0xff, 0xff, 0xff};
			memcpy(padding, buffer + i, MIN(4, count-i));

			retval = target_write_u32(target, NUMICRO_FLASH_ISPADR - m_addressMinusOffset, (bank->base + offset + i) & NUMICRO_TZ_MASK);
			if (retval != ERROR_OK)
				return retval;
			retval = target_write_memory(target, NUMICRO_FLASH_ISPDAT - m_addressMinusOffset, 4, 1, padding);
			if (retval != ERROR_OK)
				return retval;
			retval = target_write_u32(target, NUMICRO_FLASH_ISPTRG - m_addressMinusOffset, ISPTRG_ISPGO);
			if (retval != ERROR_OK)
				return retval;

			/* wait for busy to clear - check the GO flag */
			timeout = 100;
			for (;;) {
				retval = target_read_u32(target, NUMICRO_FLASH_ISPTRG - m_addressMinusOffset, &status);
				if (retval != ERROR_OK)
					return retval;
					LOG_DEBUG("status: 0x%" PRIx32 "", status);
				if (status == 0)
					break;
				if (timeout-- <= 0) {
					LOG_DEBUG("timed out waiting for flash");
					return ERROR_FAIL;
				}
				busy_sleep(1);	/* can use busy sleep for short times. */
			}
		}

		/* check for failure */
		retval = target_read_u32(target, NUMICRO_FLASH_ISPCON - m_addressMinusOffset, &status);
		if (retval != ERROR_OK)
			return retval;
		if ((status & ISPCON_ISPFF) != 0) {
			LOG_DEBUG("failure: 0x%" PRIx32 "", status);
			/* if bit is set, then must write to it to clear it. */
			retval = target_write_u32(target, NUMICRO_FLASH_ISPCON - m_addressMinusOffset, (status | ISPCON_ISPFF));
			if (retval != ERROR_OK)
				return retval;
		}
		else {
			LOG_DEBUG("Write OK");
		}
	}

	/* done. */
	LOG_DEBUG("Write done.");

	return ERROR_OK;
}

static int numicro_get_cpu_type(struct target *target, const struct numicro_cpu_type** cpu)
{
	uint32_t part_id = 0xABCDEF12;
	int retval = ERROR_OK;

	numicro_get_arm_arch(target);

	/* Read NuMicro PartID */
	if (m_M23SecureDebugState != 2) {
		retval = target_read_u32(target, NUMICRO_SYS_BASE - m_addressMinusOffset, &part_id);
		if (retval != ERROR_OK) {
			LOG_WARNING("NuMicro flash driver: Failed to Get PartID");
			return ERROR_FLASH_OPERATION_FAILED;
		}
	}
	else {
		retval = target_read_u32(target, NUMICRO_SYS_BASE, &part_id);
		if (retval != ERROR_OK) {
			LOG_WARNING("NuMicro flash driver: Failed to Get PartID");
			return ERROR_FLASH_OPERATION_FAILED;
		}
	}

	LOG_INFO("Device ID: 0x%08" PRIx32 "", part_id);
	/* search part numbers */
	for (size_t i = 0; i < sizeof(NuMicroParts) / sizeof(NuMicroParts[0]); i++) {
		if (part_id == NuMicroParts[i].partid) {
			*cpu = &NuMicroParts[i];
			LOG_INFO("Device Name: %s", (*cpu)->partname);
			return ERROR_OK;
		}
	}

	/* try again for M23 series */
	if (m_M23SecureDebugState == 2) {
		if (strcmp(m_target_name, "M2351") == 0) {
			numicro_M2351_getinitinfo_ns(target, &part_id);
		}
		else {
			retval = target_read_u32(target, NUMICRO_SYS_BASE, &part_id);
			if (retval != ERROR_OK) {
				LOG_WARNING("NuMicro flash driver: Failed to Get PartID");
				return ERROR_FLASH_OPERATION_FAILED;
			}
		}

		LOG_INFO("Device ID: 0x%08" PRIx32 "", part_id);
		/* search part numbers */
		for (size_t i = 0; i < sizeof(NuMicroParts) / sizeof(NuMicroParts[0]); i++) {
			if (part_id == NuMicroParts[i].partid) {
				*cpu = &NuMicroParts[i];
				LOG_INFO("Device Name: %s", (*cpu)->partname);
				return ERROR_OK;
			}
		}
	}
	LOG_WARNING("NuMicro flash driver: Failed to search PartID. Use 'UNKNOWN' instead.");
	*cpu = &NuMicroParts[sizeof(NuMicroParts) / sizeof(NuMicroParts[0]) - 1];
	LOG_INFO("Device Name: %s", (*cpu)->partname);

	return ERROR_FAIL;
}

static int numicro_get_flash_size(struct flash_bank *bank, const struct numicro_cpu_type *cpu, uint32_t *flash_size)
{
	for (size_t i = 0; i < cpu->n_banks; i++) {
		if (bank->base == cpu->bank[i].base) {
			*flash_size = cpu->bank[i].size;
			LOG_INFO("bank base = 0x%08" PRIx32 ", size = 0x%08" PRIx32 "", bank->base, *flash_size);
			return ERROR_OK;
		}
	}
	return ERROR_FLASH_OPERATION_FAILED;
}

static int numicro_probe(struct flash_bank *bank)
{
	uint32_t flash_size = 0, offset = 0;
	int num_pages;
	const struct numicro_cpu_type *cpu;
	struct target *target = bank->target;
	struct armv7m_common *armv7m = target_to_armv7m(target);
	int retval = ERROR_OK;

	retval = numicro_get_cpu_type(target, &cpu);
	if (retval != ERROR_OK) {
		LOG_WARNING("NuMicro flash driver: Failed to detect a known part");
		/* return ERROR_FLASH_OPERATION_FAILED; */
	}

	retval = numicro_get_flash_size(bank, cpu, &flash_size);
	if (retval != ERROR_OK) {
		LOG_WARNING("NuMicro flash driver: Failed to detect flash size");
		/* return ERROR_FLASH_OPERATION_FAILED; */
	}

	/* decide the page size */
	if (armv7m->arm.is_armv6m) { /* M0 */
		if (((cpu->partid & 0x00FFF000) == 0x00C56000/* M0564  */) ||
			((cpu->partid & 0x00FFF000) == 0x00C05000/* NUC126 */) ||
			((cpu->partid & 0xFFFF0F00) == 0x01130600/* M031G  */) ||
			((cpu->partid & 0xFFFF0F00) == 0x01130100/* M031I  */)) {
			m_pageSize = NUMICRO_PAGESIZE * 4;
		}
		else {
			m_pageSize = NUMICRO_PAGESIZE;
		}
	}
	else if (armv7m->arm.is_armv8m) { /* M23 */

		if (armv7m->arm.is_armv8mSecureExtend) {
			m_pageSize = NUMICRO_PAGESIZE * 4; /* for M2351 */
		}
		else {
			m_pageSize = NUMICRO_PAGESIZE;     /* for M251 */
		}
	}
	else { /* armv7m (M4) */
		if (((cpu->partid & 0x00FFF000) == 0x00D48000) ||
			((cpu->partid & 0x0FFFF000) == 0x01348000)) {
			m_pageSize = NUMICRO_PAGESIZE * 8; /* for M480 and M480LD */
		}
		else if (cpu->partid == 0x00550505) {
			m_pageSize = 0x1000; /* for NUC505 */
		}
		else {
			m_pageSize = NUMICRO_PAGESIZE * 4;
		}
	}
	LOG_DEBUG("Nuvoton pageSize: 0x%" PRIx32 "", m_pageSize);

	/* decide the flash information */
	if (((cpu->partid & 0x00FFF000) == 0x00D48000/* M480   */) ||
		((cpu->partid & 0x000FFF00) == 0x00056400/* M0564  */) ||
		((cpu->partid & 0x000FFF00) == 0x00012100/* NUC121 */) ||
		((cpu->partid & 0x000FFF00) == 0x00012500/* NUC125 */) ||
		((cpu->partid & 0x00FFFF00) == 0x00C05200/* NUC126 */) ||
		((cpu->partid & 0x00FFFF00) == 0x00A05800/* Mini58 */)) {
		m_flashInfo = NUMICRO_SPROM_MASK;
	}
	else {
		m_flashInfo = 0;
	}

	/* decide the target name */
	if (((cpu->partid & 0x00FFF000) == 0x00D48000) ||
		((cpu->partid & 0x0FFFF000) == 0x01348000)) {
		m_target_name = "M480";
	}
	else if (cpu->partid == 0x00550505) {
		m_target_name = "NUC505";
	}
	else if ((cpu->partid & 0x00FFFF00) == 0x00235500) {
		m_target_name = "M2354";
	}
	else {
		m_target_name = "common";
	}
	LOG_DEBUG("target name: %s", m_target_name);

	num_pages = flash_size / m_pageSize;
	bank->num_sectors = num_pages;
	bank->sectors = malloc(sizeof(struct flash_sector) * num_pages);
	bank->size = flash_size;

	for (int i = 0; i < num_pages; i++) {
		bank->sectors[i].offset = offset;
		bank->sectors[i].size = m_pageSize;
		bank->sectors[i].is_erased = -1;
		bank->sectors[i].is_protected = 0;
		offset += m_pageSize;
	}

	struct numicro_flash_bank *numicro_info = bank->driver_priv;
	numicro_info->probed = true;
	numicro_info->cpu = cpu;
	LOG_DEBUG("Nuvoton NuMicro: Probed ...");

	return ERROR_OK;
}

/* Standard approach to autoprobing. */
static int numicro_auto_probe(struct flash_bank *bank)
{
	struct numicro_flash_bank *numicro_info = bank->driver_priv;
	if (numicro_info->probed)
		return ERROR_OK;
	return numicro_probe(bank);
}

/* This is the function called in the config file. */
FLASH_BANK_COMMAND_HANDLER(numicro_flash_bank_command)
{
	struct numicro_flash_bank *bank_info;

	if (CMD_ARGC < 6)
		return ERROR_COMMAND_SYNTAX_ERROR;

	LOG_DEBUG("add flash_bank numicro %s", bank->name);

	bank_info = malloc(sizeof(struct numicro_flash_bank));

	memset(bank_info, 0, sizeof(struct numicro_flash_bank));

	bank->driver_priv = bank_info;

	return ERROR_OK;
}

COMMAND_HANDLER(numicro_handle_read_isp_command)
{
	uint32_t address;
	uint32_t ispdat;
	int retval = ERROR_OK;

	if (CMD_ARGC != 1)
		return ERROR_COMMAND_SYNTAX_ERROR;

	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address);

	struct target *target = get_current_target(CMD_CTX);

	numicro_get_arm_arch(target);
	retval = numicro_init_isp(target);
	if (retval != ERROR_OK)
		return retval;

	retval = numicro_fmc_cmd(target, ISPCMD_READ, address, 0, &ispdat);
	if (retval != ERROR_OK)
		return retval;

	LOG_INFO("numicro read_isp 0x%08" PRIx32 " 0x%08" PRIx32, address, ispdat);

	return ERROR_OK;
}

COMMAND_HANDLER(numicro_handle_write_isp_command)
{
	uint32_t address;
	uint32_t ispdat, rdat;
	int retval = ERROR_OK;

	if (CMD_ARGC != 2)
		return ERROR_COMMAND_SYNTAX_ERROR;

	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address);
	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], ispdat);

	struct target *target = get_current_target(CMD_CTX);

	numicro_get_arm_arch(target);
	retval = numicro_init_isp(target);
	if (retval != ERROR_OK)
		return retval;

	retval = numicro_fmc_cmd(target, ISPCMD_WRITE, address, ispdat, &rdat);
	if (retval != ERROR_OK)
		return retval;

	LOG_INFO("numicro write_isp 0x%08" PRIx32 " 0x%08" PRIx32, address, ispdat);
	return ERROR_OK;
}

COMMAND_HANDLER(numicro_handle_erase_isp_command)
{
	uint32_t address;
	uint32_t ispdat;
	int retval = ERROR_OK;

	if (CMD_ARGC != 1)
		return ERROR_COMMAND_SYNTAX_ERROR;

	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address);

	struct target *target = get_current_target(CMD_CTX);

	numicro_get_arm_arch(target);
	retval = numicro_init_isp(target);
	if (retval != ERROR_OK)
		return retval;

	retval = numicro_fmc_cmd(target, ISPCMD_ERASE, address, 0, &ispdat);
	if (retval != ERROR_OK)
		return retval;

	LOG_INFO("numicro erase_isp 0x%08" PRIx32 " 0x%08" PRIx32, address, ispdat);

	return ERROR_OK;
}

COMMAND_HANDLER(numicro_handle_chip_erase_command)
{
	int retval = ERROR_OK;
	uint32_t rdat;

	if (CMD_ARGC != 0)
		return ERROR_COMMAND_SYNTAX_ERROR;

	struct target *target = get_current_target(CMD_CTX);

	numicro_get_arm_arch(target);
	retval = numicro_init_isp(target);
	if (retval != ERROR_OK)
		return retval;

	retval = numicro_fmc_cmd(target, ISPCMD_CHIPERASE, 0, 0, &rdat);
	if (retval != ERROR_OK) {
		command_print(CMD_CTX, "numicro chip_erase failed");
		return retval;
	}

	if ((m_flashInfo & NUMICRO_SPROM_MASK) != 0) {
		LOG_DEBUG("SPROM is erasing");
		retval = numicro_fmc_cmd(target, ISPCMD_ERASE, NUMICRO_SPROM_BASE, NUMICRO_SPROM_ISPDAT, &rdat);
		if (retval != ERROR_OK)
			return retval;
	}

	command_print(CMD_CTX, "numicro chip_erase complete");

	return ERROR_OK;
}

extern int nulink_usb_M2351_erase();
COMMAND_HANDLER(numicro_handle_M2351_erase_command)
{
	int retval = ERROR_OK;
	uint32_t rdat;

	if (CMD_ARGC != 0)
		return ERROR_COMMAND_SYNTAX_ERROR;

	struct target *target = get_current_target(CMD_CTX);

	numicro_get_arm_arch(target);
	retval = numicro_init_isp(target);
	if (retval != ERROR_OK)
		return retval;

	retval = nulink_usb_M2351_erase();
	if (retval != ERROR_OK) {
		command_print(CMD_CTX, "numicro M2351_erase failed");
		return retval;
	}

	if ((m_flashInfo & NUMICRO_SPROM_MASK) != 0) {
		LOG_DEBUG("SPROM is erasing");

		retval = numicro_fmc_cmd(target, ISPCMD_ERASE, NUMICRO_SPROM_BASE, NUMICRO_SPROM_ISPDAT, &rdat);
		if (retval != ERROR_OK)
			return retval;
	}

	command_print(CMD_CTX, "numicro M2351_erase complete");

	return ERROR_OK;
}

COMMAND_HANDLER(numicro_handle_NUC505_sram_ini_command)
{
	unsigned long address = 0, length = 0;

	if (CMD_ARGC != 2)
		return ERROR_COMMAND_SYNTAX_ERROR;

	struct target *target = get_current_target(CMD_CTX);

	COMMAND_PARSE_NUMBER(ulong, CMD_ARGV[0], address);
	COMMAND_PARSE_NUMBER(ulong, CMD_ARGV[1], length);

	target_write_u32(target, 0x40000050, address);
	target_write_u32(target, 0x40000054, length);
	target_write_u32(target, 0x4000005C, 0x00000001);
	/* cpu reset */
	target_write_u32(target, 0x40000008, 0x00000001);
	/* wait for NUC505 IBR operations */
	busy_sleep(50);

	command_print(CMD_CTX, "numicro NUC505_sram_ini complete");

	return ERROR_OK;
}

COMMAND_HANDLER(numicro_handle_NUC505_chip_reset_command)
{
	if (CMD_ARGC != 0)
		return ERROR_COMMAND_SYNTAX_ERROR;

	struct target *target = get_current_target(CMD_CTX);

	/* cpu reset */
	target_write_u32(target, 0x40000008, 0x00000002);
	/* wait for NUC505 IBR operations */
	busy_sleep(50);

	command_print(CMD_CTX, "numicro NUC505_chip_reset complete");

	return ERROR_OK;
}

static const struct command_registration numicro_exec_command_handlers[] = {
	{
		.name = "read_isp",
		.handler = numicro_handle_read_isp_command,
		.usage = "address",
		.mode = COMMAND_EXEC,
		.help = "read flash through ISP.",
	},
	{
		.name = "write_isp",
		.handler = numicro_handle_write_isp_command,
		.usage = "address value",
		.mode = COMMAND_EXEC,
		.help = "write flash through ISP.",
	},
	{
		.name = "erase_isp",
		.handler = numicro_handle_erase_isp_command,
		.usage = "address",
		.mode = COMMAND_EXEC,
		.help = "erase flash through ISP.",
	},
	{
		.name = "chip_erase",
		.handler = numicro_handle_chip_erase_command,
		.mode = COMMAND_EXEC,
		.help = "chip erase through ISP.",
	},
	{
		.name = "M2351_erase",
		.handler = numicro_handle_M2351_erase_command,
		.mode = COMMAND_EXEC,
		.help = "M2351 erase command.",
	},
	{
		.name = "NUC505_sram_ini",
		.handler = numicro_handle_NUC505_sram_ini_command,
		.mode = COMMAND_EXEC,
		.help = "NUC505 sram initialization command.",
	},
	{
		.name = "NUC505_chip_reset",
		.handler = numicro_handle_NUC505_chip_reset_command,
		.mode = COMMAND_EXEC,
		.help = "NUC505 chip reset command.",
	},
	COMMAND_REGISTRATION_DONE
};

static const struct command_registration numicro_command_handlers[] = {
	{
		.name = "numicro",
		.mode = COMMAND_ANY,
		.help = "numicro flash command group",
		.usage = "",
		.chain = numicro_exec_command_handlers,
	},
	COMMAND_REGISTRATION_DONE
};

struct flash_driver numicro_flash = {
	.name = "numicro",
	.commands = numicro_command_handlers,
	.flash_bank_command = numicro_flash_bank_command,
	.erase = numicro_erase,
	.write = numicro_write,
	.read = default_flash_read,
	.probe = numicro_probe,
	.auto_probe = numicro_auto_probe,
	.erase_check = default_flash_blank_check,
	.protect_check = numicro_protect_check,
};