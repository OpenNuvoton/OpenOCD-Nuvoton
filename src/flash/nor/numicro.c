/***************************************************************************
 *   Copyright (C) 2011 by James K. Larson                                 *
 *   jlarson@pacifier.com                                                  *
 *                                                                         *
 *   Copyright (C) 2013 Cosmin Gorgovan                                    *
 *   cosmin [at] linux-geek [dot] org                                      *
 *                                                                         *
 *   Copyright (C) 2014 Pawel Si                                           *
 *   stawel+openocd@gmail.com                                              *
 *                                                                         *
 *   Copyright (C) 2015 Nemui Trinomius                                    *
 *   nemuisan_kawausogasuki@live.jp                                        *
 *                                                                         *
 *   Copyright (C) 2017 Zale Yu                                            *
 *   CYYU@nuvoton.com                                                      *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include "imp.h"
#include <helper/binarybuffer.h>
#include <target/algorithm.h>
#include <target/armv7m.h>
#include <target/cortex_m.h>

/* Nuvoton NuMicro register locations */
#define NUMICRO_SYS_BASE        0x50000000UL
#define NUMICRO_SYS_WRPROT      0x50000100UL
#define NUMICRO_SYS_IPRSTC1     0x50000008UL

#define NUMICRO_SYSCLK_BASE     0x50000200UL
#define NUMICRO_SYSCLK_PWRCON   0x50000200UL
#define NUMICRO_SYSCLK_CLKSEL0  0x50000210UL
#define NUMICRO_SYSCLK_CLKDIV   0x50000218UL
#define NUMICRO_SYSCLK_AHBCLK   0x50000204UL

#define NUMICRO_FLASH_BASE      0x5000C000UL
#define NUMICRO_FLASH_ISPCON    0x5000C000UL
#define NUMICRO_FLASH_ISPADR    0x5000C004UL
#define NUMICRO_FLASH_ISPDAT    0x5000C008UL
#define NUMICRO_FLASH_ISPCMD    0x5000C00CUL
#define NUMICRO_FLASH_ISPTRG    0x5000C010UL
#define NUMICRO_FLASH_CHEAT     0x5000C01CUL /* Undocumented isp register(may be cheat register) */

#define NUMICRO_SCS_BASE        0xE000E000UL
#define NUMICRO_SCS_AIRCR       0xE000ED0CUL
#define NUMICRO_SCS_DHCSR       0xE000EDF0UL
#define NUMICRO_SCS_DEMCR       0xE000EDFCUL
#define NUMICRO_CPUID           0xE000ED00UL

#define NUMICRO_APROM_BASE      0x00000000UL
#define NUMICRO_DATA_BASE       0x0001F000UL
#define NUMICRO_LDROM_BASE      0x00100000UL
#define NUMICRO_SPROM_BASE      0x00200000UL
#define NUMICRO_SPROM_BASE2     0x00240000UL
#define NUMICRO_SPROM_BASE3     0x00280000UL
#define NUMICRO_CONFIG_BASE     0x00300000UL
#define NUMICRO_DATA_DFMC_BASE  0x00400000UL

#define NUMICRO_CONFIG0         0x5000C000UL
#define NUMICRO_CONFIG1         0x5000C004UL

/* Command register bits */
#define PWRCON_OSC22M         (1 << 2)
#define PWRCON_XTL12M         (1 << 0)

#define IPRSTC1_CPU_RST       (1 << 1)
#define IPRSTC1_CHIP_RST      (1 << 0)

#define AHBCLK_ISP_EN         (1 << 2)
#define AHBCLK_SRAM_EN        (1 << 4)
#define AHBCLK_TICK_EN        (1 << 5)

#define ISPCON_ISPEN          (1 << 0)
#define ISPCON_BS_AP          (0 << 1)
#define ISPCON_BS_LP          (1 << 1)
#define ISPCON_BS_MASK        (1 << 1)
#define ISPCON_APUEN          (1 << 3)
#define ISPCON_CFGUEN         (1 << 4)
#define ISPCON_LDUEN          (1 << 5)
#define ISPCON_ISPFF          (1 << 6)

#define CONFIG0_LOCK_MASK     (1 << 1)

#define DHCSR_S_SDE           (1 << 20)

/* isp commands */
#define ISPCMD_READ           0x00U
#define ISPCMD_WRITE          0x21U
#define ISPCMD_ERASE          0x22U
#define ISPCMD_CHIPERASE      0x26U   /* Undocumented isp "Chip-Erase" command */
#define ISPCMD_READ_CID       0x0BU
#define ISPCMD_READ_UID       0x04U
#define ISPCMD_VECMAP         0x2EU
#define ISPTRG_ISPGO          (1 << 0)

/* access unlock keys */
#define REG_KEY1              0x59U
#define REG_KEY2              0x16U
#define REG_KEY3              0x88U
#define REG_LOCK              0x00U

/* flash page size */
#define NUMICRO_PAGESIZE        512
#define NUMICRO_DFMC_PAGESIZE   256
/* flash MAX banks */
#define NUMICRO_MAX_FLASH_BANKS 4
/* flash mask */
#define NUMICRO_TZ_MASK           0xEFFFFFFFUL
#define NUMICRO_SPROM_MASK        0x00000001UL
#define NUMICRO_SPROM_MINI57_MASK 0x00000002UL
#define NUMICRO_SPROM_ISPDAT      0x55AA03UL
/* SPIM flash start address */
#define NUMICRO_SPIM_FLASH_START_ADDRESS  0x8000000UL
/* M23 MFC ISP */
#define NUMICRO_M23_FMC_ISPSTS        0x4000C040UL
#define NUMICRO_M23_FMC_ISPSTS_VECMAP 0x00FFFE00UL

/* flash bank structs */
struct numicro_flash_bank_type {
	uint32_t base;
	uint32_t size;
};

/* part structs */
struct numicro_cpu_type {
	char *partname;
	uint32_t partid;
	unsigned int n_banks;
	struct numicro_flash_bank_type bank[NUMICRO_MAX_FLASH_BANKS];
};

/* If DataFlash size equals zero, it means the actual size depends on config settings. */
#define NUMICRO_BANKS_GENERAL(aprom_size, data_size, ldrom_size, config_size) \
	.n_banks = 4, \
	{{NUMICRO_APROM_BASE,  (aprom_size)}, \
	 {NUMICRO_DATA_BASE,   (data_size)}, \
	 {NUMICRO_LDROM_BASE,  (ldrom_size)}, \
	 {NUMICRO_CONFIG_BASE, (config_size)}}

#define NUMICRO_BANKS_DFMC(aprom_size, data_size, ldrom_size, config_size) \
	.n_banks = 4, \
	{{NUMICRO_APROM_BASE,  (aprom_size)}, \
	 {NUMICRO_DATA_DFMC_BASE,   (data_size)}, \
	 {NUMICRO_LDROM_BASE,  (ldrom_size)}, \
	 {NUMICRO_CONFIG_BASE, (config_size)}}

static const struct numicro_cpu_type NuMicroParts[] = {
	/*PART Name*//*PART ID*/ /*Banks*/
	/* M031 */
	{"M031LIAAE", 0x01131100, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 8*1024, 12)},
	{"M032LIAAE", 0x01132100, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 8*1024, 12)},
	{"M031SIAAE", 0x01131110, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 8*1024, 12)},
	{"M032SIAAE", 0x01132110, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 8*1024, 12)},
	{"M031KIAAE", 0x01131140, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 8*1024, 12)},
	{"M032KIAAE", 0x01132140, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 8*1024, 12)},
	{"M031LG8AE", 0x01131600, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M032LG8AE", 0x01132600, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M031SG8AE", 0x01131610, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M032SG8AE", 0x01132610, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M031KG8AE", 0x01131640, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M032KG8AE", 0x01132640, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M031LG6AE", 0x01131601, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M032LG6AE", 0x01132601, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M031SG6AE", 0x01131611, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M032SG6AE", 0x01132611, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M031KG6AE", 0x01131641, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M032KG6AE", 0x01132641, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M031LE3AE", 0x01131E00, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"M031SE3AE", 0x01131E10, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"M031BTYE3AN", 0x01131E90, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"M031TE3AE", 0x01131EE0, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"M032LE3AE", 0x01132E00, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"M032SE3AE", 0x01132E10, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"M032TD2AE", 0x01132DE0, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 2*1024, 12)},
	{"M032LD2AE", 0x01132D00, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 2*1024, 12)},
	{"M032TC2AE", 0x01132DE1, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M032LC2AE", 0x01132D01, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M030TD2AE", 0x01130DE0, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 2*1024, 12)},
	{"M030LD2AE", 0x01130D00, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 2*1024, 12)},
	{"M032FC1AE", 0x01132CB0, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M032EC1AE", 0x01132CA0, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M032TC1AE", 0x01132CE0, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M031TD2AE", 0x01131DE0, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 2*1024, 12)},
	{"M031BTYD2AN", 0x01131D90, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 2*1024, 12)},
	{"M031LD2AE", 0x01131D00, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 2*1024, 12)},
	{"M031LC2AE", 0x01131D01, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M031SD2AE", 0x01131D10, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 2*1024, 12)},
	{"M031SC2AE", 0x01131D11, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M031FC1AE", 0x01131CB0, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M031EC1AE", 0x01131CA0, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M031TC1AE", 0x01131CE0, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M031FB0AE", 0x01131BB0, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 2*1024, 12)},
	{"M031EB0AE", 0x01131BA0, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 2*1024, 12)},
	{"M031TB0AE", 0x01131BE0, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 2*1024, 12)},
	{"M030GGD1AE", 0x011306F0, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 2*1024, 12)},
	{"M030GGC1AE", 0x011306F2, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M030GTC1AE", 0x011306E2, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M030GTD1AE", 0x011306E0, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 2*1024, 12)},
	{"M030GGC0AE", 0x011306F1, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M030GTC0AE", 0x011306E1, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M030FD2AE", 0x01130DB0, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 2*1024, 12)},
	{"M031GGD2AE", 0x011316F0, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 2*1024, 12)},
	{"M031GTD2AE", 0x011316E0, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 2*1024, 12)},
	{"M031GGC2AE", 0x011316F2, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M031GTC2AE", 0x011316E2, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M031GGC1AE", 0x011316F1, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M031GTC1AE", 0x011316E1, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},

	/* M071 */
	{"M071MC2AE", 0x016071A5, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 4)},
	{"M071MD2AE", 0x016071A4, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 4)},
	{"M071R1D3AE", 0x01607193, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 8*1024, 8)},
	{"M071R1E3AE", 0x01607192, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 8*1024, 8)},
	{"M071SD3AE", 0x01607113, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 8*1024, 8)},
	{"M071SE3AE", 0x01607112, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 8*1024, 8)},
	{"M071QE4AE", 0x01607171, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M071QG4AE", 0x01607170, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M071VG4AE", 0x01607130, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},

	/* M0A21 */
	{"M0A21OB1AC", 0x015A2121, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 2*1024, 12)},
	{"M0A21OC1AC", 0x015A2120, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M0A21EB1AC", 0x015A21A1, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 2*1024, 12)},
	{"M0A21EC1AC", 0x015A21A0, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M0A23OC1AC", 0x015A2320, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},
	{"M0A23EC1AC", 0x015A23A0, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 2*1024, 12)},

	/* M051AN */
	{"M052LAN", 0x00005200, NUMICRO_BANKS_GENERAL(8*1024, 4*1024, 4*1024, 4)},
	{"M052ZAN", 0x00005203, NUMICRO_BANKS_GENERAL(8*1024, 4*1024, 4*1024, 4)},
	{"M054LAN", 0x00005400, NUMICRO_BANKS_GENERAL(16*1024, 4*1024, 4*1024, 4)},
	{"M054ZAN", 0x00005403, NUMICRO_BANKS_GENERAL(16*1024, 4*1024, 4*1024, 4)},
	{"M058LAN", 0x00005800, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 4)},
	{"M058ZAN", 0x00005803, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 4)},
	{"M0516LAN", 0x00005A00, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 4)},
	{"M0516ZAN", 0x00005A03, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 4)},

	/* M051BN */
	{"M052LBN", 0x10005200, NUMICRO_BANKS_GENERAL(8*1024, 4*1024, 4*1024, 4)},
	{"M052ZBN", 0x10005203, NUMICRO_BANKS_GENERAL(8*1024, 4*1024, 4*1024, 4)},
	{"M054LBN", 0x10005400, NUMICRO_BANKS_GENERAL(16*1024, 4*1024, 4*1024, 4)},
	{"M054ZBN", 0x10005403, NUMICRO_BANKS_GENERAL(16*1024, 4*1024, 4*1024, 4)},
	{"M058LBN", 0x10005800, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 4)},
	{"M058ZBN", 0x10005803, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 4)},
	{"M0516LBN", 0x10005A00, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 4)},
	{"M0516ZBN", 0x10005A03, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 4)},

	/* M051DN */
	{"M052LDN", 0x20005200, NUMICRO_BANKS_GENERAL(8*1024, 4*1024, 4*1024, 4)},
	{"M052ZDN", 0x20005203, NUMICRO_BANKS_GENERAL(8*1024, 4*1024, 4*1024, 4)},
	{"M054LDN", 0x20005400, NUMICRO_BANKS_GENERAL(16*1024, 4*1024, 4*1024, 4)},
	{"M054ZDN", 0x20005403, NUMICRO_BANKS_GENERAL(16*1024, 4*1024, 4*1024, 4)},
	{"M058LDN", 0x20005800, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 4)},
	{"M058ZDN", 0x20005803, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 4)},
	{"M0516LDN", 0x20005A00, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 4)},
	{"M0516ZDN", 0x20005A03, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 4)},

	/* M051DE */
	{"M052LDE", 0x30005200, NUMICRO_BANKS_GENERAL(8*1024, 4*1024, 4*1024, 4)},
	{"M052ZDE", 0x30005203, NUMICRO_BANKS_GENERAL(8*1024, 4*1024, 4*1024, 4)},
	{"M054LDE", 0x30005400, NUMICRO_BANKS_GENERAL(16*1024, 4*1024, 4*1024, 4)},
	{"M054ZDE", 0x30005403, NUMICRO_BANKS_GENERAL(16*1024, 4*1024, 4*1024, 4)},
	{"M058LDE", 0x30005800, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 4)},
	{"M058ZDE", 0x30005803, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 4)},
	{"M058MDE", 0x30005807, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 4)},
	{"M0516LDE", 0x30005A00, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 4)},
	{"M0516ZDE", 0x30005A03, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 4)},
	{"M0515LDE", 0x11413103, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 4)},

	/* M0518 */
	{"M0518LC2AE", 0x10051803, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"M0518LD2AE", 0x10051800, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"M0518SC2AE", 0x10051813, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"M0518SD2AE", 0x10051810, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},

	/* M0519 */
	{"M0519VE3AE", 0x00051930, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 8*1024, 8)},
	{"M0519SE3AE", 0x00051920, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 8*1024, 8)},
	{"M0519SD3AE", 0x00051922, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 8*1024, 8)},
	{"M0519LE3AE", 0x00051900, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 8*1024, 8)},
	{"M0519LD3AE", 0x00051902, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 8*1024, 8)},

	/* M058S */
	{"M058SFAN", 0x00005818, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 4)},
	{"M058SZAN", 0x00005813, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 4)},
	{"M058SLAN", 0x00005810, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 4)},
	{"M058SSAN", 0x00005816, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 4)},

	/* M0564 */
	{"M0564LE4AE", 0x00C56405, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M0564LG4AE", 0x00C56404, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M0564SE4AE", 0x00C56413, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M0564SG4AE", 0x00C56412, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M0564VG4AE", 0x00C56431, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M0564KG4AE", 0x00C56440, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},

	/* M05641 */
	{"M05641SG4AE", 0x01256412, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M05641SE4AE", 0x01256413, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M05641LG4AE", 0x01256404, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M05641LE4AE", 0x01256405, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},

	/* MINI51AN */
	{"MINI51LAN", 0x00205100, NUMICRO_BANKS_GENERAL(4*1024, 0*1024, 2*1024, 8)},
	{"MINI51ZAN", 0x00205103, NUMICRO_BANKS_GENERAL(4*1024, 0*1024, 2*1024, 8)},
	{"MINI51TAN", 0x00205104, NUMICRO_BANKS_GENERAL(4*1024, 0*1024, 2*1024, 8)},
	{"MINI52LAN", 0x00205200, NUMICRO_BANKS_GENERAL(8*1024, 0*1024, 2*1024, 8)},
	{"MINI52ZAN", 0x00205203, NUMICRO_BANKS_GENERAL(8*1024, 0*1024, 2*1024, 8)},
	{"MINI52TAN", 0x00205204, NUMICRO_BANKS_GENERAL(8*1024, 0*1024, 2*1024, 8)},
	{"MINI54LAN", 0x00205400, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 2*1024, 8)},
	{"MINI54ZAN", 0x00205403, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 2*1024, 8)},
	{"MINI54TAN", 0x00205404, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 2*1024, 8)},

	{"MINI51XLAE", 0x00505100, NUMICRO_BANKS_GENERAL(4*1024, 0*1024, 2*1024, 8)},
	{"MINI51XZAE", 0x00505102, NUMICRO_BANKS_GENERAL(4*1024, 0*1024, 2*1024, 8)},
	{"MINI52XLAE", 0x00505200, NUMICRO_BANKS_GENERAL(8*1024, 0*1024, 2*1024, 8)},
	{"MINI52XZAE", 0x00505203, NUMICRO_BANKS_GENERAL(8*1024, 0*1024, 2*1024, 8)},
	{"MINI54XLAE", 0x00505400, NUMICRO_BANKS_GENERAL(35*512, 0*1024, 2*1024, 8)},
	{"MINI54XZAE", 0x00505403, NUMICRO_BANKS_GENERAL(35*512, 0*1024, 2*1024, 8)},
	{"MINI54XFHC", 0x00505406, NUMICRO_BANKS_GENERAL(35*512, 0*1024, 2*1024, 8)},

	/* MINI51DE */
	{"MINI51LDE", 0x20205100, NUMICRO_BANKS_GENERAL(4*1024, 0*1024, 2*1024, 8)},
	{"MINI51QDE", 0x20205101, NUMICRO_BANKS_GENERAL(4*1024, 0*1024, 2*1024, 8)},
	{"MINI51ZDE", 0x20205103, NUMICRO_BANKS_GENERAL(4*1024, 0*1024, 2*1024, 8)},
	{"MINI51TDE", 0x20205104, NUMICRO_BANKS_GENERAL(4*1024, 0*1024, 2*1024, 8)},
	{"MINI51FDE", 0x20205105, NUMICRO_BANKS_GENERAL(4*1024, 0*1024, 2*1024, 8)},
	{"MINI52LDE", 0x20205200, NUMICRO_BANKS_GENERAL(8*1024, 0*1024, 2*1024, 8)},
	{"MINI52QDE", 0x20205201, NUMICRO_BANKS_GENERAL(8*1024, 0*1024, 2*1024, 8)},
	{"MINI52ZDE", 0x20205203, NUMICRO_BANKS_GENERAL(8*1024, 0*1024, 2*1024, 8)},
	{"MINI52TDE", 0x20205204, NUMICRO_BANKS_GENERAL(8*1024, 0*1024, 2*1024, 8)},
	{"MINI52FDE", 0x20205205, NUMICRO_BANKS_GENERAL(8*1024, 0*1024, 2*1024, 8)},
	{"MINI54LDE", 0x20205400, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 2*1024, 8)},
	{"MINI54QDE", 0x20205401, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 2*1024, 8)},
	{"MINI54ZDE", 0x20205403, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 2*1024, 8)},
	{"MINI54TDE", 0x20205404, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 2*1024, 8)},
	{"MINI54FDE", 0x20205405, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 2*1024, 8)},
	{"MINI54FHC", 0x20205406, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 2*1024, 8)},

	/* MINI55 */
	{"MINI55LDE", 0x00505500, NUMICRO_BANKS_GENERAL(35*512, 0*1024, 2*1024, 8)},
	{"MINI55ZDE", 0x00505503, NUMICRO_BANKS_GENERAL(35*512, 0*1024, 2*1024, 8)},
	{"MINI55TDE", 0x00505504, NUMICRO_BANKS_GENERAL(35*512, 0*1024, 2*1024, 8)},

	/* MINI57 */
	{"MINI57FDE", 0x00B05720, NUMICRO_BANKS_GENERAL(59*512, 0*1024, 2*1024, 8)},
	{"MINI57EDE", 0x00B05740, NUMICRO_BANKS_GENERAL(59*512, 0*1024, 2*1024, 8)},
	{"MINI57XDE", 0x00B05750, NUMICRO_BANKS_GENERAL(59*512, 0*1024, 2*1024, 8)},
	{"MINI57TDE", 0x00B05760, NUMICRO_BANKS_GENERAL(59*512, 0*1024, 2*1024, 8)},

	/* MINI58 */
	{"MINI58LDE", 0x00A05800, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 5*512, 12)},
	{"MINI58QDE", 0x00A05801, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 5*512, 12)},
	{"MINI58ZDE", 0x00A05803, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 5*512, 12)},
	{"MINI58TDE", 0x00A05804, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 5*512, 12)},
	{"MINI58FDE", 0x00A05805, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 5*512, 12)},

	/* Nano100AN */
	{"Nano100ZC2AN", 0x00110029, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"Nano100ZD2AN", 0x00110028, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano100ZD3AN", 0x00110027, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano100LC2AN", 0x00110025, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"Nano100LD2AN", 0x00110019, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano100LD3AN", 0x00110018, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano100SC2AN", 0x00110023, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"Nano100SD2AN", 0x00110016, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano100SD3AN", 0x00110015, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano100VD2AN", 0x00110013, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano100VD3AN", 0x00110012, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano120ZC2AN", 0x00112029, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"Nano120ZD2AN", 0x00112028, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano120ZD3AN", 0x00112027, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano120LC2AN", 0x00112025, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"Nano120LD2AN", 0x00112019, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano120LD3AN", 0x00112018, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano120SC2AN", 0x00112023, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"Nano120SD2AN", 0x00112016, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano120SD3AN", 0x00112015, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano120VD2AN", 0x00112013, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano120VD3AN", 0x00112012, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano130VD3AN", 0x00113012, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},

	/* Nano100BN */
	{"Nano100LC2BN", 0x00110043, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"Nano100LD2BN", 0x0011003F, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano100LD3BN", 0x0011003E, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano100LE3BN", 0x00110036, NUMICRO_BANKS_GENERAL(123*1024, 0*1024, 4*1024, 8)},
	{"Nano100SC2BN", 0x00110042, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"Nano100SD2BN", 0x0011003D, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano100SD3BN", 0x0011003C, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano100SE3BN", 0x00110034, NUMICRO_BANKS_GENERAL(123*1024, 0*1024, 4*1024, 8)},
	{"Nano100KC2BN", 0x00110040, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano100KD2BN", 0x00110039, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano100KD3BN", 0x00110038, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano100KE3BN", 0x00110030, NUMICRO_BANKS_GENERAL(123*1024, 0*1024, 4*1024, 8)},
	{"Nano100NE3BN", 0x00110044, NUMICRO_BANKS_GENERAL(123*1024, 0*1024, 4*1024, 8)},
	{"Nano100ND3BN", 0x00110045, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano100ND2BN", 0x00110046, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano100WE3BN", 0x00110047, NUMICRO_BANKS_GENERAL(123*1024, 0*1024, 4*1024, 8)},
	{"Nano110SC2BN", 0x00111042, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"Nano110SD2BN", 0x0011103D, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano110SD3BN", 0x0011103C, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano110SE3BN", 0x00111034, NUMICRO_BANKS_GENERAL(123*1024, 0*1024, 4*1024, 8)},
	{"Nano110RC2BN", 0x00111043, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"Nano110RD2BN", 0x00111044, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano110RD3BN", 0x00111045, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano110KC2BN", 0x00111040, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"Nano110KD2BN", 0x00111039, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano110KD3BN", 0x00111038, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano110KE3BN", 0x00111030, NUMICRO_BANKS_GENERAL(123*1024, 0*1024, 4*1024, 8)},
	{"Nano120LC2BN", 0x00112043, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"Nano120LD2BN", 0x0011203F, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano120LD3BN", 0x0011203E, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano120LE3BN", 0x00112036, NUMICRO_BANKS_GENERAL(123*1024, 0*1024, 4*1024, 8)},
	{"Nano120SC2BN", 0x00112042, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"Nano120SD2BN", 0x0011203D, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano120SD3BN", 0x0011203C, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano120SE3BN", 0x00112034, NUMICRO_BANKS_GENERAL(123*1024, 0*1024, 4*1024, 8)},
	{"Nano120KC2BN", 0x00112040, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"Nano120KD2BN", 0x00112039, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano120KD3BN", 0x00112038, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano120KE3BN", 0x00112030, NUMICRO_BANKS_GENERAL(123*1024, 0*1024, 4*1024, 8)},
	{"Nano130SC2BN", 0x00113042, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"Nano130SD2BN", 0x0011303D, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano130SD3BN", 0x0011303C, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano130SE3BN", 0x00113034, NUMICRO_BANKS_GENERAL(123*1024, 0*1024, 4*1024, 8)},
	{"Nano130KC2BN", 0x00113040, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"Nano130KD2BN", 0x00113039, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano130KD3BN", 0x00113038, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"Nano130KE3BN", 0x00113030, NUMICRO_BANKS_GENERAL(123*1024, 0*1024, 4*1024, 8)},

	/* Nano103 */
	{"Nano103SD3AE", 0x00110301, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"Nano103SD2AE", 0x00110302, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"Nano103SD1AE", 0x00110303, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"Nano103LD3AE", 0x00110304, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"Nano103LD2AE", 0x00110305, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"Nano103LD1AE", 0x00110306, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"Nano103ZD3AE", 0x00110307, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"Nano103ZD2AE", 0x00110308, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"Nano103ZD1AE", 0x00110309, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"Nano103SC3AE", 0x00110316, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 12)},
	{"Nano103SC2AE", 0x00110310, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 12)},
	{"Nano103SC1AE", 0x00110311, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 12)},
	{"Nano103LC3AE", 0x00110317, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 12)},
	{"Nano103LC2AE", 0x00110312, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 12)},
	{"Nano103LC1AE", 0x00110313, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 12)},
	{"Nano103ZC3AE", 0x00110318, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 12)},
	{"Nano103ZC2AE", 0x00110314, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 12)},
	{"Nano103ZC1AE", 0x00110315, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 12)},

	/* Nano112AN */
	{"Nano102ZB1AN", 0x00110202, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 4*1024, 8)},
	{"Nano102ZC2AN", 0x00110204, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"Nano102LB1AN", 0x00110206, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 4*1024, 8)},
	{"Nano102LC2AN", 0x00110208, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"Nano102SC2AN", 0x00110212, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"Nano112LB1AN", 0x00111202, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 4*1024, 8)},
	{"Nano112LC2AN", 0x00111204, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"Nano112SB1AN", 0x00111206, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 4*1024, 8)},
	{"Nano112SC2AN", 0x00111208, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"Nano112RB1AN", 0x00111210, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 4*1024, 8)},
	{"Nano112RC2AN", 0x00111212, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},
	{"Nano112VC2AN", 0x00111216, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 8)},

	/* NDA102 */
	{"NDA102SD2", 0x00F25112, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},

	/* NUC029 */
	{"NUC029LAN", 0x00295A00, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 4)},
	{"NUC029NAN", 0x00295A06, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 4)},
	{"NUC029TAN", 0x00295804, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 4)},
	{"NUC029ZAN", 0x00295A03, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 4)},

	{"NUC029FAE", 0x00295415, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 2*1024, 8)},
	{"NUC029TAE", 0x30295804, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 4)},

	{"NUC029CIG1", 0x00295824, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},

	{"NUC029LDE", 0x00295A30, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC029SDE", 0x00295A31, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC029MDE", 0x00295A37, NUMICRO_BANKS_GENERAL(68*1024, 0*1024, 4*1024, 8)},
	{"NUC029LEE", 0x00295B40, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 8*1024, 8)},
	{"NUC029SEE", 0x00295B41, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 8*1024, 8)},
	{"NUC029KGE", 0x00295C52, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"NUC029LGE", 0x00295C50, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"NUC029SGE", 0x00295C51, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},

	/* NUC100AN */
	{"NUC100LD3AN", 0x00010003, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100LE3AN", 0x00010000, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC100RD3AN", 0x00010012, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100RE3AN", 0x00010009, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC100VD2AN", 0x00010022, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100VD3AN", 0x00010021, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100VE3AN", 0x00100018, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC120LD3AN", 0x00012003, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120LE3AN", 0x00120000, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC120RD3AN", 0x00012012, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120RE3AN", 0x00012009, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC120VD2AN", 0x00012022, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120VD3AN", 0x00012021, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120VE3AN", 0x00012018, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},

	/* NUC100BN */
	{"NUC100LC1BN", 0x10010008, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC100LD1BN", 0x10010005, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100LD2BN", 0x10010004, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100RC1BN", 0x10010017, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC100RD1BN", 0x10010014, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100RD2BN", 0x10010013, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120LC1BN", 0x10012008, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC120LD1BN", 0x10012005, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120LD2BN", 0x10012004, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120RC1BN", 0x10012017, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC120RD1BN", 0x10012014, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120RD2BN", 0x10012013, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},

	/* NUC100CN */
	{"NUC130LC1CN", 0x20013008, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC130LD2CN", 0x20013004, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC130LE3CN", 0x20013000, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC130RC1CN", 0x20013017, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC130RD2CN", 0x20013013, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC130RE3CN", 0x20013009, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC130VE3CN", 0x20013018, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC140LC1CN", 0x20014008, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC140LD2CN", 0x20014004, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC140LE3CN", 0x20014000, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC140RC1CN", 0x20014017, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC140RD2CN", 0x20014013, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC140RE3CN", 0x20014009, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC140VE3CN", 0x20014018, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},

	/* NUC100DN */
	{"NUC100LC1DN", 0x30010008, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC100LD1DN", 0x30010005, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100LD2DN", 0x30010004, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100LD3DN", 0x30010003, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100LE3DN", 0x30010000, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC100RC1DN", 0x30010017, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC100RD1DN", 0x30010014, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100RD2DN", 0x30010013, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100RD3DN", 0x30010012, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100RE3DN", 0x30010009, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC100VD2DN", 0x30010022, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100VD3DN", 0x30010021, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC100VE3DN", 0x30010018, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC100VE3DE", 0x40010018, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC120LC1DN", 0x30012008, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC120LD1DN", 0x30012005, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120LD2DN", 0x30012004, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120LD2DE", 0x40012004, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120LD3DN", 0x30012003, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120LE3DN", 0x30012000, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC120RC1DN", 0x30012035, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC120RD1DN", 0x30012032, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120RD2DN", 0x30012031, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120RD3DN", 0x30012030, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120RE3DN", 0x30012027, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC120VD2DN", 0x30012022, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120VD3DN", 0x30012021, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC120VE3DN", 0x30012018, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC122ZD2DN", 0x30012231, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC122LD2DN", 0x30012204, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC122SD2DN", 0x30012222, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC122ZC1DN", 0x30012235, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC122LC1DN", 0x30012208, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC122SC1DN", 0x30012226, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},

	/* NUC121 */
	{"NUC121WC2AE", 0x00012180, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 9*512, 12)},
	{"NUC121Y25CN", 0x00012160, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 9*512, 12)},
	{"NUC121ZC2AE", 0x00012145, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 9*512, 12)},
	{"NUC121LC2AE", 0x00012125, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 9*512, 12)},
	{"NUC121SC2AE", 0x00012105, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 9*512, 12)},
	{"NUC125ZC2AE", 0x00012545, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 9*512, 12)},
	{"NUC125LC2AE", 0x00012525, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 9*512, 12)},
	{"NUC125SC2AE", 0x00012505, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 9*512, 12)},

	/* NUC122 */
	{"NUC122ZC1AN", 0x00012235, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024,4)},
	{"NUC122ZD2AN", 0x00012231, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024,4)},
	{"NUC122LC1AN", 0x00012208, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024,4)},
	{"NUC122LD2AN", 0x00012204, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024,4)},
	{"NUC122SC1AN", 0x00012226, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024,4)},
	{"NUC122SD2AN", 0x00012222, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024,4)},

	/* NUC123 */
	{"NUC123ZC2AN1", 0x00012345, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC123ZD4AN0", 0x00012355, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC123LC2AN1", 0x00012325, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC123LD4AN0", 0x00012335, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC123SC2AN1", 0x00012305, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC123SD4AN0", 0x00012315, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC123ZC2AE1", 0x10012345, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC123ZD4AE0", 0x10012355, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC123LC2AE1", 0x10012325, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC123LD4AE0", 0x10012335, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC123SC2AE1", 0x10012305, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC123SD4AE0", 0x10012315, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},

	/* NUC126 */
	{"NUC126NE4AE", 0x00C05206, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC126LE4AE", 0x00C05205, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC126LG4AE", 0x00C05204, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"NUC126SE4AE", 0x00C05213, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC126SG4AE", 0x00C05212, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"NUC126VG4AE", 0x00C05231, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"NUC126KG4AE", 0x00C05230, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},

	/* NUC1261 */
	{"NUC1261SG4AE", 0x01205212, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"NUC1261SE4AE", 0x01205213, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC1261LG4AE", 0x01205204, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"NUC1261LE4AE", 0x01205205, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC1261NE4AE", 0x01205206, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},

	/* NUC1262 */
	{"NUC1262SE4AE", 0x01812610, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC1262LE4AE", 0x01812600, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC1262NE4AE", 0x01812690, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},

	/* NUC131AE */
	{"NUC131LC2AE", 0x10013103, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC131LD2AE", 0x10013100, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC131SC2AE", 0x10013113, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC131SD2AE", 0x10013110, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC131LC2AEU", 0xF0013103, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC131LD2AEU", 0xF0013100, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC131SC2AEU", 0xF0013113, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC131SD2AEU", 0xF0013110, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},

	/* NUC1311 */
	{"NUC1311LD2AE", 0x11413100, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC1311LC2AE", 0x11413101, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},

	/* NUC200/220AN */
	{"NUC200LC2AN", 0x00020007, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC200LD2AN", 0x00020004, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC200LE3AN", 0x00020000, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC200SC2AN", 0x00020034, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC200SD2AN", 0x00020031, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC200SE3AN", 0x00020027, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC200VE3AN", 0x00020018, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC220LC2AN", 0x00022007, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC220LD2AN", 0x00022004, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC220LE3AN", 0x00022000, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC220SC2AN", 0x00022034, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 4*1024, 8)},
	{"NUC220SD2AN", 0x00022031, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 4*1024, 8)},
	{"NUC220SE3AN", 0x00022027, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC220VE3AN", 0x00022018, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"NUC220LE3AE", 0x40022000, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},

	/* NUC230/240AE */
	{"NUC230RC1AE", 0x40013017, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 8*1024, 8)},
	{"NUC230LC2AE", 0x10023007, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 8*1024, 8)},
	{"NUC230LD2AE", 0x10023004, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 8*1024, 8)},
	{"NUC230LE3AE", 0x10023000, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 8*1024, 8)},
	{"NUC230SC2AE", 0x10023034, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 8*1024, 8)},
	{"NUC230SD2AE", 0x10023031, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 8*1024, 8)},
	{"NUC230SE3AE", 0x10023027, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 8*1024, 8)},
	{"NUC230VE3AE", 0x10023018, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 8*1024, 8)},
	{"NUC240LC2AE", 0x10024007, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 8*1024, 8)},
	{"NUC240LD2AE", 0x10024004, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 8*1024, 8)},
	{"NUC240LE3AE", 0x10024000, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 8*1024, 8)},
	{"NUC240SC2AE", 0x10024034, NUMICRO_BANKS_GENERAL(32*1024, 4*1024, 8*1024, 8)},
	{"NUC240SD2AE", 0x10024031, NUMICRO_BANKS_GENERAL(64*1024, 4*1024, 8*1024, 8)},
	{"NUC240SE3AE", 0x10024027, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 8*1024, 8)},
	{"NUC240VE3AE", 0x10024018, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 8*1024, 8)},

	/* NUC2201 */
	{"NUC2201LE3AE", 0x20024000, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 8*1024, 8)},
	{"NUC2201SE3AE", 0x20024027, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 8*1024, 8)},

	/* M451 */
	{"M451VG6AE", 0x00845130, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M451VE6AE", 0x00845131, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M451RG6AE", 0x00845120, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M451RE6AE", 0x00845121, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M451LG6AE", 0x00845100, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M451LE6AE", 0x00845101, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M451VD3AE", 0x00945130, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M451VC3AE", 0x00945131, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M451RD3AE", 0x00945120, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M451RC3AE", 0x00945121, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M451SD3AE", 0x00945110, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M451SC3AE", 0x00945111, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M451LD3AE", 0x00945100, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M451LC3AE", 0x00945101, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M451YD3AE", 0x009451F0, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M451YC3AE", 0x009451F1, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M452VG6AE", 0x00845230, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M452VE6AE", 0x00845231, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M452RG6AE", 0x00845220, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M452RE6AE", 0x00845221, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M452SG6AE", 0x00845210, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M452SE6AE", 0x00845211, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M452LG6AE", 0x00845200, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M452LE6AE", 0x00845201, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M452VD3AE", 0x00945230, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M452VC3AE", 0x00945231, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M452RD3AE", 0x00945220, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M452RC3AE", 0x00945221, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M452SD3AE", 0x00945210, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M452SC3AE", 0x00945211, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M452LD3AE", 0x00945200, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M452LC3AE", 0x00945201, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M452YD3AE", 0x009452F0, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M452YC3AE", 0x009452F1, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M453VG6AE", 0x00845330, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M453VE6AE", 0x00845331, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M453RG6AE", 0x00845320, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M453RE6AE", 0x00845321, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M453LG6AE", 0x00845300, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M453LE6AE", 0x00845301, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M453VD3AE", 0x00945330, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M453VC3AE", 0x00945331, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M453RD3AE", 0x00945320, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M453RC3AE", 0x00945321, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M453SD3AE", 0x00945310, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M453SC3AE", 0x00945311, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M453LD3AE", 0x00945300, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M453LC3AE", 0x00945301, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M453YD3AE", 0x009453F0, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M453YC3AE", 0x009453F1, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M451MRG6AE", 0x00845020, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M451MRE6AE", 0x00845021, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M451MLG6AE", 0x00845000, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M451MLE6AE", 0x00845001, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M451MRD3AE", 0x00945020, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M451MRC3AE", 0x00945021, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M451MSD3AE", 0x00945010, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M451MSC3AE", 0x00945011, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M451MLD3AE", 0x00945000, NUMICRO_BANKS_GENERAL(72*1024, 0*1024, 4*1024, 8)},
	{"M451MLC3AE", 0x00945001, NUMICRO_BANKS_GENERAL(40*1024, 0*1024, 4*1024, 8)},
	{"M4LEDLG6AE", 0x00845700, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M4LEDLE6AE", 0x00845701, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M4LEDRG6AE", 0x00845720, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M4LEDRE6AE", 0x00845721, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M4TKLE6AE", 0x00845401, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M4TKLG6AE", 0x00845400, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M4TKRE6AE", 0x00845421, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M4TKRG6AE", 0x00845420, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},
	{"M4TKVE6AE", 0x00845431, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M4TKVG6AE", 0x00845430, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 8)},

	/* M4521 */
	{"M4521RE6AE", 0x00E45220, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M4521RD6AE", 0x00E45221, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"M4521SE6AE", 0x00E45210, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M4521SD6AE", 0x00E45211, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"M4521LE6AE", 0x00E45200, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M4521LD6AE", 0x00E45201, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},

	/* NUC442_472 */
	{"NUC442RG8AE", 0x00044212, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 16*1024, 8)},
	{"NUC442RI8AE", 0x00044210, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 16*1024, 8)},
	{"NUC442VG8AE", 0x00044209, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 16*1024, 8)},
	{"NUC442VI8AE", 0x00044207, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 16*1024, 8)},
	{"NUC442KG8AE", 0x00044206, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 16*1024, 8)},
	{"NUC442KI8AE", 0x00044204, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 16*1024, 8)},
	{"NUC442JG8AE", 0x00044203, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 16*1024, 8)},
	{"NUC442JI8AE", 0x00044201, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 16*1024, 8)},
	{"NUC472VG8AE", 0x00047212, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 16*1024, 8)},
	{"NUC472VI8AE", 0x00047210, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 16*1024, 8)},
	{"NUC472KG8AE", 0x00047209, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 16*1024, 8)},
	{"NUC472KI8AE", 0x00047207, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 16*1024, 8)},
	{"NUC472JG8AE", 0x00047206, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 16*1024, 8)},
	{"NUC472JI8AE", 0x00047204, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 16*1024, 8)},
	{"NUC472HG8AE", 0x00047203, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 16*1024, 8)},
	{"NUC472HI8AE", 0x00047201, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 16*1024, 8)},

	/* M471 */
	{"M471KI8AE", 0x01647140, NUMICRO_BANKS_DFMC(512*1024, 32*1024, 4*1024, 8)},
	{"M471VI8AE", 0x01647130, NUMICRO_BANKS_DFMC(512*1024, 32*1024, 4*1024, 8)},
	{"M471VG7AE", 0x01647131, NUMICRO_BANKS_DFMC(256*1024, 32*1024, 4*1024, 8)},
	{"M471QI8AE", 0x01647170, NUMICRO_BANKS_DFMC(512*1024, 32*1024, 4*1024, 8)},
	{"M471QG7AE", 0x01647171, NUMICRO_BANKS_DFMC(256*1024, 32*1024, 4*1024, 8)},
	{"M471R1E6AE", 0x01647192, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M471R1D6AE", 0x01647193, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"M471SE6AE", 0x01647112, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 8)},
	{"M471SD6AE", 0x01647113, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},
	{"M471MD6AE", 0x016471A3, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 8)},

	/* M479 */
	{"M479SG8AE", 0x01347911, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M479LG8AE", 0x01347901, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M479NG8AE", 0x01347991, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},

	/* M480 */
	{"M481KIDAE", 0x00D48140, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M481KGAAE", 0x00D48141, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M481SIDAE", 0x00D48110, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M481SGAAE", 0x00D48111, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M481LIDAE", 0x00D48100, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M481LGAAE", 0x00D48101, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M481ZIDAE", 0x00D481E0, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M481ZGAAE", 0x00D481E1, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M481ZGDAE", 0x00D481E2, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M482JIDAE", 0x00D48250, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M482JGAAE", 0x00D48251, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M482KIDAE", 0x00D48240, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M482KGAAE", 0x00D48241, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M482VIDAE", 0x00D48230, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M482VGAAE", 0x00D48231, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M482SIDAE", 0x00D48210, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M482SGAAE", 0x00D48211, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M482SIDAE3O", 0x00D48212, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M482LIDAE", 0x00D48200, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M482LGAAE", 0x00D48201, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M482ZIDAE", 0x00D482E0, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M483JIDAE", 0x00D48350, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M483JGAAE", 0x00D48351, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M483KIDAE", 0x00D48340, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M483KGAAE", 0x00D48341, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M483VIDAE", 0x00D48330, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M483VGAAE", 0x00D48331, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M483SIDAE", 0x00D48310, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M483SGAAE", 0x00D48311, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M483LIDAE", 0x00D48300, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M483LGAAE", 0x00D48301, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M484KIDAE", 0x00D48440, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M484KGAAE", 0x00D48441, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M484SIDAE", 0x00D48410, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M484SGAAE", 0x00D48411, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M484SIDAE2U", 0x00D48412, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M484SGAAE2U", 0x00D48413, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M485JIDAE", 0x00D48550, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M485JGAAE", 0x00D48551, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M485KIDAE", 0x00D48540, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M485KGAAE", 0x00D48541, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M485VIDAE", 0x00D48530, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M485VGAAE", 0x00D48531, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M485OIDAE", 0x00D48580, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M485OGAAE", 0x00D48581, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M485SIDAE", 0x00D48510, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M485SGAAE", 0x00D48511, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M485LIDAE", 0x00D48500, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M485ZIDAE", 0x00D485E0, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M486JIDAE", 0x00D48650, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M486KIDAE", 0x00D48640, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M487JIDAE", 0x00D48750, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M487JGAAE", 0x00D48751, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M487KIDAE", 0x00D48740, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M487KMCAN", 0x00D4874E, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M487KGAAE", 0x00D48741, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M487SIDAE", 0x00D48710, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M487SGAAE", 0x00D48711, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},

	/* M480LD */
	{"M481SGCAE", 0x01348110, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M481SG8AE", 0x01348111, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M481SE8AE", 0x01348112, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 16)},
	{"M481SGCAE2A", 0x01348114, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M481SG8AE2A", 0x01348115, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M481LGCAE", 0x01348100, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M481LG8AE", 0x01348101, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M481LE8AE", 0x01348102, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 16)},
	{"M481ZGCAE", 0x013481E0, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M481ZG8AE", 0x013481E1, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M481ZE8AE", 0x013481E2, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 16)},
	{"M482KGCAE", 0x01348240, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M482KG8AE", 0x01348241, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M482SGCAE", 0x01348210, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M482SG8AE", 0x01348211, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M482SE8AE", 0x01348212, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 16)},
	{"M482LGCAE", 0x01348200, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M482LG8AE", 0x01348201, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M482LE8AE", 0x01348202, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 16)},
	{"M482ZGCAE", 0x013482E0, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M482ZG8AE", 0x013482E1, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M482ZE8AE", 0x013482E2, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 16)},
	{"M483KGCAE", 0x01348340, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M483KG8AE", 0x01348341, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M483SGCAE", 0x01348310, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M483SG8AE", 0x01348311, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M483SE8AE", 0x01348312, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 16)},
	{"M483KGCAE2A", 0x01348344, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M483KG8AE2A", 0x01348345, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M483SGCAE2A", 0x01348314, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},
	{"M483SG8AE2A", 0x01348315, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 16)},

	/* NUC505 */
	{"NUC505", 0x00550505, NUMICRO_BANKS_GENERAL(0x1000000, 0*1024, 0*1024, 0)},

	/* M2351 */
	{"M2351KIAAE", 0x00235100, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M2351SIAAE", 0x00235101, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M2351ZIAAE", 0x00235103, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
	{"M2351SFSIAAP", 0x00235300, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},

	/* M2354 */
	{"M2354ES", 0x00235500, NUMICRO_BANKS_GENERAL(0x10100000, 0*1024, 16*1024, 16)},
	{"M2354MP", 0x00235400, NUMICRO_BANKS_GENERAL(0x10100000, 0*1024, 16*1024, 16)},
	{"M2354KJFAE", 0xA1735440, NUMICRO_BANKS_GENERAL(0x10100000, 0*1024, 16*1024, 16)},
	{"M2354SJFAE", 0xA1735410, NUMICRO_BANKS_GENERAL(0x10100000, 0*1024, 16*1024, 16)},
	{"M2354LJFAE", 0xA1735400, NUMICRO_BANKS_GENERAL(0x10100000, 0*1024, 16*1024, 16)},

	/* M251 */
	{"M252FC2AE", 0x00F252B0, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 12)},
	{"M252EC2AE", 0x00F252A1, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 12)},
	{"M252ZC2AE", 0x00F252E2, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 12)},
	{"M251FC2AE", 0x00F251B0, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 12)},
	{"M251EC2AE", 0x00F251A1, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 12)},
	{"M251ZC2AE", 0x00F251E2, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 12)},
	{"M251FB2AE", 0x00F251B3, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 4*1024, 12)},
	{"M251EB2AE", 0x00F251A4, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 4*1024, 12)},
	{"M251ZB2AE", 0x00F251E5, NUMICRO_BANKS_GENERAL(16*1024, 0*1024, 4*1024, 12)},
	{"M251SD2AE", 0x00F25110, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"M251LD2AE", 0x00F25101, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"M251ZD2AE", 0x00F251C2, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"M251SC2AE", 0x00F25113, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 12)},
	{"M251LC2AE", 0x00F25104, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 12)},
	{"M252SD2AE", 0x00F25210, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"M252LD2AE", 0x00F25201, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"M252ZD2AE", 0x00F252C2, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"M252SC2AE", 0x00F25213, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 12)},
	{"M252LC2AE", 0x00F25204, NUMICRO_BANKS_GENERAL(32*1024, 0*1024, 4*1024, 12)},
	{"M252KE3AE", 0x00F25243, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"M252SE3AE", 0x00F25214, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"M252LE3AE", 0x00F25205, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"M251KE3AE", 0x00F25143, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"M251SE3AE", 0x00F25114, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"M251LE3AE", 0x00F25105, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"M252KG6AE", 0x00F25240, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M252SG6AE", 0x00F25211, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M252LG6AE", 0x00F25202, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M251KG6AE", 0x00F25140, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M251SG6AE", 0x00F25111, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M251LG6AE", 0x00F25102, NUMICRO_BANKS_GENERAL(256*1024, 0*1024, 4*1024, 12)},
	{"M254SD3AE", 0x00F25410, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"M254SE3AE", 0x00F25411, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"M254PD3AE", 0x00F25470, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"M254PE3AE", 0x00F25471, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"M254KD3AE", 0x00F25440, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"M254KE3AE", 0x00F25441, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"M256SD3AE", 0x00F25610, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"M256SE3AE", 0x00F25611, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"M256PD3AE", 0x00F25670, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"M256PE3AE", 0x00F25671, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"M256KD3AE", 0x00F25640, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"M256KE3AE", 0x00F25641, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"M258SD3AE", 0x00F25810, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"M258SE3AE", 0x00F25811, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"M258PD3AE", 0x00F25870, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"M258PE3AE", 0x00F25871, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"M258KD3AE", 0x00F25840, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},
	{"M258KE3AE", 0x00F25841, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},

	/* M253 */
	{"M253ZE3AE", 0x00F253E0, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"M253LE3AE", 0x00F25301, NUMICRO_BANKS_GENERAL(128*1024, 0*1024, 4*1024, 12)},
	{"M253LD3AE", 0x00F25300, NUMICRO_BANKS_GENERAL(64*1024, 0*1024, 4*1024, 12)},

	/* M261 */
	{"M261ZIAAE", 0x00261000, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M261SIAAE", 0x00261001, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M261KIAAE", 0x00261002, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M262ZIAAE", 0x00262000, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M262SIAAE", 0x00262001, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M262KIAAE", 0x00262002, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M263ZIAAE", 0x00263000, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M263SIAAE", 0x00263001, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},
	{"M263KIAAE", 0x00263002, NUMICRO_BANKS_GENERAL(512*1024, 0*1024, 4*1024, 16)},

	{"UNKNOWN", 0x00000000, NUMICRO_BANKS_GENERAL(0x10080000, 0*1024, 4*1024, 16)},
};

/* Private bank information for NuMicro. */
struct  numicro_flash_bank {
	struct working_area *write_algorithm;
	int probed;
	const struct numicro_cpu_type *cpu;
};

enum numicro_m23_secure_debug_state {
	NUMICRO_M23_SECURE_DEBUG_NORMAL = 0, /* M23 Normal Debug */
	NUMICRO_M23_SECURE_DEBUG_S,  /* M23 Secure Debug Enabled */
	NUMICRO_M23_SECURE_DEBUG_NS, /* M23 Secure Debug Disabled */
};

/* Private variables */
uint32_t m_pageSize = NUMICRO_PAGESIZE;
uint32_t m_addressMinusOffset = 0;
uint32_t m_M23SecureDebugState = NUMICRO_M23_SECURE_DEBUG_NORMAL;
uint32_t m_flashInfo = 0; /* bit 0:SPROM exists; */
char *m_target_name = "";
bool m_bSPIMFlashSectorErased = 0;

/* Private methods */
static int numicro_get_arm_arch(struct target *target)
{
	struct armv7m_common *armv7m = target_to_armv7m(target);

	if (armv7m->arm.is_armv6m) {
		LOG_DEBUG("NuMicro arm architecture: armv6m");

		if (armv7m->arm.is_NUC_M0_FMC_MSB4) {
			m_addressMinusOffset = 0x10000000;
		}
		else {
			m_addressMinusOffset = 0;
		}

		m_M23SecureDebugState = NUMICRO_M23_SECURE_DEBUG_NORMAL;
	}
	else if (armv7m->arm.is_armv8m) {
		LOG_DEBUG("NuMicro arm architecture: armv8m");

		if (armv7m->arm.is_NUC_M23_FMC_MSB5) {
			m_addressMinusOffset = 0;
		}
		else {
		m_addressMinusOffset = 0x10000000;
		}

		if (armv7m->arm.is_armv8mSecureExtend) {
			// M2351/M2354
			if (armv7m->arm.is_armv8mSecureInvasiveDebugAllowed) {
				m_M23SecureDebugState = NUMICRO_M23_SECURE_DEBUG_S;
			}
			else {
				m_M23SecureDebugState = NUMICRO_M23_SECURE_DEBUG_NS;
			}
		}
		else {
			// M251 and NUC1262
			m_M23SecureDebugState = NUMICRO_M23_SECURE_DEBUG_NORMAL;
		}

	}
	else {
		LOG_DEBUG("NuMicro arm architecture: armv7m");
		m_addressMinusOffset = 0x10000000;
		m_M23SecureDebugState = NUMICRO_M23_SECURE_DEBUG_NORMAL;
	}

	return ERROR_OK;
}

static int numicro_reg_unlock(struct target *target)
{
	uint32_t is_protected;
	int retval = ERROR_OK;

	/* Check to see if NUC is register unlocked or not */
	retval = target_read_u32(target, NUMICRO_SYS_WRPROT - m_addressMinusOffset, &is_protected);
	if (retval != ERROR_OK)
		return retval;

	LOG_DEBUG("protected = 0x%08" PRIx32 "", is_protected);
	if (is_protected == 0) {	/* means protected - so unlock it */
		/* unlock flash registers */
		retval = target_write_u32(target, NUMICRO_SYS_WRPROT - m_addressMinusOffset, REG_KEY1);
		if (retval != ERROR_OK)
			return retval;
		retval = target_write_u32(target, NUMICRO_SYS_WRPROT - m_addressMinusOffset, REG_KEY2);
		if (retval != ERROR_OK)
			return retval;
		retval = target_write_u32(target, NUMICRO_SYS_WRPROT - m_addressMinusOffset, REG_KEY3);
		if (retval != ERROR_OK)
			return retval;
	}
	/* Check that unlock worked */
	retval = target_read_u32(target, NUMICRO_SYS_WRPROT - m_addressMinusOffset, &is_protected);
	if (retval != ERROR_OK)
		return retval;

	if (is_protected == 1) {	/* means unprotected */
		LOG_DEBUG("protection removed");
	}
	else {
		LOG_DEBUG("still protected!!");
	}

	return ERROR_OK;
}

static uint32_t numicro_fmc_cmd(struct target *target, uint32_t cmd, uint32_t addr, uint32_t wdata, uint32_t* rdata)
{
	uint32_t timeout, status;
	int retval = ERROR_OK;

	retval = target_write_u32(target, NUMICRO_FLASH_ISPCMD - m_addressMinusOffset, cmd);
	if (retval != ERROR_OK)
		return retval;

	retval = target_write_u32(target, NUMICRO_FLASH_ISPDAT - m_addressMinusOffset, wdata);
	if (retval != ERROR_OK)
		return retval;

	retval = target_write_u32(target, NUMICRO_FLASH_ISPADR - m_addressMinusOffset, addr);
	if (retval != ERROR_OK)
		return retval;

	retval = target_write_u32(target, NUMICRO_FLASH_ISPTRG - m_addressMinusOffset, ISPTRG_ISPGO);
	if (retval != ERROR_OK)
		return retval;

	/* Wait for busy to clear - check the GO flag */
	timeout = 100;
	for (;;) {
		retval = target_read_u32(target, NUMICRO_FLASH_ISPTRG - m_addressMinusOffset, &status);
		if (retval != ERROR_OK)
			return retval;
			LOG_DEBUG("status: 0x%" PRIx32 "", status);
		if ((status & (ISPTRG_ISPGO)) == 0)
			break;
		if (timeout-- <= 0) {
			LOG_DEBUG("timed out waiting for flash");
			return ERROR_FAIL;
		}
		busy_sleep(1);	/* can use busy sleep for short times. */
	}

	retval = target_read_u32(target, NUMICRO_FLASH_ISPDAT - m_addressMinusOffset, rdata);
	if (retval != ERROR_OK)
		return retval;

	return ERROR_OK;
}

/* NuMicro Program-LongWord Microcodes */
static const uint8_t numicro_M0_flash_write_code[] = {
	/* Params:
	 * r0 - workarea buffer / result
	 * r1 - target address
	 * r2 - wordcount
	 * Clobbered:
	 * r4 - tmp
	 * r5 - tmp
	 * r6 - tmp
	 * r7 - tmp
	 */

	/* .L1: */
	/* for(register uint32_t i=0;i<wcount;i++){ */
	0x04, 0x1C,				/* mov    r4, r0          */
	0x00, 0x23,				/* mov    r3, #0          */
	/* .L2: */
	0x0D, 0x1A,				/* sub    r5, r1, r0      */
	0x67, 0x19,				/* add    r7, r4, r7      */
	0x93, 0x42,				/* cmp	  r3, r2		  */
	0x0C, 0xD0,				/* beq    .L7             */
	/* .L4: */
	/* NUMICRO_FLASH_ISPADR = faddr; */
	0x08, 0x4E,				/* ldr	r6, .L8           */
	0x37, 0x60,				/* str	r7, [r6]          */
	/* NUMICRO_FLASH_ISPDAT = *pLW; */
	0x80, 0xCC,				/* ldmia	r4!, {r7}     */
	0x08, 0x4D,				/* ldr	r5, .L8+4         */
	0x2F, 0x60,				/* str	r7, [r5]		  */
	/* faddr += 4; */
	/* pLW++; */
	/*  Trigger write action  */
	/* NUMICRO_FLASH_ISPTRG = ISPTRG_ISPGO; */
	0x08, 0x4D,				/* ldr	r5, .L8+8         */
	0x01, 0x26,				/* mov	r6, #1            */
	0x2E, 0x60,				/* str	r6, [r5]          */
	/* .L3: */
	/* while((NUMICRO_FLASH_ISPTRG & ISPTRG_ISPGO) == ISPTRG_ISPGO){}; */
	0x2F, 0x68,				/* ldr	r7, [r5]          */
	0xFF, 0x07,				/* lsl	r7, r7, #31       */
	0xFC, 0xD4,				/* bmi	.L3               */

	0x01, 0x33,				/* add	r3, r3, #1        */
	0xEE, 0xE7,				/* b	.L2               */
	/* .L7: */
	/* return (NUMICRO_FLASH_ISPCON & ISPCON_ISPFF); */
	0x05, 0x4B,				/* ldr	r3, .L8+12        */
	0x18, 0x68,				/* ldr	r0, [r3]          */
	0x40, 0x21,				/* mov	r1, #64           */
	0x08, 0x40,				/* and	r0, r1            */
	/* .L9: */
	0x00, 0xBE,				/* bkpt    #0             */
	/* .L8: */
	0x04, 0xC0, 0x00, 0x50,/* .word	1342226436    */
	0x08, 0xC0, 0x00, 0x50,/* .word	1342226440    */
	0x10, 0xC0, 0x00, 0x50,/* .word	1342226448    */
	0x00, 0xC0, 0x00, 0x50 /* .word	1342226432    */
};

static const uint8_t numicro_M4_M23_flash_write_code[] = {
	/* Params:
	* r0 - workarea buffer / result
	* r1 - target address
	* r2 - wordcount
	* Clobbered:
	* r4 - tmp
	* r5 - tmp
	* r6 - tmp
	* r7 - tmp
	*/

	/* .L1: */
	/* for(register uint32_t i=0;i<wcount;i++){ */
	0x04, 0x1C,				/* mov    r4, r0          */
	0x00, 0x23,				/* mov    r3, #0          */
	/* .L2: */
	0x0D, 0x1A,				/* sub    r5, r1, r0      */
	0x67, 0x19,				/* add    r7, r4, r7      */
	0x93, 0x42,				/* cmp	  r3, r2		  */
	0x0C, 0xD0,				/* beq    .L7             */
	/* .L4: */
	/* NUMICRO_FLASH_ISPADR = faddr; */
	0x08, 0x4E,				/* ldr	r6, .L8           */
	0x37, 0x60,				/* str	r7, [r6]          */
	/* NUMICRO_FLASH_ISPDAT = *pLW; */
	0x80, 0xCC,				/* ldmia	r4!, {r7}     */
	0x08, 0x4D,				/* ldr	r5, .L8+4         */
	0x2F, 0x60,				/* str	r7, [r5]		  */
	/* faddr += 4; */
	/* pLW++; */
	/*  Trigger write action  */
	/* NUMICRO_FLASH_ISPTRG = ISPTRG_ISPGO; */
	0x08, 0x4D,				/* ldr	r5, .L8+8         */
	0x01, 0x26,				/* mov	r6, #1            */
	0x2E, 0x60,				/* str	r6, [r5]          */
	/* .L3: */
	/* while((NUMICRO_FLASH_ISPTRG & ISPTRG_ISPGO) == ISPTRG_ISPGO){}; */
	0x2F, 0x68,				/* ldr	r7, [r5]          */
	0xFF, 0x07,				/* lsl	r7, r7, #31       */
	0xFC, 0xD4,				/* bmi	.L3               */

	0x01, 0x33,				/* add	r3, r3, #1        */
	0xEE, 0xE7,				/* b	.L2               */
	/* .L7: */
	/* return (NUMICRO_FLASH_ISPCON & ISPCON_ISPFF); */
	0x05, 0x4B,				/* ldr	r3, .L8+12        */
	0x18, 0x68,				/* ldr	r0, [r3]          */
	0x40, 0x21,				/* mov	r1, #64           */
	0x08, 0x40,				/* and	r0, r1            */
	/* .L9: */
	0x00, 0xBE,				/* bkpt    #0             */
	/* .L8: */
	0x04, 0xC0, 0x00, 0x40,/* .word	0x4000C004    */
	0x08, 0xC0, 0x00, 0x40,/* .word	0x4000C008    */
	0x10, 0xC0, 0x00, 0x40,/* .word	0x4000C010    */
	0x00, 0xC0, 0x00, 0x40 /* .word	0x4000C000    */
};

static const uint8_t numicro_M2351_NS_flash_write_code[] = {
	/* Params:
	* r0 - workarea buffer / result
	* r1 - target address
	* r2 - wordcount
	* Clobbered:
	* r4 - tmp
	* r5 - tmp
	* r6 - tmp
	* r7 - tmp
	*/
	0xb0, 0xb5, 0x92, 0xb0, 0x13, 0x46, 0x0c, 0x46, 0x05, 0x46, 0x10, 0x90, 0x0f,
	0x91, 0x0e, 0x92, 0x00, 0x20, 0x0d, 0x90, 0x06, 0x93, 0x05, 0x94, 0x04, 0x95,
	0x00, 0xf0, 0xb3, 0xf8, 0x0f, 0x99, 0x01, 0x22, 0x12, 0x07, 0x11, 0x43, 0x0f,
	0x91, 0x0e, 0x99, 0x89, 0x00, 0x0d, 0x91, 0x0f, 0x99, 0x09, 0x0f, 0x01, 0x29,
	0x03, 0x90, 0x3b, 0xd1, 0xff, 0xe7, 0xff, 0xe7, 0x0d, 0x98, 0x00, 0x28, 0x35,
	0xdb, 0xff, 0xe7, 0x0d, 0x98, 0x40, 0xf6, 0x00, 0x01, 0x88, 0x42, 0x15, 0xdb,
	0xff, 0xe7, 0x0f, 0x98, 0x10, 0x99, 0x40, 0xf6, 0x00, 0x02, 0x00, 0xf0, 0x9a,
	0xf8, 0x00, 0x28, 0x03, 0xd0, 0xff, 0xe7, 0x01, 0x20, 0x11, 0x90, 0x8a, 0xe0,
	0x0f, 0x98, 0x40, 0xf6, 0x00, 0x01, 0x40, 0x18, 0x0f, 0x90, 0x10, 0x98, 0x40,
	0x18, 0x10, 0x90, 0x10, 0xe0, 0x0d, 0x98, 0x00, 0x28, 0x0c, 0xd0, 0xff, 0xe7,
	0x0f, 0x98, 0x10, 0x99, 0x0d, 0x9a, 0x00, 0xf0, 0x82, 0xf8, 0x00, 0x28, 0x03,
	0xd0, 0xff, 0xe7, 0x01, 0x20, 0x11, 0x90, 0x72, 0xe0, 0xff, 0xe7, 0xff, 0xe7,
	0xff, 0xe7, 0x0d, 0x98, 0x4f, 0xf6, 0x00, 0x01, 0xcf, 0xf6, 0xff, 0x71, 0x40,
	0x18, 0x0d, 0x90, 0xc6, 0xe7, 0x63, 0xe0, 0x0f, 0x98, 0x01, 0x21, 0x49, 0x05,
	0x88, 0x42, 0x24, 0xd1, 0xff, 0xe7, 0x10, 0x98, 0x0a, 0x90, 0x00, 0x20, 0x0c,
	0x90, 0xff, 0xe7, 0x0c, 0x98, 0x0e, 0x99, 0x89, 0x08, 0x88, 0x42, 0x18, 0xd2,
	0xff, 0xe7, 0x0a, 0x98, 0x0c, 0x99, 0x89, 0x00, 0x42, 0x18, 0x40, 0x58, 0x51,
	0x68, 0x93, 0x68, 0xd2, 0x68, 0x02, 0x92, 0x1a, 0x46, 0x02, 0x9b, 0x00, 0xf0,
	0x58, 0xf8, 0x00, 0x28, 0x03, 0xd0, 0xff, 0xe7, 0x01, 0x20, 0x11, 0x90, 0x42,
	0xe0, 0xff, 0xe7, 0x0c, 0x98, 0x00, 0x1d, 0x0c, 0x90, 0xe1, 0xe7, 0x38, 0xe0,
	0x0f, 0x98, 0x41, 0xf2, 0x00, 0x01, 0xc0, 0xf2, 0x31, 0x01, 0x88, 0x42, 0x23,
	0xd1, 0xff, 0xe7, 0x10, 0x98, 0x08, 0x90, 0x08, 0x98, 0x01, 0x68, 0x42, 0x68,
	0x80, 0x68, 0x01, 0x90, 0x08, 0x46, 0x11, 0x46, 0x01, 0x9a, 0x00, 0xf0, 0x3e,
	0xf8, 0x09, 0x90, 0x09, 0x98, 0x00, 0x28, 0x11, 0xd0, 0xff, 0xe7, 0x08, 0x98,
	0xc0, 0x68, 0x07, 0x90, 0x09, 0x98, 0x07, 0x99, 0x08, 0x60, 0x00, 0xf0, 0x37,
	0xf8, 0x07, 0x99, 0x48, 0x60, 0x00, 0xf0, 0x39, 0xf8, 0x07, 0x99, 0x88, 0x60,
	0x01, 0x20, 0x11, 0x90, 0x12, 0xe0, 0x0c, 0xe0, 0x0f, 0x98, 0x40, 0xf6, 0x00,
	0x01, 0xc0, 0xf2, 0x21, 0x01, 0x88, 0x42, 0x04, 0xd1, 0xff, 0xe7, 0x00, 0xf0,
	0x2f, 0xf8, 0x00, 0x90, 0xff, 0xe7, 0xff, 0xe7, 0xff, 0xe7, 0xff, 0xe7, 0x00,
	0x20, 0x11, 0x90, 0xff, 0xe7, 0x11, 0x98, 0x12, 0xb0, 0x00, 0xbe, 0x03, 0xb4,
	0x01, 0x48, 0x01, 0x90, 0x01, 0xbd, 0x19, 0x7e, 0x80, 0x00, 0x03, 0xb4, 0x01,
	0x48, 0x01, 0x90, 0x01, 0xbd, 0x39, 0x7e, 0x80, 0x00, 0x03, 0xb4, 0x01, 0x48,
	0x01, 0x90, 0x01, 0xbd, 0x29, 0x7f, 0x80, 0x00, 0x03, 0xb4, 0x01, 0x48, 0x01,
	0x90, 0x01, 0xbd, 0x31, 0x7f, 0x80, 0x00, 0x03, 0xb4, 0x01, 0x48, 0x01, 0x90,
	0x01, 0xbd, 0x79, 0x7e, 0x80, 0x00, 0x03, 0xb4, 0x01, 0x48, 0x01, 0x90, 0x01,
	0xbd, 0x69, 0x7e, 0x80, 0x00, 0x03, 0xb4, 0x01, 0x48, 0x01, 0x90, 0x01, 0xbd,
	0x19, 0x7f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static const uint8_t numicro_M2351_NS_flash_erase_code[] = {
	/* Params:
	* r0 - target address
	*/

	0x80, 0xb5, 0x84, 0xb0, 0x01, 0x46, 0x03, 0x90, 0x01, 0x91, 0x00, 0xf0, 0x27,
	0xf8, 0x03, 0x99, 0x01, 0x22, 0x13, 0x07, 0x19, 0x43, 0x03, 0x91, 0x03, 0x99,
	0x4f, 0xf6, 0x00, 0x03, 0xcf, 0xf6, 0xff, 0x73, 0x19, 0x40, 0x03, 0x91, 0x03,
	0x99, 0x0f, 0x23, 0x1b, 0x05, 0x19, 0x40, 0x52, 0x05, 0x91, 0x42, 0x00, 0x90,
	0x0a, 0xd1, 0xff, 0xe7, 0x03, 0x98, 0x40, 0xf2, 0x00, 0x01, 0xcf, 0xf6, 0xe0,
	0x71, 0x40, 0x18, 0x00, 0xf0, 0x10, 0xf8, 0x02, 0x90, 0x04, 0xe0, 0x03, 0x98,
	0x00, 0xf0, 0x11, 0xf8, 0x02, 0x90, 0xff, 0xe7, 0x02, 0x98, 0x04, 0xb0, 0x00,
	0xbe, 0x03, 0xb4, 0x01, 0x48, 0x01, 0x90, 0x01, 0xbd, 0x19, 0x7e, 0x80, 0x00,
	0x03, 0xb4, 0x01, 0x48, 0x01, 0x90, 0x01, 0xbd, 0x21, 0x7e, 0x80, 0x00, 0x03,
	0xb4, 0x01, 0x48, 0x01, 0x90, 0x01, 0xbd, 0x41, 0x7e, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x00,
};

static const uint8_t numicro_M2351_NS_init_info_code[] = {
	/* Params:
	* r0 - address to place info (In fact, the actual location will be the address plus one word)
	*/
	0xb0, 0xb5, 0x8e, 0xb0, 0x13, 0x46, 0x0c, 0x46, 0x05, 0x46, 0x0d, 0x90, 0x0c,
	0x91, 0x0b, 0x92, 0x06, 0x93, 0x05, 0x94, 0x04, 0x95, 0x00, 0xf0, 0xa5, 0xf8,
	0x03, 0x90, 0x00, 0xf0, 0xa8, 0xf8, 0x09, 0x90, 0x09, 0x98, 0x0d, 0x99, 0x08,
	0x60, 0x0d, 0x98, 0x00, 0x1d, 0x0d, 0x90, 0x0d, 0x98, 0x00, 0x28, 0x00, 0xd1,
	0x82, 0xe0, 0x00, 0xf0, 0xa1, 0xf8, 0x09, 0x90, 0x09, 0x98, 0x0d, 0x99, 0x08,
	0x60, 0x0d, 0x98, 0x00, 0x1d, 0x0d, 0x90, 0x00, 0xf0, 0x9e, 0xf8, 0x09, 0x90,
	0x09, 0x98, 0x0d, 0x99, 0x08, 0x60, 0x0d, 0x98, 0x00, 0x1d, 0x0d, 0x90, 0x00,
	0x20, 0x02, 0x90, 0x00, 0xf0, 0x99, 0xf8, 0x09, 0x90, 0x09, 0x98, 0x0d, 0x99,
	0x08, 0x60, 0x0d, 0x98, 0x00, 0x1d, 0x0d, 0x90, 0x01, 0x20, 0x00, 0xf0, 0x8f,
	0xf8, 0x09, 0x90, 0x09, 0x98, 0x0d, 0x99, 0x08, 0x60, 0x0d, 0x98, 0x00, 0x1d,
	0x0d, 0x90, 0x02, 0x20, 0x00, 0xf0, 0x85, 0xf8, 0x09, 0x90, 0x09, 0x98, 0x0d,
	0x99, 0x08, 0x60, 0x0d, 0x98, 0x00, 0x1d, 0x0d, 0x90, 0x00, 0xf0, 0x82, 0xf8,
	0x09, 0x90, 0x09, 0x98, 0x0d, 0x99, 0x08, 0x60, 0x0d, 0x98, 0x00, 0x1d, 0x0d,
	0x90, 0x00, 0xf0, 0x7f, 0xf8, 0x09, 0x90, 0x09, 0x98, 0x0d, 0x99, 0x08, 0x60,
	0x0d, 0x98, 0x00, 0x1d, 0x0d, 0x90, 0x00, 0xf0, 0x7c, 0xf8, 0x80, 0xb2, 0x09,
	0x90, 0x09, 0x98, 0x00, 0x04, 0x01, 0x90, 0x00, 0xf0, 0x7b, 0xf8, 0x80, 0xb2,
	0x01, 0x99, 0x01, 0x43, 0x09, 0x91, 0x09, 0x98, 0x0d, 0x99, 0x08, 0x60, 0x0d,
	0x98, 0x00, 0x1d, 0x0d, 0x90, 0x02, 0x98, 0x0a, 0x90, 0xff, 0xe7, 0x0a, 0x98,
	0x03, 0x28, 0x25, 0xd8, 0xff, 0xe7, 0x00, 0x20, 0x09, 0x90, 0x0a, 0x98, 0x00,
	0xf0, 0x6b, 0xf8, 0x00, 0x28, 0x12, 0xd0, 0xff, 0xe7, 0x0a, 0x98, 0x08, 0xa9,
	0x07, 0xaa, 0x00, 0xf0, 0x69, 0xf8, 0x09, 0x90, 0x09, 0x98, 0x00, 0x28, 0x07,
	0xd1, 0xff, 0xe7, 0x08, 0x98, 0x00, 0x02, 0x07, 0xa9, 0x09, 0x78, 0x08, 0x43,
	0x09, 0x90, 0xff, 0xe7, 0xff, 0xe7, 0x09, 0x98, 0x0d, 0x99, 0x08, 0x60, 0x0d,
	0x98, 0x00, 0x1d, 0x0d, 0x90, 0xff, 0xe7, 0x0a, 0x98, 0x40, 0x1c, 0x0a, 0x90,
	0xd6, 0xe7, 0xff, 0xe7, 0x00, 0x20, 0x0e, 0xb0, 0x00, 0xbe, 0xc0, 0x46, 0xc0,
	0x46, 0xc0, 0x46, 0xc0, 0x46, 0xc0, 0x46, 0xc0, 0x46, 0xc0, 0x46, 0x80, 0xb5,
	0x82, 0xb0, 0x01, 0x46, 0x01, 0x90, 0x00, 0x91, 0x00, 0xf0, 0x45, 0xf8, 0x00,
	0x20, 0x02, 0xb0, 0x00, 0xbe, 0x03, 0xb4, 0x01, 0x48, 0x01, 0x90, 0x01, 0xbd,
	0x19, 0x7e, 0x80, 0x00, 0x03, 0xb4, 0x01, 0x48, 0x01, 0x90, 0x01, 0xbd, 0x89,
	0x7e, 0x80, 0x00, 0x03, 0xb4, 0x01, 0x48, 0x01, 0x90, 0x01, 0xbd, 0xf1, 0x7e,
	0x80, 0x00, 0x03, 0xb4, 0x01, 0x48, 0x01, 0x90, 0x01, 0xbd, 0xe1, 0x7e, 0x80,
	0x00, 0x03, 0xb4, 0x01, 0x48, 0x01, 0x90, 0x01, 0xbd, 0x01, 0x7f, 0x80, 0x00,
	0x03, 0xb4, 0x01, 0x48, 0x01, 0x90, 0x01, 0xbd, 0x81, 0x7e, 0x80, 0x00, 0x03,
	0xb4, 0x01, 0x48, 0x01, 0x90, 0x01, 0xbd, 0x79, 0x7e, 0x80, 0x00, 0x03, 0xb4,
	0x01, 0x48, 0x01, 0x90, 0x01, 0xbd, 0x71, 0x7e, 0x80, 0x00, 0x03, 0xb4, 0x01,
	0x48, 0x01, 0x90, 0x01, 0xbd, 0x69, 0x7e, 0x80, 0x00, 0x03, 0xb4, 0x01, 0x48,
	0x01, 0x90, 0x01, 0xbd, 0x91, 0x7e, 0x80, 0x00, 0x03, 0xb4, 0x01, 0x48, 0x01,
	0x90, 0x01, 0xbd, 0x09, 0x7f, 0x80, 0x00, 0x03, 0xb4, 0x01, 0x48, 0x01, 0x90,
	0x01, 0xbd, 0x11, 0x7f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static const uint32_t numicro_M2354_NS_flash_algorithm_code[] = {
	0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
	0x9002b084, 0x92009101, 0x4820e7ff, 0x07c06800, 0xd0012800, 0xe7f8e7ff, 0x6801481d, 0x43112240,
	0x98026001, 0x6008491b, 0x491b9801, 0x98006008, 0xd1052800, 0x2000e7ff, 0x491843c0, 0xe0036008,
	0x49174816, 0xe7ff6001, 0x21014816, 0xf3bf6001, 0xe7ff8f6f, 0x6800480d, 0x280007c0, 0xe7ffd001,
	0x480be7f8, 0x06406800, 0xd5082800, 0x4808e7ff, 0x22406801, 0x60014311, 0x90032001, 0x2000e002,
	0xe7ff9003, 0xb0049803, 0x46c04770, 0x5000c040, 0x5000c000, 0x5000c00c, 0x5000c004, 0x5000c008,
	0x0055aa03, 0x5000c010, 0x9002b084, 0x92009101, 0x07002005, 0x28006800, 0xe7ffd103, 0x90032001,
	0x480fe01b, 0x60012159, 0x60012116, 0x60012188, 0x07c06800, 0xd1032800, 0x2001e7ff, 0xe00c9003,
	0x21494808, 0x68006001, 0xd1032800, 0x2001e7ff, 0xe0029003, 0x90032000, 0x9803e7ff, 0x4770b004,
	0x50000100, 0x5000c000, 0x9000b081, 0x4806e7ff, 0x07c06800, 0xd0012800, 0xe7f8e7ff, 0x21004803,
	0x46086001, 0x4770b001, 0x5000c040, 0x5000c000, 0xb082b580, 0x98019001, 0x070a2101, 0x90014390,
	0x4a0e9801, 0x90014010, 0x220f9801, 0x40100512, 0x42880549, 0xe7ffd107, 0x49099801, 0x90011840,
	0x90002001, 0x2000e002, 0xe7ff9000, 0x9a009901, 0xf7ff2022, 0xb002ff45, 0x46c0bd80, 0xfffff800,
	0xffe00000, 0xb084b580, 0x91019002, 0x90002000, 0x9800e7ff, 0x42889901, 0xe7ffd20f, 0x99009802,
	0x92001c4a, 0x58400089, 0xffc2f7ff, 0xd0032800, 0x2001e7ff, 0xe0039003, 0x2000e7eb, 0xe7ff9003,
	0xb0049803, 0x46c0bd80, 0x9002b084, 0x92009101, 0x1cc09801, 0x43882103, 0x98029001, 0x07092101,
	0x90024388, 0x4823e7ff, 0x07c06800, 0xd0012800, 0xe7f8e7ff, 0x68014820, 0x43112240, 0x481f6001,
	0x60012121, 0x9801e7ff, 0xd02c2800, 0x9802e7ff, 0x6008491b, 0x68009800, 0x6008491a, 0x2101481a,
	0xf3bf6001, 0xe7ff8f6f, 0x68004812, 0x280007c0, 0xe7ffd001, 0x4810e7f8, 0x06406800, 0xd5082800,
	0x480de7ff, 0x22406801, 0x60014311, 0x90032001, 0x9802e00c, 0x90021d00, 0x1d009800, 0x98019000,
	0x90011f00, 0x2000e7cf, 0xe7ff9003, 0xb0049803, 0x46c04770, 0x5000c040, 0x5000c000, 0x5000c00c,
	0x5000c004, 0x5000c008, 0x5000c010, 0x9003b084, 0x92019102, 0x1cc09802, 0x43882103, 0x98039002,
	0x07092101, 0x90004008, 0x43889803, 0xe7ff9003, 0x68004823, 0x280007c0, 0xe7ffd001, 0x4821e7f8,
	0x22406801, 0x60014311, 0x2100481f, 0xe7ff6001, 0x28009802, 0xe7ffd02e, 0x491c9803, 0x481c6008,
	0x60012101, 0x8f6ff3bf, 0x4815e7ff, 0x07c06800, 0xd0012800, 0xe7f8e7ff, 0x68004812, 0x28000640,
	0xe7ffd506, 0x6801480f, 0x43112240, 0xe0116001, 0x68004810, 0x68099901, 0xd0014288, 0xe009e7ff,
	0x1d009803, 0x98019003, 0x90011d00, 0x1f009802, 0xe7cd9002, 0x99009803, 0xb0044308, 0x46c04770,
	0x5000c040, 0x5000c000, 0x5000c00c, 0x5000c004, 0x5000c010, 0x5000c008, 0x00000000
};

static const uint32_t numicro_M471_dataflash_flash_algorithm_code[] = {
    0xE00ABE00, 0x4603b510, 0x4c8b2059, 0x20166020, 0xf8c405a4, 0x20880100, 0x0100f8c4, 0xf8d006c0,
	0x28010100, 0x2001d001, 0x4884bd10, 0xf0006800, 0xb9780010, 0x38504881, 0xf0406800, 0xf04f0004,
	0xf8c44480, 0xbf000200, 0x6800487c, 0x0010f000, 0xd0f92800, 0x384c4879, 0xf0406800, 0xf04f0004,
	0xf8c44480, 0x48760204, 0xf0406800, 0x4c740009, 0x46206020, 0xf0006800, 0x28090009, 0x2001d001,
	0x486ee7d2, 0x68003830, 0x000ff020, 0x4480f04f, 0x0220f8c4, 0xe7c72000, 0xbf004601, 0x6c004868,
	0x0001f000, 0xd1f92800, 0x68004865, 0x0001f020, 0x60104a63, 0x47702000, 0x4861bf00, 0xf0006c00,
	0x28000001, 0x485ed1f9, 0xf0406800, 0x4a5c0040, 0xf44f6010, 0x60500080, 0x60d02026, 0x61102001,
	0x4857bf00, 0xf0006c00, 0x28000001, 0x4854d1f9, 0xf0016801, 0xb1180040, 0x60014851, 0x47702001,
	0xe7fc2000, 0xbf004602, 0x6c00484d, 0x0001f000, 0xd1f92800, 0x6800484a, 0x0040f040, 0x60184b48,
	0x60424618, 0x60d82022, 0x61182001, 0x4844bf00, 0xf0006c00, 0x28000001, 0x4841d1f9, 0xf0016801,
	0xb1180040, 0x6001483e, 0x47702001, 0xe7fc2000, 0x4603b530, 0x0003f003, 0x2001b108, 0x1cc8bd30,
	0x0103f020, 0x4836bf00, 0xf0006c00, 0x28000001, 0x4833d1f9, 0xf0406800, 0x4d310040, 0x20216028,
	0xe01960e8, 0x6043482e, 0x68104d2d, 0x200160a8, 0xbf006128, 0x6c00482a, 0x0001f000, 0xd1f92800,
	0x68044827, 0x0040f004, 0x4825b118, 0x20016004, 0x1d1be7d4, 0x1f091d12, 0xd1e32900, 0xe7cd2000,
	0x4603b530, 0x0003f003, 0x2001b108, 0x1cc8bd30, 0x0103f020, 0x481abf00, 0xf0006c00, 0x28000001,
	0x4817d1f9, 0xf0406800, 0x4d150040, 0x20006028, 0xe01c60e8, 0x60434812, 0x4d112001, 0xbf006128,
	0x6c00480f, 0x0001f000, 0xd1f92800, 0x6804480c, 0x0040f004, 0x480ab110, 0xe00a6004, 0x68804808,
	0x42a86815, 0xe004d000, 0x1d121d1b, 0x29001f09, 0xbf00d1e0, 0xe7c94618, 0x40000100, 0x40000250,
	0x4000f000, 0x00000000
};

static const uint32_t numicro_M480_flash_algorithm_code[] = {
	0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
	0x4603b530, 0x2164460c, 0x4dfe2059, 0xf04f6028, 0xf04f0016, 0xf8c54580, 0xf04f0100, 0xf8c50088,
	0xf04f0100, 0xf8d04080, 0xf0100100, 0xd1010f01, 0xbd302001, 0x680048f4, 0x0004f040, 0x4580f04f,
	0x0200f8c5, 0xf8d04628, 0xf0400204, 0xf8c50004, 0xbf000204, 0xf1a10008, 0xd1fb0101, 0x680048eb,
	0x0021f040, 0x60284de9, 0x69c04628, 0x0001f040, 0x462861e8, 0xf0106800, 0xd1010f01, 0xe7d82001,
	0x680048e2, 0x0040f040, 0x60284de0, 0xe7d02000, 0xbf004601, 0x690048dd, 0x0f01f010, 0x48dbd1fa,
	0xf0206800, 0x4ad90021, 0x46106010, 0xf02069c0, 0x61d00001, 0x47702000, 0xbf004601, 0x690048d3,
	0x0f01f010, 0x48d1d1fa, 0xf0406800, 0x4acf0040, 0x20226010, 0xf02160d0, 0x60500003, 0x1f00f5b1,
	0x48cbd101, 0x20016090, 0x61104ac8, 0x8f60f3bf, 0x48c6bf00, 0xf0106900, 0xd1fa0f01, 0x680048c3,
	0x0f40f010, 0x48c1d007, 0xf0406800, 0x4abf0040, 0x20016010, 0x20004770, 0x4601e7fc, 0x48bbbf00,
	0xf0106900, 0xd1fa0f01, 0x680048b8, 0x0040f040, 0x60104ab6, 0x60d02025, 0x60414610, 0x1f00f5b1,
	0x48b3d101, 0x20016090, 0x61104ab0, 0x8f60f3bf, 0x48aebf00, 0xf0106900, 0xd1fa0f01, 0x680048ab,
	0x0f40f010, 0x48a9d007, 0xf0406800, 0x4aa70040, 0x20016010, 0x20004770, 0xb570e7fc, 0x460d4604,
	0xe01a2300, 0x0023f854, 0x0c800480, 0x1ae8d10c, 0xd3092804, 0x0023f854, 0xffbff7ff, 0xd0010006,
	0xbd704630, 0xe0081d1b, 0x0023f854, 0xff84f7ff, 0xd0010006, 0xe7f44630, 0x42ab1c5b, 0x2000d3e2,
	0xb570e7ef, 0x460b4604, 0x22004615, 0xf1034629, 0xf020000f, 0xbf00030f, 0x6900488c, 0x0f01f010,
	0x488ad1fa, 0xf0406800, 0x4e880040, 0xf0246030, 0x6070000f, 0x60f02027, 0x1c524610, 0x0020f851,
	0x60304e84, 0xf1024610, 0xf8510201, 0x4e7f0020, 0x0084f8c6, 0xf1024610, 0xf8510201, 0x4e7e0020,
	0x46106030, 0x0201f102, 0x0020f851, 0x0604f106, 0xf04f6030, 0x4e750001, 0xf1a36130, 0xe0290310,
	0x4876bf00, 0xf0106800, 0xd1fa0f30, 0x1c524610, 0x0020f851, 0x60304e6f, 0xf1024610, 0xf8510201,
	0x4e6a0020, 0x0084f8c6, 0x486cbf00, 0xf0106800, 0xd1fa0fc0, 0x1c524610, 0x0020f851, 0x60304e66,
	0xf1024610, 0xf8510201, 0x4e600020, 0x008cf8c6, 0x0310f1a3, 0xd1d32b00, 0x485cbf00, 0xf0106900,
	0xd1fa0f01, 0xbd702000, 0x4603b510, 0xf0201cc8, 0xbf000103, 0x69004855, 0x0f01f010, 0x4853d1fa,
	0xf0406800, 0x4c510040, 0x20216020, 0xe01f60e0, 0x0003f023, 0x60604c4d, 0x60a06810, 0x61202001,
	0x8f60f3bf, 0x4849bf00, 0xf0106900, 0xd1fa0f01, 0x68004846, 0x0f40f010, 0x4844d007, 0xf0406800,
	0x4c420040, 0x20016020, 0x1d1bbd10, 0x1f091d12, 0xd1dd2900, 0xe7f72000, 0x47f0e92d, 0x460c4605,
	0xf04f4616, 0x46c20800, 0x4838bf00, 0xf0106900, 0xd1fa0f01, 0x68004835, 0x0040f040, 0x60084933,
	0xf0201ce0, 0xe02f0403, 0x0dc005e8, 0xf5b4d10c, 0xd3097f00, 0x7700f44f, 0x0208eb06, 0x46284639,
	0xff2ff7ff, 0xe0164682, 0x0dc005e8, 0x2c10d10b, 0xf024d309, 0xeb06070f, 0x46390208, 0xf7ff4628,
	0x4682ff20, 0x4627e007, 0x0208eb06, 0x46284639, 0xff8af7ff, 0x443d4682, 0x1be444b8, 0x0f00f1ba,
	0x2001d002, 0x87f0e8bd, 0xd1cd2c00, 0xe7f92000, 0x1ccbb510, 0x0103f023, 0x4b14bf00, 0xf013691b,
	0xd1fa0f01, 0x681b4b11, 0x0340f043, 0x60234c0f, 0x60e32300, 0xf020e033, 0x4c0c0303, 0x23006063,
	0x230160a3, 0xf3bf6123, 0xbf008f60, 0x691b4b07, 0x0f01f013, 0x4b05d1fa, 0xf013681b, 0xd0150f40,
	0xe00d4b02, 0x40000100, 0x40000200, 0x4000c000, 0x0055aa03, 0x4000c080, 0x4000c088, 0x4000c0c0,
	0xf043681b, 0x4c1a0340, 0xbd106023, 0x689b4b18, 0x42a36814, 0xe7f8d000, 0x1d121d00, 0x29001f09,
	0xbf00d1c9, 0xb510e7f1, 0x48114603, 0xf0106e00, 0xd00c0f02, 0x6503480e, 0x65826541, 0x4c0c2001,
	0xbf0065e0, 0x6e00480a, 0x0f01f010, 0x4808d1fa, 0xf0106e00, 0xd1010f04, 0xbd102002, 0x6e004804,
	0x0f02f010, 0x2001d001, 0x2000e7f7, 0x0000e7f5, 0x4000c000, 0x00000000
};

static const uint32_t numicro_M480_spim_flash_algorithm_code[] = {
	0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
	0xf2402a03, 0xf0108030, 0xf0000c03, 0xf8118015, 0xf1bc3b01, 0x44620f02, 0xf811bf98, 0xf800cb01,
	0xbf383b01, 0x3b01f811, 0x0204f1a2, 0xf800bf98, 0xbf38cb01, 0x3b01f800, 0x0303f011, 0x8025f000,
	0xf0c03a08, 0xf8518008, 0x3a083b04, 0xcb04f851, 0x1008e8a0, 0x1d12e7f5, 0xf851bf5c, 0xf8403b04,
	0xf3af3b04, 0x07d28000, 0xf811bf24, 0xf8113b01, 0xbf48cb01, 0x2b01f811, 0xf800bf24, 0xf8003b01,
	0xbf48cb01, 0x2b01f800, 0xb5104770, 0xf0c03a20, 0xe8b1800b, 0x3a205018, 0x5018e8a0, 0x5018e8b1,
	0x5018e8a0, 0xaff5f4bf, 0x7c02ea5f, 0xe8b1bf24, 0xe8a05018, 0xbf445018, 0xc018c918, 0x4010e8bd,
	0x7c82ea5f, 0xf851bf24, 0xf8403b04, 0xbf083b04, 0x07d24770, 0xf831bf28, 0xbf483b02, 0x2b01f811,
	0xf820bf28, 0xbf483b02, 0x2b01f800, 0x46034770, 0x47702001, 0xe0002100, 0x4a031c49, 0x6812444a,
	0x428a4342, 0x4770d8f8, 0x00000008, 0x466cb53e, 0xf80420c7, 0x482a0b01, 0x69804448, 0x9002b2c0,
	0x4828bf00, 0xf0206840, 0x49260010, 0xbf006048, 0x4608bf00, 0xf4206800, 0xf4401042, 0x60084000,
	0x2101bf00, 0xf000a802, 0xbf00fe79, 0x6840481d, 0x0010f040, 0x6048491b, 0xbf00bf00, 0xfad6f000,
	0x0f01f010, 0xbf00d1fa, 0xfad0f000, 0x0002f000, 0xd1f92802, 0x4813bf00, 0xf0206840, 0x49110010,
	0xbf006048, 0x4608bf00, 0xf4206800, 0xf4401042, 0x60084000, 0x2101bf00, 0xf0004668, 0xbf00fe4f,
	0x68404808, 0x0010f040, 0x60484906, 0xbf00bf00, 0xfaacf000, 0x0f01f010, 0xf000d1fa, 0xbd3efaa7,
	0x0000000c, 0x40007000, 0x4605b53e, 0x483c466c, 0x6a404448, 0x0b01f804, 0x44484839, 0xb1586880,
	0xf8040e28, 0x0c280b01, 0x0b01f804, 0xf8040a28, 0xf8040b01, 0xe0075b01, 0xf8040c28, 0x0a280b01,
	0x0b01f804, 0x5b01f804, 0x4448482d, 0xb2c06980, 0xbf009002, 0x6840482b, 0x0010f020, 0x60484929,
	0xbf00bf00, 0x68004608, 0x1042f420, 0x4000f440, 0xbf006008, 0xa8022101, 0xfe00f000, 0x4821bf00,
	0xf0406840, 0x491f0010, 0xbf006048, 0xf000bf00, 0xf010fa5d, 0xd1fa0f01, 0xf000bf00, 0xf000fa57,
	0x28020002, 0xbf00d1f9, 0x68404816, 0x0010f020, 0x60484914, 0xbf00bf00, 0x68004608, 0x1042f420,
	0x4000f440, 0xbf006008, 0x4448480d, 0xb1086880, 0xe0002005, 0x46012004, 0xf0004668, 0xbf00fdcf,
	0x68404808, 0x0010f040, 0x60484906, 0xbf00bf00, 0xfa2cf000, 0x0f01f010, 0xf000d1fa, 0xbd3efa27,
	0x0000000c, 0x40007000, 0x41f0e92d, 0x460d4604, 0xe00a2600, 0x1c764631, 0x0021f854, 0xff74f7ff,
	0xd0020007, 0xe8bd4638, 0x42ae81f0, 0x2000d3f2, 0x0000e7f9, 0x4605b5f8, 0x4617460e, 0x497d2059,
	0xf04f6008, 0xf04f0016, 0xf8c14180, 0xf04f0100, 0xf8c10088, 0xf04f0100, 0xf8d04080, 0xf0100100,
	0xd1010f01, 0xbdf82001, 0x68004873, 0x7040f010, 0xf1b0d014, 0xd00d7f80, 0x7f00f1b0, 0xf1b0d006,
	0xd10f7f40, 0xf0002004, 0xe00ffb2d, 0xf0002003, 0xe00bfb29, 0xf0002002, 0xe007fb25, 0xf0002001,
	0xe003fb21, 0xf000200f, 0xbf00fb1d, 0xf240bf00, 0x49622005, 0xf2406008, 0xf04f10fb, 0xf8c14180,
	0x485f027c, 0x0270f8c1, 0x6800485e, 0x0038f040, 0x0210f8c1, 0xfc8ef000, 0x4080f04f, 0x0204f8d0,
	0x4080f440, 0x4180f04f, 0x0204f8c1, 0x44484856, 0x49566800, 0xf4f1fbb0, 0x44484853, 0xfbb06800,
	0xfb01f2f1, 0xb1000012, 0xbf001c64, 0x68404850, 0x401ff364, 0x6048494e, 0xbf00bf00, 0x68c04608,
	0x4060f020, 0xbf0060c8, 0x68c04608, 0x1080f420, 0xf04f60c8, 0x64886000, 0x4608bf00, 0xf0206840,
	0x60480020, 0x2066bf00, 0xbf009000, 0x68404608, 0x0010f020, 0xbf006048, 0x4608bf00, 0xf4206800,
	0xf4401042, 0x60084000, 0x2101bf00, 0xf0004668, 0xbf00fd05, 0x68404836, 0x0010f040, 0x60484934,
	0x2032bf00, 0xfe56f7ff, 0x90002099, 0x4830bf00, 0xf0206840, 0x492e0010, 0xbf006048, 0x4608bf00,
	0xf4206800, 0xf4401042, 0x60084000, 0x2101bf00, 0xf0004668, 0xbf00fce3, 0x68404825, 0x0010f040,
	0x60484923, 0x2032bf00, 0xfe34f7ff, 0x900020f0, 0x481fbf00, 0xf0206840, 0x491d0010, 0xbf006048,
	0x4608bf00, 0xf4206800, 0xf4401042, 0x60084000, 0x2101bf00, 0xf0004668, 0xbf00fcc1, 0x68404814,
	0x0010f040, 0x60484912, 0x2032bf00, 0xfe12f7ff, 0x6800480f, 0x0001f040, 0x6008490d, 0x68404608,
	0x6070f420, 0x6000f440, 0xf0006048, 0x2000f993, 0x0000e719, 0x40000100, 0x400001c0, 0x40000278,
	0x00010010, 0x40000210, 0x00000004, 0x005b8d80, 0x40007000, 0x47f0e92d, 0x460e4680, 0x48214617,
	0x68004448, 0x481fb1b0, 0x68404448, 0x481db190, 0x68c04448, 0x481bb170, 0x68004448, 0x63c8491a,
	0x44484818, 0x64086840, 0x68004608, 0x0001f020, 0xe0086008, 0x49142000, 0x640863c8, 0x68004608,
	0x0001f040, 0x24006008, 0x1b35e016, 0x7f80f5b5, 0xf44fd901, 0x462a7580, 0x46404639, 0xf88af000,
	0xe0024682, 0xf8c2f000, 0xf1ba4682, 0xd1f90f00, 0x442f44a8, 0x7480f504, 0xd3e642b4, 0xe8bd2000,
	0x000087f0, 0x0000000c, 0x40007000, 0x41f0e92d, 0x460d4680, 0x27004616, 0x1bece011, 0x7f80f5b4,
	0xf44fd901, 0x1ce07480, 0x00840880, 0x46314622, 0xf0004640, 0x44a0f809, 0xf5074426, 0x42af7780,
	0x2000d3eb, 0x81f0e8bd, 0x4603b510, 0x68004827, 0x0001f040, 0x60204c25, 0x4620bf00, 0xf4206800,
	0xf4400040, 0x60200000, 0xbf00bf00, 0x68004620, 0x407ff020, 0x7040f040, 0xbf006020, 0x4620bf00,
	0xf0206800, 0x4c1a0020, 0x68a4444c, 0x1044ea40, 0x60204c16, 0x4620bf00, 0x63426301, 0x68406383,
	0x0001f040, 0xbf006060, 0x4810bf00, 0xf0106840, 0xd1fa0f01, 0x480ebf00, 0x68004448, 0x480cb170,
	0x68404448, 0x480ab150, 0x68c04448, 0x4807b130, 0xf0206800, 0x4c050001, 0xe0056020, 0x68004803,
	0x0001f040, 0x60204c01, 0xbd102000, 0x40007000, 0x0000000c, 0x4604b570, 0x4616460d, 0x4819bf00,
	0xf4206800, 0xf4400040, 0x49160080, 0xbf006008, 0x4608bf00, 0xf0206800, 0xf040407f, 0x60087000,
	0xbf00bf00, 0x68004608, 0x0020f020, 0x4449490e, 0xea406889, 0x490b1041, 0xbf006008, 0x63054608,
	0x63846346, 0xf0406840, 0x60480001, 0xbf00bf00, 0x68404804, 0x0f01f010, 0xbf00d1fa, 0xf806f000,
	0x0000bd70, 0x40007000, 0x0000000c, 0x2000b51c, 0x48189001, 0x69c04448, 0xf88db2c0, 0xbf000000,
	0x68404815, 0x0010f020, 0x60484913, 0xbf00bf00, 0x68004608, 0x1042f420, 0x4000f440, 0xbf006008,
	0x46682101, 0xfb7af000, 0x480bbf00, 0xf4206800, 0x49091042, 0xbf006008, 0xa8012101, 0xfb2cf000,
	0x4805bf00, 0xf0406840, 0x49030010, 0xbf006048, 0xbd1c9801, 0x0000000c, 0x40007000, 0x4823b508,
	0x68804448, 0x4821b3f0, 0x6ac04448, 0xf88db2c0, 0xbf000000, 0x6840481e, 0x0010f020, 0x6048491c,
	0xbf00bf00, 0x68004608, 0x1042f420, 0x4000f440, 0xbf006008, 0x44484815, 0x28ff6b80, 0x4813d00a,
	0x6b804448, 0xf88db2c0, 0x21020001, 0xf0004668, 0xe003fb35, 0x46682101, 0xfb30f000, 0x480cbf00,
	0xf0406840, 0x490a0010, 0xbf006048, 0x4608bf00, 0xf0206800, 0x49050020, 0x68894449, 0x1041ea40,
	0xe0004903, 0x6008e001, 0xbd08bf00, 0x0000000c, 0x40007000, 0x2600b57c, 0x9000209f, 0x444c4c4a,
	0x484abf00, 0xf0206840, 0x49480010, 0xbf006048, 0x4608bf00, 0xf4206800, 0xf4401042, 0x60084000,
	0x2101bf00, 0xf0004668, 0xbf00faf9, 0x6800483f, 0x1042f420, 0x6008493d, 0x2103bf00, 0xf000a801,
	0xbf00faab, 0x68404839, 0x0010f040, 0x60484937, 0x9d01bf00, 0xf3c5bf00, 0x1e494103, 0x408a2201,
	0x17c10510, 0x7151eb00, 0xf1b610ce, 0xd9027f80, 0x60a02001, 0x2000e001, 0x200060a0, 0x602060e0,
	0x20026060, 0x200b6220, 0x200562a0, 0x202061e0, 0x20066260, 0x200161a0, 0xb2e86360, 0xd10a281c,
	0x62e020b7, 0x632020e9, 0x61202066, 0x61602099, 0x63a020ff, 0xb2e8e036, 0xd10828c8, 0x62e020b7,
	0x632020e9, 0x612020ff, 0x63a06160, 0xb2e8e02a, 0xd10a28ef, 0x62e020b7, 0x632020e9, 0x61202066,
	0x61602099, 0x63a020ff, 0xb2e8e01c, 0xd1092801, 0x62e02017, 0x20f06320, 0x20ff6120, 0x20806160,
	0xe00f63a0, 0x28c2b2e8, 0x20b7d10a, 0x20e962e0, 0x20666320, 0x20996120, 0x20ff6160, 0xe00163a0,
	0xbd7c2000, 0xe7fcbf00, 0x0000000c, 0x40007000, 0x4604b510, 0x44494912, 0x60086820, 0x60486860,
	0x608868a0, 0x60c868e0, 0x61086920, 0x61486960, 0x618869a0, 0x61c869e0, 0x62086a20, 0x62486a60,
	0x62886aa0, 0x62c86ae0, 0x63086b20, 0x63486b60, 0x63886ba0, 0xfef2f7ff, 0x44484801, 0xbd106ac0,
	0x0000000c, 0x21004602, 0x68004899, 0x0004f040, 0x4380f04f, 0x0200f8c3, 0x68004896, 0x0007f020,
	0x0007f100, 0x0210f8c3, 0x4893bf00, 0xf0106800, 0xd1fa0f80, 0x4b924891, 0x6018444b, 0x68004618,
	0xfbb04b90, 0x4b90f0f3, 0x6018444b, 0x3080f44f, 0x60184b8e, 0xd26e2a05, 0xf002e8df, 0x386ea4da,
	0x488b0003, 0x60184b89, 0x4883bf00, 0xf0106800, 0xd0000f04, 0x4608e004, 0x4b861c49, 0xdbf44298,
	0x4884bf00, 0xdb014281, 0x47702001, 0x7084f44f, 0x64d84b81, 0x68004877, 0x00c0f040, 0x4380f04f,
	0x0210f8c3, 0xf8d04618, 0xf0200220, 0xf8c3000f, 0x48700220, 0xf0206800, 0xf1000007, 0x4b6d0002,
	0x48766018, 0x444b4b6e, 0xe0c56018, 0x4b6f4874, 0xbf006018, 0x68004868, 0x0f04f010, 0xe004d000,
	0x1c494608, 0x42984b6b, 0xbf00dbf4, 0x42814869, 0x2001db01, 0xf240e7c9, 0x4b671007, 0x485d64d8,
	0xf0406800, 0xf04f00c0, 0xf8c34380, 0x46180210, 0x0220f8d0, 0x000ff020, 0x0220f8c3, 0x68004855,
	0x0007f020, 0x0002f100, 0x60184b52, 0x4b54485d, 0x6018444b, 0xe08ee090, 0x380a4855, 0x60184b53,
	0x484dbf00, 0xf0106800, 0xd0000f04, 0x4608e004, 0x4b501c49, 0xdbf44298, 0x484ebf00, 0xdb014281,
	0xe7922001, 0x1007f240, 0x64d84b4b, 0x68004841, 0x00c0f040, 0x4380f04f, 0x0210f8c3, 0xf8d04618,
	0xf0200220, 0xf8c3000f, 0x483a0220, 0xf0206800, 0xf1000007, 0x4b370002, 0x48436018, 0x444b4b38,
	0xe0596018, 0x380e483a, 0x60184b38, 0x4832bf00, 0xf0106800, 0xd0000f04, 0x4608e004, 0x4b351c49,
	0xdbf44298, 0x4833bf00, 0xdb014281, 0xe75c2001, 0x7083f44f, 0x64d84b30, 0x68004826, 0x00c0f040,
	0x4380f04f, 0x0210f8c3, 0xf8d04618, 0xf0200220, 0xf8c3000f, 0x481f0220, 0xf0206800, 0xf1000007,
	0x4b1c0002, 0x48296018, 0x444b4b1d, 0xe0236018, 0x68004817, 0x0001f040, 0x4380f04f, 0x0200f8c3,
	0x4815bf00, 0xf0106800, 0xd0000f01, 0x4608e004, 0x4b181c49, 0xdbf44298, 0x4816bf00, 0xdb014281,
	0xe7222001, 0x6800481a, 0x1301f240, 0xd0014218, 0xe71a2001, 0xbf00e000, 0x4809bf00, 0x68004448,
	0xfbb04b08, 0x4b08f0f3, 0x6018444b, 0xe70c2000, 0x40000200, 0x40000210, 0x40000250, 0x00b71b00,
	0x00000004, 0x000f4240, 0x00000008, 0x40000240, 0x00088430, 0x000186a0, 0x4000c000, 0x0bebc200,
	0x0008821c, 0x0aba9500, 0x09896800, 0x08954400, 0x40000274, 0x20004601, 0xe92d4770, 0xb0c045f0,
	0x460e4682, 0xf04f4617, 0xe01f0800, 0x0408eba6, 0x7f80f5b4, 0xf44fd901, 0x1ce07480, 0x00820880,
	0x46504669, 0xfcb0f7ff, 0xe0092500, 0x0005f81d, 0x42885d79, 0x4650d003, 0xe8bdb040, 0x1c6d85f0,
	0xd3f342a5, 0x442744a2, 0x7880f508, 0xd3dd45b0, 0xe7f14650, 0x4080f04f, 0x49346800, 0xd11b4288,
	0x4080f04f, 0x49326d00, 0xf04f4008, 0x65084180, 0x6e404608, 0x4008492f, 0x4180f04f, 0x46086648,
	0x492d6d00, 0x05094308, 0x46086508, 0x492b6e40, 0x04094308, 0xe0486648, 0x68004829, 0x0030f010,
	0x2810d032, 0x2820d020, 0x2830d00f, 0xf04fd13b, 0x6d004080, 0xf04fb2c0, 0x65084180, 0x6d004608,
	0x43084920, 0x65080509, 0xf04fe02e, 0x6e404080, 0x4008491d, 0x4180f04f, 0x46086648, 0x491b6e40,
	0x06094308, 0xe01f6648, 0x4080f04f, 0xf0006c00, 0xf04f407f, 0x64084180, 0x6c004608, 0x43084914,
	0x4180f04f, 0xe00f6408, 0x4080f04f, 0xf0006b00, 0xf04f407f, 0x63084180, 0x6b004608, 0x4308490d,
	0x63080749, 0xbf00e000, 0x4770bf00, 0x00d4874e, 0x00f0f0ff, 0xff0f0fff, 0x44040400, 0x00404000,
	0x400001c0, 0x44444400, 0xf000000f, 0x04444440, 0x00333333, 0x00222222, 0x4606b5f8, 0xe037460c,
	0xd3012c04, 0xe0002504, 0xbf004625, 0x6800481a, 0x0040f420, 0x60084918, 0xbf00bf00, 0x68004608,
	0x50f8f420, 0xebc12101, 0xea4001c5, 0x49122001, 0xbf006008, 0x4608bf00, 0xf4206800, 0x600840c0,
	0x4608bf00, 0xf0406840, 0x60480001, 0xbf00bf00, 0x68404809, 0x0f01f010, 0xbf00d1fa, 0x69004806,
	0x462a9000, 0x46304669, 0xf8eaf7ff, 0x1b64442e, 0xd1c52c00, 0x0000bdf8, 0x40007000, 0x4606b5f8,
	0xe038460c, 0xd3012c04, 0xe0002504, 0x20004625, 0x462a9000, 0x46684631, 0xf8d2f7ff, 0x98004917,
	0xbf006208, 0x68004608, 0x0040f420, 0xbf006008, 0x4608bf00, 0xf4206800, 0x210150f8, 0x01c5ebc1,
	0x2001ea40, 0x6008490d, 0xbf00bf00, 0x68004608, 0x40c0f420, 0xbf006008, 0x68404608, 0x0001f040,
	0xbf006048, 0x4805bf00, 0xf0106840, 0xd1fa0f01, 0x442ebf00, 0x2c001b64, 0xbdf8d1c4, 0x40007000,
	0x00000000, 0x01518000, 0x00000016, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
	0x00000000, 0x00000000
};

static const uint32_t numicro_NUC505_flash_algorithm_code[] = {
	0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
	0x4770ba40, 0x4770bac0, 0x0030ea4f, 0x00004770, 0x684a49ba, 0x0210f022, 0x1000ea42, 0x47706048,
	0x684a49b6, 0xd1fc07d2, 0x4207f44f, 0x6208600a, 0xf0406848, 0x60480001, 0x07c06848, 0x4770d1fc,
	0x684148ae, 0xd1fc07c9, 0x61e0f44f, 0x68416001, 0x0101f041, 0x68416041, 0xd1fc07c9, 0xb2c06900,
	0xb5004770, 0xf7ff2000, 0x2006ffd3, 0xffd8f7ff, 0xf85d2001, 0xe7cbeb04, 0x2000b500, 0xffc8f7ff,
	0xf7ff2005, 0xf7ffffcd, 0x07c0ffdb, 0x2001d1fb, 0xeb04f85d, 0xb500e7bc, 0xf7ff4603, 0x2000ffe2,
	0xffb6f7ff, 0xf7ff2020, 0xf3c3ffbb, 0xf7ff4007, 0xf3c3ffb7, 0xf7ff2007, 0xb2d8ffb3, 0xffb0f7ff,
	0xf7ff2001, 0xf85dffa5, 0xe7d5eb04, 0xf7ffb500, 0x2000ffc8, 0xff9cf7ff, 0xf7ff20c7, 0x2001ffa1,
	0xff96f7ff, 0xeb04f85d, 0xb570e7c6, 0x460e4615, 0xf7ff4604, 0x2000ffb6, 0xff8af7ff, 0x631c4b7f,
	0x639e635d, 0x7010f04f, 0x68586018, 0x0001f040, 0x68586058, 0xd1fc07c0, 0xf7ff2001, 0xe8bdff79,
	0xe7a94070, 0x4604b570, 0x460e4615, 0xf7ff2000, 0x4b72ff6f, 0x635d631c, 0x02d8639e, 0x68586018,
	0x0001f040, 0x68586058, 0xd1fc07c0, 0x4070e8bd, 0xe75d2001, 0x4603b500, 0xf7ff2000, 0x209fff59,
	0xff5ef7ff, 0xff6cf7ff, 0xf7ff7098, 0x7058ff69, 0xff66f7ff, 0x20017018, 0xeb04f85d, 0xf04fe748,
	0xf8d04080, 0xf0411204, 0xf8c00108, 0x495b1204, 0x6943684a, 0x020ff36f, 0x6380f443, 0x69436143,
	0x6380f423, 0x68486143, 0x4310b280, 0x68486048, 0x0020f020, 0x0010f040, 0x47706048, 0x2300b578,
	0x4180f04f, 0x68499300, 0xf0014d4d, 0x444d010f, 0xd0022907, 0xd0032906, 0x2101e030, 0xe0006069,
	0x2a01606b, 0x6028d100, 0xffc9f7ff, 0x68704e43, 0xf0206869, 0xea4000c0, 0x60701081, 0xf7ff4668,
	0x9800ffa9, 0x447ff06f, 0x407ff030, 0xd0019000, 0xd11442a0, 0xb1886868, 0x60681c40, 0xf0216871,
	0xea4101c0, 0x60701080, 0xf7ff4668, 0x9800ff93, 0x407ff030, 0xd0019000, 0xd10042a0, 0xbd782001,
	0xf7ffb500, 0x482dff9c, 0x4a2d6841, 0x01c0f021, 0x6852444a, 0x1182ea41, 0x20006041, 0x2001bd00,
	0x49274770, 0x4449b500, 0x1a406809, 0xff13f7ff, 0xbd002000, 0x41f0e92d, 0xf8df2700, 0x1cc98084,
	0x46064694, 0x0403f021, 0xe01944c8, 0x0ffff016, 0x2cffd10a, 0xf8d8d908, 0xf44f0000, 0x1a317580,
	0x0007eb0c, 0xe006462a, 0x0000f8d8, 0x1a314625, 0x0007eb0c, 0xf7ff4622, 0x442eff18, 0x1b64442f,
	0xd1e32c00, 0xe8bd2000, 0xb57081f0, 0x460c4616, 0x4605460a, 0x480b4601, 0xf7ff4448, 0x4809ff23,
	0x44482100, 0x5c42e006, 0x429a5c73, 0x1868d001, 0x1c49bd70, 0xd3f642a1, 0xbd701928, 0x40007000,
	0x00000004, 0x0000000c, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000
};

static int numicro_init_isp(struct target *target)
{
	struct working_area *init_algorithm;
	struct reg_param reg_params[6];
	struct armv7m_common *armv7m = target_to_armv7m(target);
	struct armv7m_algorithm armv7m_info;
	uint32_t algorithm_init_entry_offset = 0;
	uint32_t algorithm_lr = 0;
	int retval = ERROR_OK;
	uint32_t reg_stat;

	if (target->state != TARGET_HALTED) {
		LOG_ERROR("Target not halted");
		return ERROR_TARGET_NOT_HALTED;
	}

	if (m_M23SecureDebugState == NUMICRO_M23_SECURE_DEBUG_NS) {
		if (strcmp(m_target_name, "M2354") == 0) {
			algorithm_init_entry_offset = 0xC9;
			algorithm_lr = 0x30010001;

			/* allocate working area with init info code */
			if (target_alloc_working_area(target, sizeof(numicro_M2354_NS_flash_algorithm_code),
				&init_algorithm) != ERROR_OK) {
				LOG_WARNING("no working area available, can't do block memory erase");
				return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
			}

			retval = target_write_buffer(target, init_algorithm->address,
				sizeof(numicro_M2354_NS_flash_algorithm_code), (const uint8_t *)numicro_M2354_NS_flash_algorithm_code);
			if (retval != ERROR_OK)
				return retval;

			armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
			armv7m_info.core_mode = ARM_MODE_THREAD;
			if (armv7m == NULL) {
				/* something is very wrong if armv7m is NULL */
				LOG_ERROR("unable to get armv7m target");
				return retval;
			}

			init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);    /* faddr */
			init_reg_param(&reg_params[1], "sp", 32, PARAM_OUT);    /* update SP */
			init_reg_param(&reg_params[2], "lr", 32, PARAM_OUT);

			buf_set_u32(reg_params[0].value, 0, 32, 0);
			buf_set_u32(reg_params[1].value, 0, 32, init_algorithm->address + target->working_area_size);
			buf_set_u32(reg_params[2].value, 0, 32, algorithm_lr);

			retval = target_run_algorithm(target, 0, NULL, 3, reg_params,
				init_algorithm->address + algorithm_init_entry_offset, 0, 100000, &armv7m_info);
			if (retval != ERROR_OK) {
				LOG_ERROR("Error executing NuMicro Flash erase algorithm");
				retval = ERROR_FLASH_OPERATION_FAILED;
			}

			target_free_working_area(target, init_algorithm);
			destroy_reg_param(&reg_params[0]);
			destroy_reg_param(&reg_params[1]);
			destroy_reg_param(&reg_params[2]);
		}
		else {
			LOG_DEBUG("numicro_init_isp skips since Secure invasive debug is prohibited.");
		}
		return ERROR_OK;
	}

	if (strcmp(m_target_name, "NUC505") == 0) {
		algorithm_init_entry_offset = 0x1DD;
		algorithm_lr = 0x20000001;

		/* allocate working area with init info code */
		if (target_alloc_working_area(target, sizeof(numicro_NUC505_flash_algorithm_code),
			&init_algorithm) != ERROR_OK) {
			LOG_WARNING("no working area available, can't do block memory erase");
			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
		}

		retval = target_write_buffer(target, init_algorithm->address,
			sizeof(numicro_NUC505_flash_algorithm_code), (const uint8_t *)numicro_NUC505_flash_algorithm_code);
		if (retval != ERROR_OK)
			return retval;

		armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
		armv7m_info.core_mode = ARM_MODE_THREAD;
		if (armv7m == NULL) {
			/* something is very wrong if armv7m is NULL */
			LOG_ERROR("unable to get armv7m target");
			return retval;
		}

		init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
		init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
		init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT);
		init_reg_param(&reg_params[3], "r9", 32, PARAM_OUT);
		init_reg_param(&reg_params[4], "sp", 32, PARAM_OUT);    /* update SP */
		init_reg_param(&reg_params[5], "lr", 32, PARAM_OUT);    /* update LR */

		/* use init info code within NuMicro */
		buf_set_u32(reg_params[0].value, 0, 32, 0);
		buf_set_u32(reg_params[1].value, 0, 32, 0);
		buf_set_u32(reg_params[2].value, 0, 32, 0);
		buf_set_u32(reg_params[3].value, 0, 32, 0x2000032C);
		buf_set_u32(reg_params[4].value, 0, 32, init_algorithm->address + 126 * 1024);
		buf_set_u32(reg_params[5].value, 0, 32, algorithm_lr);

		retval = target_run_algorithm(target, 0, NULL, 6, reg_params,
			init_algorithm->address + algorithm_init_entry_offset, 0, 100000, &armv7m_info);
		if (retval != ERROR_OK) {
			LOG_ERROR("Error executing NuMicro init algorithm");
			retval = ERROR_FLASH_OPERATION_FAILED;
		}

		target_free_working_area(target, init_algorithm);
		destroy_reg_param(&reg_params[0]);
		destroy_reg_param(&reg_params[1]);
		destroy_reg_param(&reg_params[2]);
		destroy_reg_param(&reg_params[3]);
		destroy_reg_param(&reg_params[4]);
		destroy_reg_param(&reg_params[5]);
	}
	else {
		retval = numicro_reg_unlock(target);
		if (retval != ERROR_OK)
			return retval;

		/* Enable ISP/SRAM/TICK Clock */
		retval = target_read_u32(target, NUMICRO_SYSCLK_AHBCLK - m_addressMinusOffset, &reg_stat);
		if (retval != ERROR_OK)
			return retval;

		reg_stat |= AHBCLK_ISP_EN | AHBCLK_SRAM_EN | AHBCLK_TICK_EN;
		retval = target_write_u32(target, NUMICRO_SYSCLK_AHBCLK - m_addressMinusOffset, reg_stat);
		if (retval != ERROR_OK)
			return retval;

		/* Enable ISP */
		retval = target_read_u32(target, NUMICRO_FLASH_ISPCON - m_addressMinusOffset, &reg_stat);
		if (retval != ERROR_OK)
			return retval;

		reg_stat |= ISPCON_ISPFF | ISPCON_LDUEN | ISPCON_APUEN | ISPCON_CFGUEN | ISPCON_ISPEN;
		retval = target_write_u32(target, NUMICRO_FLASH_ISPCON - m_addressMinusOffset, reg_stat);
		if (retval != ERROR_OK)
			return retval;

		/* Write one to undocumented flash control register */
		retval = target_write_u32(target, NUMICRO_FLASH_CHEAT - m_addressMinusOffset, 1);
		if (retval != ERROR_OK)
			return retval;
	}

	LOG_DEBUG("numicro_init_isp is done.");
	return ERROR_OK;
}

/* Program LongWord Block Write */
static int numicro_writeblock(struct flash_bank *bank, const uint8_t *buffer,
		uint32_t offset, uint32_t count)
{
	struct target *target = bank->target;
	uint32_t buffer_size = 1024; /* Default minimum value */
	uint32_t totalCount = count;
	uint32_t thisrun_count = 0;
	struct working_area *write_algorithm;
	struct working_area *source;
	struct working_area *source2;
	uint32_t address = bank->base + offset;
	struct reg_param reg_params[6];
	struct armv7m_common *armv7m = target_to_armv7m(target);
	struct armv7m_algorithm armv7m_info;
	uint32_t algorithm_programPage_entry_offset = 0;
	uint32_t algorithm_lr = 0;
	bool bSPIMFlashWrite = (bank->base + offset < NUMICRO_SPIM_FLASH_START_ADDRESS)? 0 : 1;
	bool bDFMCFlashWrite = (bank->base + offset < NUMICRO_DATA_DFMC_BASE)? 0 : 1;
	int retval = ERROR_OK;

	/* Params:
	 * r0 - workarea buffer / result
	 * r1 - target address
	 * r2 - wordcount
	 * Clobbered:
	 * r4 - tmp
	 * r5 - tmp
	 * r6 - tmp
	 * r7 - tmp
	 */

	/* check code alignment */
	if (offset & 0x1) {
		LOG_WARNING("offset 0x%" PRIx32 " breaks required 2-byte alignment", offset);
		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
	}

	/* Difference between M0 and M4(M23) */
	if (armv7m->arm.is_armv6m) {
		/* allocate working area with flash programming code */
		if (armv7m->arm.is_NUC_M0_FMC_MSB4) {
			if (target_alloc_working_area(target, sizeof(numicro_M4_M23_flash_write_code),
				&write_algorithm) != ERROR_OK) {
				LOG_WARNING("no working area available, can't do block memory writes");
				return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
			}

			retval = target_write_buffer(target, write_algorithm->address,
				sizeof(numicro_M4_M23_flash_write_code), numicro_M4_M23_flash_write_code);
			if (retval != ERROR_OK)
				return retval;
		}
		else {
			if (target_alloc_working_area(target, sizeof(numicro_M0_flash_write_code),
				&write_algorithm) != ERROR_OK) {
				LOG_WARNING("no working area available, can't do block memory writes");
				return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
			}

			retval = target_write_buffer(target, write_algorithm->address,
				sizeof(numicro_M0_flash_write_code), numicro_M0_flash_write_code);
			if (retval != ERROR_OK)
				return retval;
		}
	}
	else { /* for M4 and M23 */
		if (strcmp(m_target_name, "M480") == 0) {
			if (bSPIMFlashWrite) {
				/* allocate working area with flash programming code */
				if (target_alloc_working_area(target, sizeof(numicro_M480_spim_flash_algorithm_code),
					&write_algorithm) != ERROR_OK) {
					LOG_WARNING("no working area available, can't do block memory writes");
					return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
				}

				retval = target_write_buffer(target, write_algorithm->address,
					sizeof(numicro_M480_spim_flash_algorithm_code), (const uint8_t *)numicro_M480_spim_flash_algorithm_code);
				if (retval != ERROR_OK)
					return retval;
			}
			else {
				algorithm_programPage_entry_offset = 0x339;
				algorithm_lr = 0x20000001;

				/* allocate working area with flash programming code */
				if (target_alloc_working_area(target, sizeof(numicro_M480_flash_algorithm_code),
					&write_algorithm) != ERROR_OK) {
					LOG_WARNING("no working area available, can't do block memory writes");
					return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
				}

				retval = target_write_buffer(target, write_algorithm->address,
					sizeof(numicro_M480_flash_algorithm_code), (const uint8_t *)numicro_M480_flash_algorithm_code);
				if (retval != ERROR_OK)
					return retval;
			}
		}
		else if (strcmp(m_target_name, "NUC505") == 0) {
			buffer_size = 0x1000;
			algorithm_programPage_entry_offset = 0x295;
			algorithm_lr = 0x20000001;

			/* allocate working area with flash programming code */
			if (target_alloc_working_area(target, sizeof(numicro_NUC505_flash_algorithm_code),
				&write_algorithm) != ERROR_OK) {
				LOG_WARNING("no working area available, can't do block memory writes");
				return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
			}

			retval = target_write_buffer(target, write_algorithm->address,
				sizeof(numicro_NUC505_flash_algorithm_code), (const uint8_t *)numicro_NUC505_flash_algorithm_code);
			if (retval != ERROR_OK)
				return retval;
		}
		else if (strcmp(m_target_name, "NUC1262") == 0) {
			if (target_alloc_working_area(target, sizeof(numicro_M0_flash_write_code),
				&write_algorithm) != ERROR_OK) {
				LOG_WARNING("no working area available, can't do block memory writes");
				return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
			}

			retval = target_write_buffer(target, write_algorithm->address,
				sizeof(numicro_M0_flash_write_code), numicro_M0_flash_write_code);
			if (retval != ERROR_OK)
				return retval;
		}
		else if(strcmp(m_target_name, "M471") == 0 && bDFMCFlashWrite) {
			if (target_alloc_working_area(target, sizeof(numicro_M471_dataflash_flash_algorithm_code),
				&write_algorithm) != ERROR_OK) {
				LOG_WARNING("no working area available, can't do block memory writes");
				return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
			}

			retval = target_write_buffer(target, write_algorithm->address,
				sizeof(numicro_M471_dataflash_flash_algorithm_code), (const uint8_t *)numicro_M471_dataflash_flash_algorithm_code);
			if (retval != ERROR_OK)
				return retval;
		}
		else if (m_M23SecureDebugState != NUMICRO_M23_SECURE_DEBUG_NS) {
			/* allocate working area with flash programming code */
			if (target_alloc_working_area(target, sizeof(numicro_M4_M23_flash_write_code),
				&write_algorithm) != ERROR_OK) {
				LOG_WARNING("no working area available, can't do block memory writes");
				return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
			}

			retval = target_write_buffer(target, write_algorithm->address,
				sizeof(numicro_M4_M23_flash_write_code), numicro_M4_M23_flash_write_code);
			if (retval != ERROR_OK)
				return retval;
		}
		else {
			if (strcmp(m_target_name, "M2354") == 0) {
				algorithm_programPage_entry_offset = 0x1E9;
				algorithm_lr = 0x30010001;

				/* allocate working area with flash programming code */
				if (target_alloc_working_area(target, sizeof(numicro_M2354_NS_flash_algorithm_code),
					&write_algorithm) != ERROR_OK) {
					LOG_WARNING("no working area available, can't do block memory writes");
					return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
				}

				retval = target_write_buffer(target, write_algorithm->address,
					sizeof(numicro_M2354_NS_flash_algorithm_code), (const uint8_t *)numicro_M2354_NS_flash_algorithm_code);
				if (retval != ERROR_OK)
					return retval;
			}
			else {
				/* allocate working area with flash programming code */
				if (target_alloc_working_area(target, sizeof(numicro_M2351_NS_flash_write_code),
					&write_algorithm) != ERROR_OK) {
					LOG_WARNING("no working area available, can't do block memory writes");
					return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
				}

				retval = target_write_buffer(target, write_algorithm->address,
					sizeof(numicro_M2351_NS_flash_write_code), numicro_M2351_NS_flash_write_code);
				if (retval != ERROR_OK)
					return retval;
			}
		}
		/*buffer_size = m_pageSize; <- it doesn't matter because the flash algorithm uses the word programming. */
	}

	/* Increase buffer_size if needed */
	if (buffer_size == 1024 /*&& buffer_size < ((target->working_area_size - write_algorithm->size)/2)*/) {
		buffer_size = (target->working_area_size - write_algorithm->size - 512) / 2; /* 512 bytes for stack */

		if (buffer_size & 0x1)
			buffer_size = buffer_size - 1;

		/* buffer for alignment */
		if (buffer_size >= 128) {
			buffer_size = buffer_size / 128 * 128;
		}
		else {
			buffer_size = buffer_size - 10;
		}
	}

	/* memory buffer */
	if ((target_alloc_working_area(target, buffer_size, &source) != ERROR_OK) ||
		(target_alloc_working_area(target, buffer_size, &source2) != ERROR_OK)) {
		/* free working area, write algorithm already allocated */
		target_free_working_area(target, write_algorithm);

		LOG_WARNING("No large enough working area available, can't do block memory writes");
		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
	}

	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
	armv7m_info.core_mode = ARM_MODE_THREAD;
	if (armv7m == NULL) {
		/* something is very wrong if armv7m is NULL */
		LOG_ERROR("unable to get armv7m target");
		return retval;
	}

	if ((strcmp(m_target_name, "M2354") == 0 && m_M23SecureDebugState == NUMICRO_M23_SECURE_DEBUG_NS) ||
		(strcmp(m_target_name, "M480")  == 0 && !bSPIMFlashWrite)) {
		init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);    /* faddr */
		init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);    /* number of words to program */
		init_reg_param(&reg_params[2], "r2", 32, PARAM_IN_OUT); /* *pLW (*buffer) */
		init_reg_param(&reg_params[3], "sp", 32, PARAM_OUT);    /* update SP */
		init_reg_param(&reg_params[4], "lr", 32, PARAM_OUT);    /* update LR */

		/* write code buffer and use flash programming code within numicro */
		/* set breakpoint to 0 with time-out of 10000 ms                  */
		while (count > 0) {
			if (count == totalCount) {
				thisrun_count = (count > (buffer_size / 4)) ? (buffer_size / 4) : count;

				retval = target_write_buffer(target, source->address, thisrun_count * 4, buffer);
				if (retval != ERROR_OK)
					break;
			}

			buf_set_u32(reg_params[0].value, 0, 32, address/* & NUMICRO_TZ_MASK*/);
			buf_set_u32(reg_params[1].value, 0, 32, thisrun_count * 4);
			buf_set_u32(reg_params[2].value, 0, 32, source->address);
			buf_set_u32(reg_params[3].value, 0, 32, write_algorithm->address + target->working_area_size);
			buf_set_u32(reg_params[4].value, 0, 32, algorithm_lr);

			retval = target_start_algorithm(target, 0, NULL, 5, reg_params,
				write_algorithm->address + algorithm_programPage_entry_offset, 0, &armv7m_info);

			buffer  += thisrun_count * 4;
			address += thisrun_count * 4;
			count   -= thisrun_count;
			LOG_INFO("Have written %d%%", (totalCount - count) * 100 / totalCount);

			thisrun_count = (count > (buffer_size / 4)) ? (buffer_size / 4) : count;

			if (thisrun_count > 0) {
				retval = target_write_buffer(target, source2->address, thisrun_count * 4, buffer);
				if (retval != ERROR_OK)
					break;
			}

			retval = target_wait_algorithm(target, 0, NULL, 5, reg_params,
				0, 10000, &armv7m_info);

			if (thisrun_count == 0)
				break;

			buf_set_u32(reg_params[0].value, 0, 32, address/* & NUMICRO_TZ_MASK*/);
			buf_set_u32(reg_params[1].value, 0, 32, thisrun_count * 4);
			buf_set_u32(reg_params[2].value, 0, 32, source2->address);
			buf_set_u32(reg_params[3].value, 0, 32, write_algorithm->address + target->working_area_size);
			buf_set_u32(reg_params[4].value, 0, 32, algorithm_lr);

			retval = target_start_algorithm(target, 0, NULL, 5, reg_params,
				write_algorithm->address + algorithm_programPage_entry_offset, 0, &armv7m_info);

			buffer  += thisrun_count * 4;
			address += thisrun_count * 4;
			count   -= thisrun_count;
			LOG_INFO("Have written %d%%", (totalCount - count) * 100 / totalCount);

			if (count != 0) {
				thisrun_count = (count > (buffer_size / 4)) ? (buffer_size / 4) : count;

				retval = target_write_buffer(target, source->address, thisrun_count * 4, buffer);
				if (retval != ERROR_OK)
					break;
			}

			retval = target_wait_algorithm(target, 0, NULL, 5, reg_params,
				0, 10000, &armv7m_info);
		}

		target_free_working_area(target, source);
		target_free_working_area(target, source2);
		target_free_working_area(target, write_algorithm);
		destroy_reg_param(&reg_params[0]);
		destroy_reg_param(&reg_params[1]);
		destroy_reg_param(&reg_params[2]);
		destroy_reg_param(&reg_params[3]);
		destroy_reg_param(&reg_params[4]);
	}
	else if (strcmp(m_target_name, "M480") == 0 && bSPIMFlashWrite) {
		// init
		algorithm_programPage_entry_offset = 0x315;
		algorithm_lr = 0x20000001;

		init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
		init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
		init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT);
		init_reg_param(&reg_params[3], "r9", 32, PARAM_OUT);
		init_reg_param(&reg_params[4], "sp", 32, PARAM_OUT);    /* update SP */
		init_reg_param(&reg_params[5], "lr", 32, PARAM_OUT);    /* update LR */

		/* use init info code within NuMicro */
		buf_set_u32(reg_params[0].value, 0, 32, 0);
		buf_set_u32(reg_params[1].value, 0, 32, 0);
		buf_set_u32(reg_params[2].value, 0, 32, 0);
		buf_set_u32(reg_params[3].value, 0, 32, 0x20000EE0);
		buf_set_u32(reg_params[4].value, 0, 32, write_algorithm->address + target->working_area_size);
		buf_set_u32(reg_params[5].value, 0, 32, algorithm_lr);

		retval = target_run_algorithm(target, 0, NULL, 6, reg_params,
			write_algorithm->address + algorithm_programPage_entry_offset, 0, 100000, &armv7m_info);
		if (retval != ERROR_OK) {
			LOG_ERROR("Error executing NuMicro init algorithm");
			retval = ERROR_FLASH_OPERATION_FAILED;
		}

		// ChipErase
		if (!m_bSPIMFlashSectorErased) {
			algorithm_programPage_entry_offset = 0x12D;
			retval = target_run_algorithm(target, 0, NULL, 6, reg_params,
				write_algorithm->address + algorithm_programPage_entry_offset, 0, 100000, &armv7m_info);
			if (retval != ERROR_OK) {
				LOG_ERROR("Error executing NuMicro chip erase algorithm");
				retval = ERROR_FLASH_OPERATION_FAILED;
			}
		}
		m_bSPIMFlashSectorErased = 0;

		// ProgramPage
		algorithm_programPage_entry_offset = 0x535;
		algorithm_lr = 0x20000001;

		/* write code buffer and use flash programming code within numicro */
		/* set breakpoint to 0 with time-out of 10000 ms                  */
		while (count > 0) {
			if (count == totalCount) {
				thisrun_count = (count > (buffer_size / 4)) ? (buffer_size / 4) : count;

				retval = target_write_buffer(target, source->address, thisrun_count * 4, buffer);
				if (retval != ERROR_OK)
					break;
			}

			buf_set_u32(reg_params[0].value, 0, 32, address - NUMICRO_SPIM_FLASH_START_ADDRESS);
			buf_set_u32(reg_params[1].value, 0, 32, thisrun_count * 4);
			buf_set_u32(reg_params[2].value, 0, 32, source->address);
			buf_set_u32(reg_params[3].value, 0, 32, 0x20000EE0);
			buf_set_u32(reg_params[4].value, 0, 32, write_algorithm->address + target->working_area_size);
			buf_set_u32(reg_params[5].value, 0, 32, algorithm_lr);

			retval = target_start_algorithm(target, 0, NULL, 6, reg_params,
				write_algorithm->address + algorithm_programPage_entry_offset, 0, &armv7m_info);

			buffer  += thisrun_count * 4;
			address += thisrun_count * 4;
			count   -= thisrun_count;
			LOG_INFO("Have written %d%%", (totalCount - count) * 100 / totalCount);

			thisrun_count = (count > (buffer_size / 4)) ? (buffer_size / 4) : count;

			if (thisrun_count > 0) {
				retval = target_write_buffer(target, source2->address, thisrun_count * 4, buffer);
				if (retval != ERROR_OK)
					break;
			}

			retval = target_wait_algorithm(target, 0, NULL, 6, reg_params,
				0, 10000, &armv7m_info);

			if (thisrun_count == 0)
				break;

			buf_set_u32(reg_params[0].value, 0, 32, address - NUMICRO_SPIM_FLASH_START_ADDRESS);
			buf_set_u32(reg_params[1].value, 0, 32, thisrun_count * 4);
			buf_set_u32(reg_params[2].value, 0, 32, source2->address);
			buf_set_u32(reg_params[3].value, 0, 32, 0x20000EE0);
			buf_set_u32(reg_params[4].value, 0, 32, write_algorithm->address + target->working_area_size);
			buf_set_u32(reg_params[5].value, 0, 32, algorithm_lr);

			retval = target_start_algorithm(target, 0, NULL, 6, reg_params,
				write_algorithm->address + algorithm_programPage_entry_offset, 0, &armv7m_info);

			buffer  += thisrun_count * 4;
			address += thisrun_count * 4;
			count   -= thisrun_count;
			LOG_INFO("Have written %d%%", (totalCount - count) * 100 / totalCount);

			if (count != 0) {
				thisrun_count = (count > (buffer_size / 4)) ? (buffer_size / 4) : count;

				retval = target_write_buffer(target, source->address, thisrun_count * 4, buffer);
				if (retval != ERROR_OK)
					break;
			}

			retval = target_wait_algorithm(target, 0, NULL, 6, reg_params,
				0, 10000, &armv7m_info);
		}

		// uninit
		algorithm_programPage_entry_offset = 0xC75;
		algorithm_lr = 0x20000001;

		buf_set_u32(reg_params[0].value, 0, 32, 0);
		buf_set_u32(reg_params[1].value, 0, 32, 0);
		buf_set_u32(reg_params[2].value, 0, 32, 0);
		buf_set_u32(reg_params[3].value, 0, 32, 0x20000EE0);
		buf_set_u32(reg_params[4].value, 0, 32, write_algorithm->address + target->working_area_size);
		buf_set_u32(reg_params[5].value, 0, 32, algorithm_lr);

		retval = target_run_algorithm(target, 0, NULL, 6, reg_params,
					write_algorithm->address + algorithm_programPage_entry_offset, 0, 100000, &armv7m_info);
		if (retval != ERROR_OK) {
			LOG_ERROR("Error executing NuMicro Flash uninit algorithm");
			retval = ERROR_FLASH_OPERATION_FAILED;
		}

		target_free_working_area(target, source);
		target_free_working_area(target, source2);
		target_free_working_area(target, write_algorithm);
		destroy_reg_param(&reg_params[0]);
		destroy_reg_param(&reg_params[1]);
		destroy_reg_param(&reg_params[2]);
		destroy_reg_param(&reg_params[3]);
		destroy_reg_param(&reg_params[4]);
		destroy_reg_param(&reg_params[5]);
	}
	else if (strcmp(m_target_name, "NUC505") == 0) {
		init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);    /* faddr */
		init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);    /* number of words to program */
		init_reg_param(&reg_params[2], "r2", 32, PARAM_IN_OUT); /* *pLW (*buffer) */
		init_reg_param(&reg_params[3], "r9", 32, PARAM_OUT);
		init_reg_param(&reg_params[4], "sp", 32, PARAM_OUT);    /* update SP */
		init_reg_param(&reg_params[5], "lr", 32, PARAM_OUT);    /* update LR */

		/* write code buffer and use flash programming code within numicro */
		/* set breakpoint to 0 with time-out of 10000 ms                  */
		while (count > 0) {
			if (count == totalCount) {
				thisrun_count = (count > (buffer_size / 4)) ? (buffer_size / 4) : count;

				retval = target_write_buffer(target, source->address, thisrun_count * 4, buffer);
				if (retval != ERROR_OK)
					break;
			}

			buf_set_u32(reg_params[0].value, 0, 32, address & NUMICRO_TZ_MASK);
			buf_set_u32(reg_params[1].value, 0, 32, thisrun_count * 4);
			buf_set_u32(reg_params[2].value, 0, 32, source->address);
			buf_set_u32(reg_params[3].value, 0, 32, 0x2000032C);
			buf_set_u32(reg_params[4].value, 0, 32, write_algorithm->address + 126 * 1024);
			buf_set_u32(reg_params[5].value, 0, 32, algorithm_lr);

			retval = target_start_algorithm(target, 0, NULL, 6, reg_params,
				write_algorithm->address + algorithm_programPage_entry_offset, 0, &armv7m_info);

			buffer  += thisrun_count * 4;
			address += thisrun_count * 4;
			count   -= thisrun_count;
			LOG_INFO("Have written %d%%", (totalCount - count) * 100 / totalCount);

			thisrun_count = (count > (buffer_size / 4)) ? (buffer_size / 4) : count;

			if (thisrun_count > 0) {
				retval = target_write_buffer(target, source2->address, thisrun_count * 4, buffer);
				if (retval != ERROR_OK)
					break;
			}

			retval = target_wait_algorithm(target, 0, NULL, 6, reg_params,
				0, 10000, &armv7m_info);

			if (thisrun_count == 0)
				break;

			buf_set_u32(reg_params[0].value, 0, 32, address & NUMICRO_TZ_MASK);
			buf_set_u32(reg_params[1].value, 0, 32, thisrun_count * 4);
			buf_set_u32(reg_params[2].value, 0, 32, source2->address);
			buf_set_u32(reg_params[3].value, 0, 32, 0x2000032C);
			buf_set_u32(reg_params[4].value, 0, 32, write_algorithm->address + 126 * 1024);
			buf_set_u32(reg_params[5].value, 0, 32, algorithm_lr);

			retval = target_start_algorithm(target, 0, NULL, 6, reg_params,
				write_algorithm->address + algorithm_programPage_entry_offset, 0, &armv7m_info);

			buffer  += thisrun_count * 4;
			address += thisrun_count * 4;
			count   -= thisrun_count;
			LOG_INFO("Have written %d%%", (totalCount - count) * 100 / totalCount);

			if (count != 0) {
				thisrun_count = (count > (buffer_size / 4)) ? (buffer_size / 4) : count;

				retval = target_write_buffer(target, source->address, thisrun_count * 4, buffer);
				if (retval != ERROR_OK)
					break;
			}

			retval = target_wait_algorithm(target, 0, NULL, 6, reg_params,
				0, 10000, &armv7m_info);
		}

		// uninit
		algorithm_programPage_entry_offset = 0x261;
		algorithm_lr = 0x20000001;

		buf_set_u32(reg_params[0].value, 0, 32, 0);
		buf_set_u32(reg_params[1].value, 0, 32, 0);
		buf_set_u32(reg_params[2].value, 0, 32, 0);
		buf_set_u32(reg_params[3].value, 0, 32, 0x2000032C);
		buf_set_u32(reg_params[4].value, 0, 32, write_algorithm->address + 126 * 1024);
		buf_set_u32(reg_params[5].value, 0, 32, algorithm_lr);

		retval = target_run_algorithm(target, 0, NULL, 6, reg_params,
					write_algorithm->address + algorithm_programPage_entry_offset, 0, 100000, &armv7m_info);
		if (retval != ERROR_OK) {
			LOG_ERROR("Error executing NuMicro Flash uninit algorithm");
			retval = ERROR_FLASH_OPERATION_FAILED;
		}

		target_free_working_area(target, source);
		target_free_working_area(target, source2);
		target_free_working_area(target, write_algorithm);
		destroy_reg_param(&reg_params[0]);
		destroy_reg_param(&reg_params[1]);
		destroy_reg_param(&reg_params[2]);
		destroy_reg_param(&reg_params[3]);
		destroy_reg_param(&reg_params[4]);
		destroy_reg_param(&reg_params[5]);

		/* chip reset */
		target_write_u32(target, 0x40000008, 0x2);
		/* wait for NUC505 IBR operations */
		busy_sleep(50);
	}
	else if (strcmp(m_target_name, "M471") == 0 && bDFMCFlashWrite) {
		// init
		algorithm_programPage_entry_offset = 0x5;
		algorithm_lr = 0x20000001;

		init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
		init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
		init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT);
		init_reg_param(&reg_params[3], "r9", 32, PARAM_OUT);
		init_reg_param(&reg_params[4], "sp", 32, PARAM_OUT);    /* update SP */
		init_reg_param(&reg_params[5], "lr", 32, PARAM_OUT);    /* update LR */

		/* use init info code within NuMicro */
		buf_set_u32(reg_params[0].value, 0, 32, 0);
		buf_set_u32(reg_params[1].value, 0, 32, 0);
		buf_set_u32(reg_params[2].value, 0, 32, 0);
		buf_set_u32(reg_params[3].value, 0, 32, 0x20000244);
		buf_set_u32(reg_params[4].value, 0, 32, write_algorithm->address + target->working_area_size);
		buf_set_u32(reg_params[5].value, 0, 32, algorithm_lr);

		retval = target_run_algorithm(target, 0, NULL, 6, reg_params,
			write_algorithm->address + algorithm_programPage_entry_offset, 0, 100000, &armv7m_info);
		if (retval != ERROR_OK) {
			LOG_ERROR("Error executing NuMicro init algorithm");
			retval = ERROR_FLASH_OPERATION_FAILED;
		}

		// ProgramPage
		algorithm_programPage_entry_offset = 0x151;
		algorithm_lr = 0x20000001;

		/* write code buffer and use flash programming code within numicro */
		/* set breakpoint to 0 with time-out of 10000 ms                  */
		while (count > 0) {
			if (count == totalCount) {
				thisrun_count = (count > (buffer_size / 4)) ? (buffer_size / 4) : count;

				retval = target_write_buffer(target, source->address, thisrun_count * 4, buffer);
				if (retval != ERROR_OK)
					break;
			}

			buf_set_u32(reg_params[0].value, 0, 32, address);
			buf_set_u32(reg_params[1].value, 0, 32, thisrun_count * 4);
			buf_set_u32(reg_params[2].value, 0, 32, source->address);
			buf_set_u32(reg_params[3].value, 0, 32, 0x20000244);
			buf_set_u32(reg_params[4].value, 0, 32, write_algorithm->address + target->working_area_size);
			buf_set_u32(reg_params[5].value, 0, 32, algorithm_lr);

			retval = target_start_algorithm(target, 0, NULL, 6, reg_params,
				write_algorithm->address + algorithm_programPage_entry_offset, 0, &armv7m_info);

			buffer  += thisrun_count * 4;
			address += thisrun_count * 4;
			count   -= thisrun_count;
			LOG_INFO("Have written %d%%", (totalCount - count) * 100 / totalCount);

			thisrun_count = (count > (buffer_size / 4)) ? (buffer_size / 4) : count;

			if (thisrun_count > 0) {
				retval = target_write_buffer(target, source2->address, thisrun_count * 4, buffer);
				if (retval != ERROR_OK)
					break;
			}

			retval = target_wait_algorithm(target, 0, NULL, 6, reg_params,
				0, 10000, &armv7m_info);

			if (thisrun_count == 0)
				break;

			buf_set_u32(reg_params[0].value, 0, 32, address);
			buf_set_u32(reg_params[1].value, 0, 32, thisrun_count * 4);
			buf_set_u32(reg_params[2].value, 0, 32, source2->address);
			buf_set_u32(reg_params[3].value, 0, 32, 0x20000244);
			buf_set_u32(reg_params[4].value, 0, 32, write_algorithm->address + target->working_area_size);
			buf_set_u32(reg_params[5].value, 0, 32, algorithm_lr);

			retval = target_start_algorithm(target, 0, NULL, 6, reg_params,
				write_algorithm->address + algorithm_programPage_entry_offset, 0, &armv7m_info);

			buffer  += thisrun_count * 4;
			address += thisrun_count * 4;
			count   -= thisrun_count;
			LOG_INFO("Have written %d%%", (totalCount - count) * 100 / totalCount);

			if (count != 0) {
				thisrun_count = (count > (buffer_size / 4)) ? (buffer_size / 4) : count;

				retval = target_write_buffer(target, source->address, thisrun_count * 4, buffer);
				if (retval != ERROR_OK)
					break;
			}

			retval = target_wait_algorithm(target, 0, NULL, 6, reg_params,
				0, 10000, &armv7m_info);
		}

		// uninit
		algorithm_programPage_entry_offset = 0x99;
		algorithm_lr = 0x20000001;

		buf_set_u32(reg_params[0].value, 0, 32, 0);
		buf_set_u32(reg_params[1].value, 0, 32, 0);
		buf_set_u32(reg_params[2].value, 0, 32, 0);
		buf_set_u32(reg_params[3].value, 0, 32, 0x20000244);
		buf_set_u32(reg_params[4].value, 0, 32, write_algorithm->address + target->working_area_size);
		buf_set_u32(reg_params[5].value, 0, 32, algorithm_lr);

		retval = target_run_algorithm(target, 0, NULL, 6, reg_params,
					write_algorithm->address + algorithm_programPage_entry_offset, 0, 100000, &armv7m_info);
		if (retval != ERROR_OK) {
			LOG_ERROR("Error executing NuMicro Flash uninit algorithm");
			retval = ERROR_FLASH_OPERATION_FAILED;
		}

		target_free_working_area(target, source);
		target_free_working_area(target, source2);
		target_free_working_area(target, write_algorithm);
		destroy_reg_param(&reg_params[0]);
		destroy_reg_param(&reg_params[1]);
		destroy_reg_param(&reg_params[2]);
		destroy_reg_param(&reg_params[3]);
		destroy_reg_param(&reg_params[4]);
		destroy_reg_param(&reg_params[5]);
	}
	else {
		init_reg_param(&reg_params[0], "r0", 32, PARAM_IN_OUT); /* *pLW (*buffer) */
		init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);    /* faddr */
		init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT);    /* number of words to program */
		init_reg_param(&reg_params[3], "sp", 32, PARAM_OUT);    /* update SP */

		/* write code buffer and use Flash programming code within NuMicro */
		/* set breakpoint to 0 with time-out of 10000 ms                  */
		while (count > 0) {
			if (count == totalCount) {
				thisrun_count = (count > (buffer_size / 4)) ? (buffer_size / 4) : count;

				retval = target_write_buffer(target, source->address, thisrun_count * 4, buffer);
				if (retval != ERROR_OK)
					break;
			}

			buf_set_u32(reg_params[0].value, 0, 32, source->address);
			buf_set_u32(reg_params[1].value, 0, 32, address & NUMICRO_TZ_MASK);
			buf_set_u32(reg_params[2].value, 0, 32, thisrun_count);
			buf_set_u32(reg_params[3].value, 0, 32, write_algorithm->address + target->working_area_size);

			retval = target_start_algorithm(target, 0, NULL, 4, reg_params,
				write_algorithm->address + algorithm_programPage_entry_offset, 0, &armv7m_info);

			buffer  += thisrun_count * 4;
			address += thisrun_count * 4;
			count   -= thisrun_count;
			LOG_INFO("Have written %d%%", (totalCount - count) * 100 / totalCount);

			thisrun_count = (count > (buffer_size / 4)) ? (buffer_size / 4) : count;

			if (thisrun_count > 0) {
				retval = target_write_buffer(target, source2->address, thisrun_count * 4, buffer);
				if (retval != ERROR_OK)
					break;
			}

			retval = target_wait_algorithm(target, 0, NULL, 4, reg_params,
				0, 10000, &armv7m_info);

			if (thisrun_count == 0)
				break;

			buf_set_u32(reg_params[0].value, 0, 32, source2->address);
			buf_set_u32(reg_params[1].value, 0, 32, address & NUMICRO_TZ_MASK);
			buf_set_u32(reg_params[2].value, 0, 32, thisrun_count);
			buf_set_u32(reg_params[3].value, 0, 32, write_algorithm->address + target->working_area_size);

			retval = target_start_algorithm(target, 0, NULL, 4, reg_params,
				write_algorithm->address + algorithm_programPage_entry_offset, 0, &armv7m_info);

			buffer  += thisrun_count * 4;
			address += thisrun_count * 4;
			count   -= thisrun_count;
			LOG_INFO("Have written %d%%", (totalCount - count) * 100 / totalCount);

			if (count != 0) {
				thisrun_count = (count > (buffer_size / 4)) ? (buffer_size / 4) : count;

				retval = target_write_buffer(target, source->address, thisrun_count * 4, buffer);
				if (retval != ERROR_OK)
					break;
			}

			retval = target_wait_algorithm(target, 0, NULL, 4, reg_params,
				0, 10000, &armv7m_info);
		}

		target_free_working_area(target, source);
		target_free_working_area(target, source2);
		target_free_working_area(target, write_algorithm);
		destroy_reg_param(&reg_params[0]);
		destroy_reg_param(&reg_params[1]);
		destroy_reg_param(&reg_params[2]);
		destroy_reg_param(&reg_params[3]);
	}

	return retval;
}

static int numicro_M2351_getinitinfo_ns(struct target *target, uint32_t *part_id)
{
	struct working_area *init_algorithm;
	uint32_t address;
	struct reg_param reg_params[2];
	struct armv7m_common *armv7m = target_to_armv7m(target);
	struct armv7m_algorithm armv7m_info;
	int retval = ERROR_OK;
	//int numberOfInfo = 1; /* info: 1. PID */

	/* Params:
	* r0 - address to place info (In fact, the actual location will be the address plus one word)
	*/

	if (m_M23SecureDebugState != NUMICRO_M23_SECURE_DEBUG_NS) {
		LOG_DEBUG("Error executing NuMicro init-info algorithm because it is only used for M23 NS.");
		retval = ERROR_FLASH_OPERATION_FAILED;

		return retval;
	}

	/* allocate working area with init info code */
	if (target_alloc_working_area(target, sizeof(numicro_M2351_NS_init_info_code),
		&init_algorithm) != ERROR_OK) {
		LOG_WARNING("no working area available, can't do block memory erase");
		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
	}

	retval = target_write_buffer(target, init_algorithm->address,
		sizeof(numicro_M2351_NS_init_info_code), numicro_M2351_NS_init_info_code);
	if (retval != ERROR_OK)
		return retval;

	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
	armv7m_info.core_mode = ARM_MODE_THREAD;
	if (armv7m == NULL) {
		/* something is very wrong if armv7m is NULL */
		LOG_ERROR("unable to get armv7m target");
		return retval;
	}

	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);    /* faddr */
	init_reg_param(&reg_params[1], "sp", 32, PARAM_OUT);    /* update SP */

	/* use init info code within NuMicro              */
	/* set breakpoint to 0 with time-out of 100000 ms */
	address = init_algorithm->address + target->working_area_size/* - 4 * (numberOfInfo + 1) */;
	buf_set_u32(reg_params[0].value, 0, 32, address + 4);
	buf_set_u32(reg_params[1].value, 0, 32, address);

	retval = target_run_algorithm(target, 0, NULL, 2, reg_params,
		init_algorithm->address, 0, 100000, &armv7m_info);
	if (retval != ERROR_OK) {
		LOG_ERROR("Error executing NuMicro init info algorithm");
		retval = ERROR_FLASH_OPERATION_FAILED;
	}

	target_free_working_area(target, init_algorithm);
	destroy_reg_param(&reg_params[0]);
	destroy_reg_param(&reg_params[1]);

	/* get the result */
	if (retval == ERROR_OK) {
		retval = target_read_u32(target, address + 8, part_id);
		if (retval != ERROR_OK) {
			LOG_WARNING("NuMicro flash driver: Failed to Get PartID");
			retval = ERROR_FLASH_OPERATION_FAILED;
		}
	}

	return retval;
}

/* Flash Lock checking - examines the lock bit. */
static int numicro_protect_check(struct flash_bank *bank)
{
	struct target *target = bank->target;
	uint32_t set, config[2];
	int i, retval = ERROR_OK;

	if (target->state != TARGET_HALTED) {
		LOG_ERROR("Target not halted");
		return ERROR_TARGET_NOT_HALTED;
	}

	LOG_INFO("Nuvoton NuMicro: Flash Lock Check...");

	numicro_get_arm_arch(target);
	retval = numicro_init_isp(target);
	if (retval != ERROR_OK)
		return retval;

	/* TODO: how about M23 NS? */
	/* Read CONFIG0,CONFIG1 */
	numicro_fmc_cmd(target, ISPCMD_READ, NUMICRO_CONFIG0 - m_addressMinusOffset, 0, &config[0]);
	numicro_fmc_cmd(target, ISPCMD_READ, NUMICRO_CONFIG1 - m_addressMinusOffset, 0, &config[1]);

	LOG_DEBUG("CONFIG0: 0x%" PRIx32 ",CONFIG1: 0x%" PRIx32 "", config[0], config[1]);

	if ((config[0] & (1<<7)) == 0)
		LOG_INFO("CBS=0: Boot From LPROM");
	else
		LOG_INFO("CBS=1: Boot From APROM");

	if ((config[0] & CONFIG0_LOCK_MASK) == 0) {

		LOG_INFO("Flash is secure locked!");
		LOG_INFO("TO UNLOCK FLASH,EXECUTE chip_erase COMMAND!!");
		set = 1;
	}
	else {
		LOG_INFO("Flash is not locked!");
		set = 0;
	}

	for (i = 0; i < bank->num_sectors; i++)
		bank->sectors[i].is_protected = set;

	return ERROR_OK;
}

static int numicro_erase(struct flash_bank *bank, int first, int last)
{
	struct target *target = bank->target;
	struct working_area *erase_algorithm;
	uint32_t address;
	struct reg_param reg_params[6];
	struct armv7m_common *armv7m = target_to_armv7m(target);
	struct armv7m_algorithm armv7m_info;
	uint32_t algorithm_eraseSector_entry_offset = 0;
	uint32_t algorithm_lr = 0;
	int i, retval = ERROR_OK;
	uint32_t timeout, status;
	bool bSPIMFlashWrite = (bank->base + bank->sectors[first].offset < NUMICRO_SPIM_FLASH_START_ADDRESS)? 0 : 1;
	bool bDFMCFlashWrite = (bank->base + bank->sectors[first].offset < NUMICRO_DATA_DFMC_BASE)? 0 : 1;

	if (target->state != TARGET_HALTED) {
		LOG_ERROR("Target not halted");
		return ERROR_TARGET_NOT_HALTED;
	}

	LOG_INFO("Nuvoton NuMicro: Sector Erase ... (%d to %d)", first, last);

	numicro_get_arm_arch(target);
	if (!bSPIMFlashWrite || m_M23SecureDebugState == NUMICRO_M23_SECURE_DEBUG_NS) {
		retval = numicro_init_isp(target);
	}
	if (retval != ERROR_OK)
		return retval;

	if (strcmp(m_target_name, "M480") == 0 && bSPIMFlashWrite) {
		m_bSPIMFlashSectorErased = 1;
		// init
		algorithm_eraseSector_entry_offset = 0x315;
		algorithm_lr = 0x20000001;

		/* allocate working area with flash erase code */
		if (target_alloc_working_area(target, sizeof(numicro_M480_spim_flash_algorithm_code),
			&erase_algorithm) != ERROR_OK) {
			LOG_WARNING("no working area available, can't do block memory erase");
			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
		}

		retval = target_write_buffer(target, erase_algorithm->address,
			sizeof(numicro_M480_spim_flash_algorithm_code), (const uint8_t *)numicro_M480_spim_flash_algorithm_code);
		if (retval != ERROR_OK)
			return retval;

		armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
		armv7m_info.core_mode = ARM_MODE_THREAD;
		if (armv7m == NULL) {
			/* something is very wrong if armv7m is NULL */
			LOG_ERROR("unable to get armv7m target");
			return retval;
		}

		init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
		init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
		init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT);
		init_reg_param(&reg_params[3], "r9", 32, PARAM_OUT);
		init_reg_param(&reg_params[4], "sp", 32, PARAM_OUT);    /* update SP */
		init_reg_param(&reg_params[5], "lr", 32, PARAM_OUT);    /* update LR */

		/* use init info code within NuMicro */
		buf_set_u32(reg_params[0].value, 0, 32, 0);
		buf_set_u32(reg_params[1].value, 0, 32, 0);
		buf_set_u32(reg_params[2].value, 0, 32, 0);
		buf_set_u32(reg_params[3].value, 0, 32, 0x20000EE0);
		buf_set_u32(reg_params[4].value, 0, 32, erase_algorithm->address + target->working_area_size);
		buf_set_u32(reg_params[5].value, 0, 32, algorithm_lr);

		retval = target_run_algorithm(target, 0, NULL, 6, reg_params,
			erase_algorithm->address + algorithm_eraseSector_entry_offset, 0, 100000, &armv7m_info);
		if (retval != ERROR_OK) {
			LOG_ERROR("Error executing NuMicro init algorithm");
			retval = ERROR_FLASH_OPERATION_FAILED;
		}

		destroy_reg_param(&reg_params[0]);
		destroy_reg_param(&reg_params[1]);
		destroy_reg_param(&reg_params[2]);
		destroy_reg_param(&reg_params[3]);
		destroy_reg_param(&reg_params[4]);
		destroy_reg_param(&reg_params[5]);

		// EraseSector
		algorithm_eraseSector_entry_offset = 0x1E9;
		algorithm_lr = 0x20000001;

		init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);    /* faddr */
		init_reg_param(&reg_params[1], "r9", 32, PARAM_OUT);
		init_reg_param(&reg_params[2], "sp", 32, PARAM_OUT);    /* update SP */
		init_reg_param(&reg_params[3], "lr", 32, PARAM_OUT);

		/* use Flash erase code within NuMicro            */
		/* set breakpoint to 0 with time-out of 100000 ms */
		for (i = first; i <= last; i++) {
			if (bank->sectors[i].is_erased == 1) {
				LOG_DEBUG("sector %d has been erased recently. Skip to the next sector.", i);
				continue;
			}

			address = bank->base + bank->sectors[i].offset;
			buf_set_u32(reg_params[0].value, 0, 32, address - NUMICRO_SPIM_FLASH_START_ADDRESS);
			buf_set_u32(reg_params[1].value, 0, 32, 0x20000EE0);
			buf_set_u32(reg_params[2].value, 0, 32, erase_algorithm->address + target->working_area_size);
			buf_set_u32(reg_params[3].value, 0, 32, algorithm_lr);

			retval = target_run_algorithm(target, 0, NULL, 4, reg_params,
				erase_algorithm->address + algorithm_eraseSector_entry_offset, 0, 100000, &armv7m_info);
			if (retval != ERROR_OK) {
				LOG_ERROR("Error executing NuMicro Flash erase algorithm");
				retval = ERROR_FLASH_OPERATION_FAILED;
				break;
			}
			else {
				bank->sectors[i].is_erased = 1;
			}
		}

		destroy_reg_param(&reg_params[0]);
		destroy_reg_param(&reg_params[1]);
		destroy_reg_param(&reg_params[2]);
		destroy_reg_param(&reg_params[3]);

		// uninit
		algorithm_eraseSector_entry_offset = 0xC75;
		algorithm_lr = 0x20000001;

		init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
		init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
		init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT);
		init_reg_param(&reg_params[3], "r9", 32, PARAM_OUT);
		init_reg_param(&reg_params[4], "sp", 32, PARAM_OUT);    /* update SP */
		init_reg_param(&reg_params[5], "lr", 32, PARAM_OUT);    /* update LR */

		buf_set_u32(reg_params[0].value, 0, 32, 0);
		buf_set_u32(reg_params[1].value, 0, 32, 0);
		buf_set_u32(reg_params[2].value, 0, 32, 0);
		buf_set_u32(reg_params[3].value, 0, 32, 0x20000EE0);
		buf_set_u32(reg_params[4].value, 0, 32, erase_algorithm->address + target->working_area_size);
		buf_set_u32(reg_params[5].value, 0, 32, algorithm_lr);

		retval = target_run_algorithm(target, 0, NULL, 6, reg_params,
					erase_algorithm->address + algorithm_eraseSector_entry_offset, 0, 100000, &armv7m_info);
		if (retval != ERROR_OK) {
			LOG_ERROR("Error executing NuMicro Flash uninit algorithm");
			retval = ERROR_FLASH_OPERATION_FAILED;
		}

		target_free_working_area(target, erase_algorithm);
		destroy_reg_param(&reg_params[0]);
		destroy_reg_param(&reg_params[1]);
		destroy_reg_param(&reg_params[2]);
		destroy_reg_param(&reg_params[3]);
		destroy_reg_param(&reg_params[4]);
		destroy_reg_param(&reg_params[5]);
	}
	else if (strcmp(m_target_name, "NUC505") == 0) {
		algorithm_eraseSector_entry_offset = 0x283;
		algorithm_lr = 0x20000001;

		/* allocate working area with flash erase code */
		if (target_alloc_working_area(target, sizeof(numicro_NUC505_flash_algorithm_code),
			&erase_algorithm) != ERROR_OK) {
			LOG_WARNING("no working area available, can't do block memory erase");
			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
		}

		retval = target_write_buffer(target, erase_algorithm->address,
			sizeof(numicro_NUC505_flash_algorithm_code), (const uint8_t *)numicro_NUC505_flash_algorithm_code);
		if (retval != ERROR_OK)
			return retval;

		armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
		armv7m_info.core_mode = ARM_MODE_THREAD;
		if (armv7m == NULL) {
			/* something is very wrong if armv7m is NULL */
			LOG_ERROR("unable to get armv7m target");
			return retval;
		}

		init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);    /* faddr */
		init_reg_param(&reg_params[1], "r9", 32, PARAM_OUT);
		init_reg_param(&reg_params[2], "sp", 32, PARAM_OUT);    /* update SP */
		init_reg_param(&reg_params[3], "lr", 32, PARAM_OUT);

		/* use Flash erase code within NuMicro            */
		/* set breakpoint to 0 with time-out of 100000 ms */
		for (i = first; i <= last; i++) {
			if (bank->sectors[i].is_erased == 1) {
				LOG_DEBUG("sector %d has been erased recently. Skip to the next sector.", i);
				continue;
			}

			address = (bank->base + bank->sectors[i].offset) /* & NUMICRO_TZ_MASK */;
			buf_set_u32(reg_params[0].value, 0, 32, address);
			buf_set_u32(reg_params[1].value, 0, 32, 0x2000032C);
			buf_set_u32(reg_params[2].value, 0, 32, erase_algorithm->address + 126 * 1024);
			buf_set_u32(reg_params[3].value, 0, 32, algorithm_lr);

			retval = target_run_algorithm(target, 0, NULL, 4, reg_params,
				erase_algorithm->address + algorithm_eraseSector_entry_offset, 0, 100000, &armv7m_info);
			if (retval != ERROR_OK) {
				LOG_ERROR("Error executing NuMicro Flash erase algorithm");
				retval = ERROR_FLASH_OPERATION_FAILED;
				break;
			}
			else {
				bank->sectors[i].is_erased = 1;
			}
		}

		// uninit
		algorithm_eraseSector_entry_offset = 0x261;
		algorithm_lr = 0x20000001;

		buf_set_u32(reg_params[0].value, 0, 32, 0);
		buf_set_u32(reg_params[1].value, 0, 32, 0x2000032C);
		buf_set_u32(reg_params[2].value, 0, 32, erase_algorithm->address + 126 * 1024);
		buf_set_u32(reg_params[3].value, 0, 32, algorithm_lr);

		retval = target_run_algorithm(target, 0, NULL, 4, reg_params,
					erase_algorithm->address + algorithm_eraseSector_entry_offset, 0, 100000, &armv7m_info);
		if (retval != ERROR_OK) {
			LOG_ERROR("Error executing NuMicro Flash programming algorithm");
			retval = ERROR_FLASH_OPERATION_FAILED;
		}

		target_free_working_area(target, erase_algorithm);
		destroy_reg_param(&reg_params[0]);
		destroy_reg_param(&reg_params[1]);
		destroy_reg_param(&reg_params[2]);
		destroy_reg_param(&reg_params[3]);
	}
	else if (m_M23SecureDebugState != NUMICRO_M23_SECURE_DEBUG_NS) {
		if (strcmp(m_target_name, "M471") == 0 && bDFMCFlashWrite) {	// M471 data flash DFMC erase
			// init
			algorithm_eraseSector_entry_offset = 0x5;
			algorithm_lr = 0x20000001;

			/* allocate working area with flash erase code */
			if (target_alloc_working_area(target, sizeof(numicro_M471_dataflash_flash_algorithm_code),
				&erase_algorithm) != ERROR_OK) {
				LOG_WARNING("no working area available, can't do block memory erase");
				return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
			}

			retval = target_write_buffer(target, erase_algorithm->address,
				sizeof(numicro_M471_dataflash_flash_algorithm_code), (const uint8_t *)numicro_M471_dataflash_flash_algorithm_code);
			if (retval != ERROR_OK)
				return retval;

			armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
			armv7m_info.core_mode = ARM_MODE_THREAD;
			if (armv7m == NULL) {
				/* something is very wrong if armv7m is NULL */
				LOG_ERROR("unable to get armv7m target");
				return retval;
			}

			init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
			init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
			init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT);
			init_reg_param(&reg_params[3], "r9", 32, PARAM_OUT);
			init_reg_param(&reg_params[4], "sp", 32, PARAM_OUT);    /* update SP */
			init_reg_param(&reg_params[5], "lr", 32, PARAM_OUT);    /* update LR */

			/* use init info code within NuMicro */
			buf_set_u32(reg_params[0].value, 0, 32, 0);
			buf_set_u32(reg_params[1].value, 0, 32, 0);
			buf_set_u32(reg_params[2].value, 0, 32, 0);
			buf_set_u32(reg_params[3].value, 0, 32, 0x20000244);
			buf_set_u32(reg_params[4].value, 0, 32, erase_algorithm->address + target->working_area_size);
			buf_set_u32(reg_params[5].value, 0, 32, algorithm_lr);

			retval = target_run_algorithm(target, 0, NULL, 6, reg_params,
				erase_algorithm->address + algorithm_eraseSector_entry_offset, 0, 100000, &armv7m_info);
			if (retval != ERROR_OK) {
				LOG_ERROR("Error executing NuMicro init algorithm");
				retval = ERROR_FLASH_OPERATION_FAILED;
			}

			destroy_reg_param(&reg_params[0]);
			destroy_reg_param(&reg_params[1]);
			destroy_reg_param(&reg_params[2]);
			destroy_reg_param(&reg_params[3]);
			destroy_reg_param(&reg_params[4]);
			destroy_reg_param(&reg_params[5]);

			algorithm_eraseSector_entry_offset = 0x105;
			algorithm_lr = 0x20000001;

			/* allocate working area with flash erase code */
			if (target_alloc_working_area(target, sizeof(numicro_M471_dataflash_flash_algorithm_code),
				&erase_algorithm) != ERROR_OK) {
				LOG_WARNING("no working area available, can't do block memory erase");
				return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
			}

			retval = target_write_buffer(target, erase_algorithm->address,
				sizeof(numicro_M471_dataflash_flash_algorithm_code), (const uint8_t *)numicro_M471_dataflash_flash_algorithm_code);
			if (retval != ERROR_OK)
				return retval;

			armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
			armv7m_info.core_mode = ARM_MODE_THREAD;
			if (armv7m == NULL) {
				/* something is very wrong if armv7m is NULL */
				LOG_ERROR("unable to get armv7m target");
				return retval;
			}

			init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);    /* faddr */
			init_reg_param(&reg_params[1], "r9", 32, PARAM_OUT);
			init_reg_param(&reg_params[2], "sp", 32, PARAM_OUT);    /* update SP */
			init_reg_param(&reg_params[3], "lr", 32, PARAM_OUT);

			/* use Flash erase code within NuMicro            */
			/* set breakpoint to 0 with time-out of 100000 ms */
			for (i = first; i <= last; i++) {
				if (bank->sectors[i].is_erased == 1) {
					LOG_DEBUG("sector %d has been erased recently. Skip to the next sector.", i);
					continue;
				}

				LOG_DEBUG("address: 0x%x, bank->base: 0x%x, bank->sectors[i].offset: 0x%x,  %d", address, bank->base, bank->sectors[i].offset, i);
				address = (bank->base + bank->sectors[i].offset);
				buf_set_u32(reg_params[0].value, 0, 32, address);
				buf_set_u32(reg_params[1].value, 0, 32, 0x20000244);
				buf_set_u32(reg_params[2].value, 0, 32, erase_algorithm->address + target->working_area_size);
				buf_set_u32(reg_params[3].value, 0, 32, algorithm_lr);

				retval = target_run_algorithm(target, 0, NULL, 4, reg_params,
					erase_algorithm->address + algorithm_eraseSector_entry_offset, 0, 100000, &armv7m_info);

				if (retval != ERROR_OK) {
					LOG_ERROR("Error executing NuMicro Flash erase algorithm");
					retval = ERROR_FLASH_OPERATION_FAILED;
					break;
				}
				else {
					bank->sectors[i].is_erased = 1;
				}
			}

			// uninit
			algorithm_eraseSector_entry_offset = 0x99;
			algorithm_lr = 0x20000001;

			buf_set_u32(reg_params[0].value, 0, 32, 0);
			buf_set_u32(reg_params[1].value, 0, 32, 0x20000244);
			buf_set_u32(reg_params[2].value, 0, 32, erase_algorithm->address + target->working_area_size);
			buf_set_u32(reg_params[3].value, 0, 32, algorithm_lr);

			retval = target_run_algorithm(target, 0, NULL, 4, reg_params,
						erase_algorithm->address + algorithm_eraseSector_entry_offset, 0, 100000, &armv7m_info);
			if (retval != ERROR_OK) {
				LOG_ERROR("Error executing NuMicro Flash programming algorithm");
				retval = ERROR_FLASH_OPERATION_FAILED;
			}

			target_free_working_area(target, erase_algorithm);
			destroy_reg_param(&reg_params[0]);
			destroy_reg_param(&reg_params[1]);
			destroy_reg_param(&reg_params[2]);
			destroy_reg_param(&reg_params[3]);
		}
		else {
		retval = target_write_u32(target, NUMICRO_FLASH_ISPCMD - m_addressMinusOffset, ISPCMD_ERASE);
		if (retval != ERROR_OK)
			return retval;

		for (i = first; i <= last; i++) {
			if (bank->sectors[i].is_erased == 1) {
				LOG_DEBUG("sector %d has been erased recently. Skip to the next sector.", i);
				continue;
			}

			address = bank->base + bank->sectors[i].offset;
			LOG_DEBUG("erasing sector %d at address 0x%" PRIx32 "", i, address);
			if ((m_flashInfo & NUMICRO_SPROM_MASK) != 0 &&
				(address >= NUMICRO_SPROM_BASE) && (address < (NUMICRO_SPROM_BASE + m_pageSize))) {
				LOG_DEBUG("SPROM is erasing");
				retval = target_write_u32(target, NUMICRO_FLASH_ISPDAT - m_addressMinusOffset, NUMICRO_SPROM_ISPDAT);
				if (retval != ERROR_OK)
					return retval;

				retval = target_write_u32(target, NUMICRO_FLASH_ISPADR - m_addressMinusOffset, NUMICRO_SPROM_BASE);
				if (retval != ERROR_OK)
					return retval;
			}
			else if ((m_flashInfo & NUMICRO_SPROM_MINI57_MASK) != 0 &&
				(address >= NUMICRO_SPROM_BASE) && (address < (NUMICRO_SPROM_BASE + m_pageSize))) {
				LOG_DEBUG("SPROM is erasing");
				retval = target_write_u32(target, NUMICRO_FLASH_ISPDAT - m_addressMinusOffset, NUMICRO_SPROM_ISPDAT);
				if (retval != ERROR_OK)
					return retval;

				retval = target_write_u32(target, NUMICRO_FLASH_ISPADR - m_addressMinusOffset, NUMICRO_SPROM_BASE);
				if (retval != ERROR_OK)
					return retval;
			}
			else if ((m_flashInfo & NUMICRO_SPROM_MINI57_MASK) != 0 &&
				(address >= NUMICRO_SPROM_BASE2) && (address < (NUMICRO_SPROM_BASE2 + m_pageSize))) {
				LOG_DEBUG("SPROM is erasing");
				retval = target_write_u32(target, NUMICRO_FLASH_ISPDAT - m_addressMinusOffset, NUMICRO_SPROM_ISPDAT);
				if (retval != ERROR_OK)
					return retval;

				retval = target_write_u32(target, NUMICRO_FLASH_ISPADR - m_addressMinusOffset, NUMICRO_SPROM_BASE2);
				if (retval != ERROR_OK)
					return retval;
			}
			else if ((m_flashInfo & NUMICRO_SPROM_MINI57_MASK) != 0 &&
				(address >= NUMICRO_SPROM_BASE3) && (address < (NUMICRO_SPROM_BASE3 + m_pageSize))) {
				LOG_DEBUG("SPROM is erasing");
				retval = target_write_u32(target, NUMICRO_FLASH_ISPDAT - m_addressMinusOffset, NUMICRO_SPROM_ISPDAT);
				if (retval != ERROR_OK)
					return retval;

				retval = target_write_u32(target, NUMICRO_FLASH_ISPADR - m_addressMinusOffset, NUMICRO_SPROM_BASE3);
				if (retval != ERROR_OK)
					return retval;
			}
			else {
				retval = target_write_u32(target, NUMICRO_FLASH_ISPADR - m_addressMinusOffset, address & NUMICRO_TZ_MASK);
				if (retval != ERROR_OK)
					return retval;
			}

			retval = target_write_u32(target, NUMICRO_FLASH_ISPTRG - m_addressMinusOffset, ISPTRG_ISPGO); /* This is the only bit available */
			if (retval != ERROR_OK)
				return retval;

			/* wait for busy to clear - check the GO flag */
			timeout = 100;
			for (;;) {
				retval = target_read_u32(target, NUMICRO_FLASH_ISPTRG - m_addressMinusOffset, &status);
				if (retval != ERROR_OK)
					return retval;
				LOG_DEBUG("status: 0x%" PRIx32 "", status);
				if (status == 0)
					break;
				if (timeout-- <= 0) {
					LOG_DEBUG("timed out waiting for flash");
					return ERROR_FAIL;
				}
				busy_sleep(1);	/* can use busy sleep for short times. */
			}

			/* check for failure */
			retval = target_read_u32(target, NUMICRO_FLASH_ISPCON - m_addressMinusOffset, &status);
			if (retval != ERROR_OK)
				return retval;
			if ((status & ISPCON_ISPFF) != 0) {
				LOG_DEBUG("failure: 0x%" PRIx32 "", status);
				/* if bit is set, then must write to it to clear it. */
				retval = target_write_u32(target, NUMICRO_FLASH_ISPCON - m_addressMinusOffset, (status | ISPCON_ISPFF));
				if (retval != ERROR_OK)
					return retval;
			}
			else {
				bank->sectors[i].is_erased = 1;
			}
		}
	}
	}
	else { // m_M23SecureDebugState == NUMICRO_M23_SECURE_DEBUG_NS
		if (strcmp(m_target_name, "M2354") == 0) {
			algorithm_eraseSector_entry_offset = 0x151;
			algorithm_lr = 0x30010001;

			/* allocate working area with flash erase code */
			if (target_alloc_working_area(target, sizeof(numicro_M2354_NS_flash_algorithm_code),
				&erase_algorithm) != ERROR_OK) {
				LOG_WARNING("no working area available, can't do block memory erase");
				return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
			}

			retval = target_write_buffer(target, erase_algorithm->address,
				sizeof(numicro_M2354_NS_flash_algorithm_code), (const uint8_t *)numicro_M2354_NS_flash_algorithm_code);
			if (retval != ERROR_OK)
				return retval;

			armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
			armv7m_info.core_mode = ARM_MODE_THREAD;
			if (armv7m == NULL) {
				/* something is very wrong if armv7m is NULL */
				LOG_ERROR("unable to get armv7m target");
				return retval;
			}

			init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);    /* faddr */
			init_reg_param(&reg_params[1], "sp", 32, PARAM_OUT);    /* update SP */
			init_reg_param(&reg_params[2], "lr", 32, PARAM_OUT);

			/* use Flash erase code within NuMicro            */
			/* set breakpoint to 0 with time-out of 100000 ms */
			for (i = first; i <= last; i++) {
				if (bank->sectors[i].is_erased == 1) {
					LOG_DEBUG("sector %d has been erased recently. Skip to the next sector.", i);
					continue;
				}

				address = (bank->base + bank->sectors[i].offset) /* & NUMICRO_TZ_MASK */;
				buf_set_u32(reg_params[0].value, 0, 32, address);
				buf_set_u32(reg_params[1].value, 0, 32, erase_algorithm->address + target->working_area_size);
				buf_set_u32(reg_params[2].value, 0, 32, algorithm_lr);

				retval = target_run_algorithm(target, 0, NULL, 3, reg_params,
					erase_algorithm->address + algorithm_eraseSector_entry_offset, 0, 100000, &armv7m_info);
				if (retval != ERROR_OK) {
					LOG_ERROR("Error executing NuMicro Flash erase algorithm");
					retval = ERROR_FLASH_OPERATION_FAILED;
					break;
				}
				else {
					bank->sectors[i].is_erased = 1;
				}
			}

			target_free_working_area(target, erase_algorithm);
			destroy_reg_param(&reg_params[0]);
			destroy_reg_param(&reg_params[1]);
			destroy_reg_param(&reg_params[2]);
		}
		else {
			/* allocate working area with flash erase code */
			if (target_alloc_working_area(target, sizeof(numicro_M2351_NS_flash_erase_code),
				&erase_algorithm) != ERROR_OK) {
				LOG_WARNING("no working area available, can't do block memory erase");
				return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
			}

			retval = target_write_buffer(target, erase_algorithm->address,
				sizeof(numicro_M2351_NS_flash_erase_code), numicro_M2351_NS_flash_erase_code);
			if (retval != ERROR_OK)
				return retval;

			armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
			armv7m_info.core_mode = ARM_MODE_THREAD;
			if (armv7m == NULL) {
				/* something is very wrong if armv7m is NULL */
				LOG_ERROR("unable to get armv7m target");
				return retval;
			}

			init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);    /* faddr */
			init_reg_param(&reg_params[1], "sp", 32, PARAM_OUT);    /* update SP */

			/* use Flash erase code within NuMicro            */
			/* set breakpoint to 0 with time-out of 100000 ms */
			for (i = first; i <= last; i++) {
				if (bank->sectors[i].is_erased == 1) {
					LOG_DEBUG("sector %d has been erased recently. Skip to the next sector.", i);
					continue;
				}

				address = (bank->base + bank->sectors[i].offset) /* & NUMICRO_TZ_MASK */;
				buf_set_u32(reg_params[0].value, 0, 32, address);
				buf_set_u32(reg_params[1].value, 0, 32, erase_algorithm->address + target->working_area_size);

				retval = target_run_algorithm(target, 0, NULL, 2, reg_params,
					erase_algorithm->address, 0, 100000, &armv7m_info);
				if (retval != ERROR_OK) {
					LOG_ERROR("Error executing NuMicro Flash erase algorithm");
					retval = ERROR_FLASH_OPERATION_FAILED;
					break;
				}
				else {
					bank->sectors[i].is_erased = 1;
				}
			}

			target_free_working_area(target, erase_algorithm);
			destroy_reg_param(&reg_params[0]);
			destroy_reg_param(&reg_params[1]);
		}
	}

	/* done */
	LOG_DEBUG("Erase done.");

	return ERROR_OK;
}

/* The write routine stub. */
static int numicro_write(struct flash_bank *bank, const uint8_t *buffer,
		uint32_t offset, uint32_t count)
{
	struct target *target = bank->target;
	uint32_t timeout, status, rdat;
	uint8_t *new_buffer = NULL;
	int retval = ERROR_OK;

	if (target->state != TARGET_HALTED) {
		LOG_ERROR("Target not halted");
		return ERROR_TARGET_NOT_HALTED;
	}

	LOG_INFO("Nuvoton NuMicro: Flash Write ...");

	numicro_get_arm_arch(target);
	if ((bank->base + offset < NUMICRO_SPIM_FLASH_START_ADDRESS) ||
		m_M23SecureDebugState == NUMICRO_M23_SECURE_DEBUG_NS) {
		retval = numicro_init_isp(target);
	}
	if (retval != ERROR_OK)
		return retval;

	if (m_M23SecureDebugState != NUMICRO_M23_SECURE_DEBUG_NS) {
		retval = target_write_u32(target, NUMICRO_FLASH_ISPCMD - m_addressMinusOffset, ISPCMD_WRITE);
		if (retval != ERROR_OK)
			return retval;
	}

	if (count & 0x3) {
		uint32_t old_count = count;
		count = (old_count | 3) + 1;
		new_buffer = malloc(count);
		if (new_buffer == NULL) {
			LOG_ERROR("odd number of bytes to write and no memory "
				"for padding buffer");
			return ERROR_FAIL;
		}
		LOG_INFO("odd number of bytes to write (%d), extending to %d "
			"and padding with 0xff", old_count, count);
		memset(new_buffer, 0xff, count);
		buffer = memcpy(new_buffer, buffer, old_count);
	}

	uint32_t words_remaining = count / 4;

	/* try using a block write */
	retval = numicro_writeblock(bank, buffer, offset, words_remaining);

	if ((retval == ERROR_TARGET_RESOURCE_NOT_AVAILABLE) && (m_M23SecureDebugState != NUMICRO_M23_SECURE_DEBUG_NS)) {
		/* if block write failed (no sufficient working area),
		 * we use normal (slow) single word accesses */
		LOG_WARNING("couldn't use block writes, falling back to single "
			"memory accesses");

		/* program command */
		for (uint32_t i = 0; i < count; i += 4) {

			LOG_DEBUG("write longword @ %08X", offset + i);

			uint8_t padding[4] = {0xff, 0xff, 0xff, 0xff};
			memcpy(padding, buffer + i, MIN(4, count-i));

			retval = target_write_u32(target, NUMICRO_FLASH_ISPADR - m_addressMinusOffset, (bank->base + offset + i) & NUMICRO_TZ_MASK);
			if (retval != ERROR_OK)
				return retval;
			retval = target_write_memory(target, NUMICRO_FLASH_ISPDAT - m_addressMinusOffset, 4, 1, padding);
			if (retval != ERROR_OK)
				return retval;
			retval = target_write_u32(target, NUMICRO_FLASH_ISPTRG - m_addressMinusOffset, ISPTRG_ISPGO);
			if (retval != ERROR_OK)
				return retval;

			/* wait for busy to clear - check the GO flag */
			timeout = 100;
			for (;;) {
				retval = target_read_u32(target, NUMICRO_FLASH_ISPTRG - m_addressMinusOffset, &status);
				if (retval != ERROR_OK)
					return retval;
					LOG_DEBUG("status: 0x%" PRIx32 "", status);
				if (status == 0)
					break;
				if (timeout-- <= 0) {
					LOG_DEBUG("timed out waiting for flash");
					return ERROR_FAIL;
				}
				busy_sleep(1);	/* can use busy sleep for short times. */
			}
		}

		/* check for failure */
		retval = target_read_u32(target, NUMICRO_FLASH_ISPCON - m_addressMinusOffset, &status);
		if (retval != ERROR_OK)
			return retval;
		if ((status & ISPCON_ISPFF) != 0) {
			LOG_DEBUG("failure: 0x%" PRIx32 "", status);
			/* if bit is set, then must write to it to clear it. */
			retval = target_write_u32(target, NUMICRO_FLASH_ISPCON - m_addressMinusOffset, (status | ISPCON_ISPFF));
			if (retval != ERROR_OK)
				return retval;
		}
		else {
			LOG_DEBUG("Write OK");
		}
	}

	/* done. */
	LOG_DEBUG("Write done.");

	/* check VectorRemap */
	if (m_M23SecureDebugState == NUMICRO_M23_SECURE_DEBUG_S) {
		// M2351/M2354
		retval = target_read_u32(target, NUMICRO_M23_FMC_ISPSTS, &status);
		if (retval != ERROR_OK)
			return retval;
		if (bank->base + offset < NUMICRO_LDROM_BASE) {
			// APROM
			if ((status & NUMICRO_M23_FMC_ISPSTS_VECMAP) != NUMICRO_APROM_BASE)
			{
				LOG_DEBUG("VectorRemap to APROM");
				retval = numicro_fmc_cmd(target, ISPCMD_VECMAP, NUMICRO_APROM_BASE, 0, &rdat);
				if (retval != ERROR_OK) {
					LOG_DEBUG("VectorRemap to APROM failed");
					return retval;
				}
			}
		}
		else {
			// LDROM
			if ((status & NUMICRO_M23_FMC_ISPSTS_VECMAP) != NUMICRO_LDROM_BASE)
			{
				LOG_DEBUG("VectorRemap to LDROM");
				retval = numicro_fmc_cmd(target, ISPCMD_VECMAP, NUMICRO_LDROM_BASE, 0, &rdat);
				if (retval != ERROR_OK) {
					LOG_DEBUG("VectorRemap to LDROM failed");
					return retval;
				}
			}
		}
	}

	return ERROR_OK;
}

static int numicro_get_cpu_type(struct target *target, const struct numicro_cpu_type** cpu)
{
	uint32_t part_id = 0xABCDEF12;
	int retval = ERROR_OK;

	numicro_get_arm_arch(target);

	/* Read NuMicro PartID */
	if (m_M23SecureDebugState != NUMICRO_M23_SECURE_DEBUG_NS) {
		retval = target_read_u32(target, NUMICRO_SYS_BASE - m_addressMinusOffset, &part_id);
		if (retval != ERROR_OK) {
			LOG_WARNING("NuMicro flash driver: Failed to Get PartID");
			return ERROR_FLASH_OPERATION_FAILED;
		}
	}
	else {
		retval = target_read_u32(target, NUMICRO_SYS_BASE, &part_id);
		if (retval != ERROR_OK) {
			LOG_WARNING("NuMicro flash driver: Failed to Get PartID");
			return ERROR_FLASH_OPERATION_FAILED;
		}
	}

	LOG_INFO("Device ID: 0x%08" PRIx32 "", part_id);
	/* search part numbers */
	for (size_t i = 0; i < sizeof(NuMicroParts) / sizeof(NuMicroParts[0]); i++) {
		if (part_id == NuMicroParts[i].partid) {
			*cpu = &NuMicroParts[i];
			LOG_INFO("Device Name: %s", (*cpu)->partname);
			return ERROR_OK;
		}
	}

	/* try again for M23 series */
	if (m_M23SecureDebugState == NUMICRO_M23_SECURE_DEBUG_NS) {
		if (strcmp(m_target_name, "M2351") == 0) {
			numicro_M2351_getinitinfo_ns(target, &part_id);
		}
		else {
			retval = target_read_u32(target, NUMICRO_SYS_BASE, &part_id);
			if (retval != ERROR_OK) {
				LOG_WARNING("NuMicro flash driver: Failed to Get PartID");
				return ERROR_FLASH_OPERATION_FAILED;
			}
		}

		LOG_INFO("Device ID: 0x%08" PRIx32 "", part_id);
		/* search part numbers */
		for (size_t i = 0; i < sizeof(NuMicroParts) / sizeof(NuMicroParts[0]); i++) {
			if (part_id == NuMicroParts[i].partid) {
				*cpu = &NuMicroParts[i];
				LOG_INFO("Device Name: %s", (*cpu)->partname);
				return ERROR_OK;
			}
		}
	}
	LOG_WARNING("NuMicro flash driver: Failed to search PartID. Use 'UNKNOWN' instead.");
	*cpu = &NuMicroParts[sizeof(NuMicroParts) / sizeof(NuMicroParts[0]) - 1];
	LOG_INFO("Device Name: %s", (*cpu)->partname);

	return ERROR_FAIL;
}

static int numicro_get_flash_size(struct flash_bank *bank, const struct numicro_cpu_type *cpu, uint32_t *flash_size)
{
	for (size_t i = 0; i < cpu->n_banks; i++) {
		if (bank->base == cpu->bank[i].base) {
			*flash_size = cpu->bank[i].size;
			LOG_INFO("bank base = 0x%08" PRIx32 ", size = 0x%08" PRIx32 "", bank->base, *flash_size);
			return ERROR_OK;
		}
	}
	return ERROR_FLASH_OPERATION_FAILED;
}

static int numicro_probe(struct flash_bank *bank)
{
	uint32_t flash_size = 0, offset = 0, page_size;
	int num_pages;
	const struct numicro_cpu_type *cpu;
	struct target *target = bank->target;
	struct armv7m_common *armv7m = target_to_armv7m(target);
	int retval = ERROR_OK;

	retval = numicro_get_cpu_type(target, &cpu);
	if (retval != ERROR_OK) {
		LOG_WARNING("NuMicro flash driver: Failed to detect a known part");
		/* return ERROR_FLASH_OPERATION_FAILED; */
	}

	retval = numicro_get_flash_size(bank, cpu, &flash_size);
	if (retval != ERROR_OK) {
		LOG_WARNING("NuMicro flash driver: Failed to detect flash size");
		/* return ERROR_FLASH_OPERATION_FAILED; */
	}

	/* decide the page size */
	if (armv7m->arm.is_armv6m) { /* M0 */
		if ((cpu->partid == 0x00295C50/* NUC029LGE */) ||
			(cpu->partid == 0x00295C51/* NUC029SGE */) ||
			(cpu->partid == 0x00295C52/* NUC029KGE */) ||
			(cpu->partid == 0x01607171/* M071QE4AE */) ||
			(cpu->partid == 0x01607170/* M071QG4AE */) ||
			(cpu->partid == 0x01607130/* M071VG4AE */) ||
			((cpu->partid & 0xFFFFF000) == 0x00C56000/* M0564  */) ||
			((cpu->partid & 0xFFFFF000) == 0x00C05000/* NUC126 */) ||
			((cpu->partid & 0xFFFFFF00) == 0x01205200/* NUC1261*/) ||
			((cpu->partid & 0xFFFFFFF0) == 0x01131600/* M031G  */) ||
			((cpu->partid & 0xFFFFFFF0) == 0x01131610/* M031G  */) ||
			((cpu->partid & 0xFFFFFFF0) == 0x01131640/* M031G  */) ||
			((cpu->partid & 0xFFFFFF00) == 0x01132600/* M031G  */) ||
			((cpu->partid & 0xFFFFFF00) == 0x01131100/* M031I  */) ||
			((cpu->partid & 0xFFFFFF00) == 0x01132100/* M031I  */)) {
			m_pageSize = NUMICRO_PAGESIZE * 4;
		}
		else {
			m_pageSize = NUMICRO_PAGESIZE;
		}
	}
	else if (armv7m->arm.is_armv8m) { /* M23 */
		if ((cpu->partid & 0xFFFFFF00) == 0x01812600/* NUC1262 */ ||
			 armv7m->arm.is_armv8mSecureExtend) {
			m_pageSize = NUMICRO_PAGESIZE * 4; /* for M261, M2351 and M2354 */
		}
		else {
			m_pageSize = NUMICRO_PAGESIZE;     /* for M251 */
		}
	}
	else { /* armv7m (M4) */
		if (((cpu->partid & 0xFFFFFF00) == 0x01347900/* M479   */) ||
			((cpu->partid & 0xFFFFF000) == 0x00D48000/* M480   */) ||
			((cpu->partid & 0xFFFFF000) == 0x01348000/* M480LD */)) {
			m_pageSize = NUMICRO_PAGESIZE * 8;
		}
		else if (cpu->partid == 0x00550505) {
			m_pageSize = 0x1000; /* for NUC505 */
		}
		else {
			m_pageSize = NUMICRO_PAGESIZE * 4;
		}
	}
	LOG_DEBUG("Nuvoton pageSize: 0x%" PRIx32 "", m_pageSize);

	/* decide the flash information */
	if ((cpu->partid == 0x00295C50/* NUC029LGE */) ||
		(cpu->partid == 0x00295C51/* NUC029SGE */) ||
		(cpu->partid == 0x00295C52/* NUC029KGE */) ||
		(cpu->partid == 0x01607171/* M071QE4AE */) ||
		(cpu->partid == 0x01607170/* M071QG4AE */) ||
		(cpu->partid == 0x01607130/* M071VG4AE */) ||
		((cpu->partid & 0xFFFF0000) == 0x01130000/* M03X   */) ||
		((cpu->partid & 0xFFFFFF00) == 0x00C56400/* M0564  */) ||
		((cpu->partid & 0xFFFFFF00) == 0x01256400/* M05641 */) ||
		((cpu->partid & 0xFFFFF000) == 0x00D48000/* M480   */) ||
		((cpu->partid & 0xFFFFFF00) == 0x00012100/* NUC121  */) ||
		((cpu->partid & 0xFFFFFF00) == 0x00012500/* NUC125  */) ||
		((cpu->partid & 0xFFFFFF00) == 0x00C05200/* NUC126  */) ||
		((cpu->partid & 0xFFFFFF00) == 0x01205200/* NUC1261 */) ||
		((cpu->partid & 0xFFFFFF00) == 0x01812600/* NUC1262 */) ||
		((cpu->partid & 0xFFFFFF00) == 0x00110200/* Nano102 */) ||
		((cpu->partid & 0xFFFFFF00) == 0x00111200/* Nano112 */) ||
		((cpu->partid & 0xFFFFFF00) == 0x00A05800/* Mini58  */)) {
		m_flashInfo = NUMICRO_SPROM_MASK;
	}
	else if ((cpu->partid & 0xFFFFFF00) == 0x00B05700/* Mini57 */) {
		m_flashInfo = NUMICRO_SPROM_MINI57_MASK;
	}
	else {
		m_flashInfo = 0;
	}

	/* decide the target name */
	if (((cpu->partid & 0xFFFFFF00) == 0x01347900/* M479   */) ||
		((cpu->partid & 0xFFFFF000) == 0x00D48000/* M480   */) ||
		((cpu->partid & 0xFFFFF000) == 0x01348000/* M480LD */)) {
		m_target_name = "M480";
	}
	else if (((cpu->partid & 0xFFFFFFF0) == 0x01647140) ||
		((cpu->partid & 0xFFFFFFF0) == 0x01647130) ||
		((cpu->partid & 0xFFFFFFF0) == 0x01647170)) {
		m_target_name = "M471";
	}
	else if (cpu->partid == 0x00550505) {
		m_target_name = "NUC505";
	}
	else if ((cpu->partid & 0xFFFFFF00) == 0x01812600/* NUC1262 */) {
		m_target_name = "NUC1262";
	}
	else if (((cpu->partid & 0xFFFFFF00) == 0x00235100) ||
			 ((cpu->partid & 0xFFFFFF00) == 0x00235300)) {
		m_target_name = "M2351";
	}
	else if (((cpu->partid & 0xFFFFFF00) == 0x00235500) ||
			 ((cpu->partid & 0xFFFFFF00) == 0x00235400) ||
			 ((cpu->partid & 0xFFFFFF00) == 0xA1735400)) {
		m_target_name = "M2354";
	}
	else {
		m_target_name = "common";
	}
	LOG_DEBUG("target name: %s", m_target_name);

	if (bank->base >= NUMICRO_DATA_DFMC_BASE) {
		page_size =  NUMICRO_DFMC_PAGESIZE;
	}
	else {
		page_size = m_pageSize;
	}

	num_pages = flash_size / page_size;
	bank->num_sectors = num_pages;
	bank->sectors = malloc(sizeof(struct flash_sector) * num_pages);
	bank->size = flash_size;

	for (int i = 0; i < num_pages; i++) {
		bank->sectors[i].offset = offset;
		bank->sectors[i].size = page_size;
		bank->sectors[i].is_erased = -1;
		bank->sectors[i].is_protected = 0;
		offset += page_size;
	}

	struct numicro_flash_bank *numicro_info = bank->driver_priv;
	numicro_info->probed = true;
	numicro_info->cpu = cpu;
	LOG_DEBUG("Nuvoton NuMicro: Probed ...");

	return ERROR_OK;
}

/* Standard approach to auto-probing. */
static int numicro_auto_probe(struct flash_bank *bank)
{
	struct numicro_flash_bank *numicro_info = bank->driver_priv;
	if (numicro_info->probed)
		return ERROR_OK;
	return numicro_probe(bank);
}

/* This is the function called in the config file. */
FLASH_BANK_COMMAND_HANDLER(numicro_flash_bank_command)
{
	struct numicro_flash_bank *bank_info;

	if (CMD_ARGC < 6)
		return ERROR_COMMAND_SYNTAX_ERROR;

	LOG_DEBUG("add flash_bank numicro %s", bank->name);

	bank_info = malloc(sizeof(struct numicro_flash_bank));

	memset(bank_info, 0, sizeof(struct numicro_flash_bank));

	bank->driver_priv = bank_info;

	return ERROR_OK;
}

COMMAND_HANDLER(numicro_handle_read_isp_command)
{
	uint32_t address;
	uint32_t ispdat;
	int retval = ERROR_OK;

	if (CMD_ARGC != 1)
		return ERROR_COMMAND_SYNTAX_ERROR;

	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address);

	struct target *target = get_current_target(CMD_CTX);

	numicro_get_arm_arch(target);
	retval = numicro_init_isp(target);
	if (retval != ERROR_OK)
		return retval;

	retval = numicro_fmc_cmd(target, ISPCMD_READ, address, 0, &ispdat);
	if (retval != ERROR_OK)
		return retval;

	LOG_INFO("numicro read_isp 0x%08" PRIx32 " 0x%08" PRIx32, address, ispdat);

	return ERROR_OK;
}

COMMAND_HANDLER(numicro_handle_write_isp_command)
{
	uint32_t address;
	uint32_t ispdat, rdat;
	int retval = ERROR_OK;

	if (CMD_ARGC != 2)
		return ERROR_COMMAND_SYNTAX_ERROR;

	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address);
	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], ispdat);

	struct target *target = get_current_target(CMD_CTX);

	numicro_get_arm_arch(target);
	retval = numicro_init_isp(target);
	if (retval != ERROR_OK)
		return retval;

	retval = numicro_fmc_cmd(target, ISPCMD_WRITE, address, ispdat, &rdat);
	if (retval != ERROR_OK)
		return retval;

	LOG_INFO("numicro write_isp 0x%08" PRIx32 " 0x%08" PRIx32, address, ispdat);
	return ERROR_OK;
}

COMMAND_HANDLER(numicro_handle_erase_isp_command)
{
	uint32_t address;
	uint32_t ispdat;
	int retval = ERROR_OK;

	if (CMD_ARGC != 1)
		return ERROR_COMMAND_SYNTAX_ERROR;

	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address);

	struct target *target = get_current_target(CMD_CTX);

	numicro_get_arm_arch(target);
	retval = numicro_init_isp(target);
	if (retval != ERROR_OK)
		return retval;

	retval = numicro_fmc_cmd(target, ISPCMD_ERASE, address, 0, &ispdat);
	if (retval != ERROR_OK)
		return retval;

	LOG_INFO("numicro erase_isp 0x%08" PRIx32 " 0x%08" PRIx32, address, ispdat);

	return ERROR_OK;
}

COMMAND_HANDLER(numicro_handle_chip_erase_command)
{
	int retval = ERROR_OK;
	uint32_t rdat;

	if (CMD_ARGC != 0)
		return ERROR_COMMAND_SYNTAX_ERROR;

	struct target *target = get_current_target(CMD_CTX);

	numicro_get_arm_arch(target);
	retval = numicro_init_isp(target);
	if (retval != ERROR_OK)
		return retval;

	retval = numicro_fmc_cmd(target, ISPCMD_CHIPERASE, 0, 0, &rdat);
	if (retval != ERROR_OK) {
		command_print(CMD_CTX, "numicro chip_erase failed");
		return retval;
	}

	if ((m_flashInfo & NUMICRO_SPROM_MASK) != 0) {
		LOG_DEBUG("SPROM is erasing");
		retval = numicro_fmc_cmd(target, ISPCMD_ERASE, NUMICRO_SPROM_BASE, NUMICRO_SPROM_ISPDAT, &rdat);
		if (retval != ERROR_OK)
			return retval;
	}
	else if ((m_flashInfo & NUMICRO_SPROM_MINI57_MASK) != 0) {
		LOG_DEBUG("SPROM is erasing");
		retval = numicro_fmc_cmd(target, ISPCMD_ERASE, NUMICRO_SPROM_BASE, NUMICRO_SPROM_ISPDAT, &rdat);
		if (retval != ERROR_OK)
			return retval;
		retval = numicro_fmc_cmd(target, ISPCMD_ERASE, NUMICRO_SPROM_BASE2, NUMICRO_SPROM_ISPDAT, &rdat);
		if (retval != ERROR_OK)
			return retval;
		retval = numicro_fmc_cmd(target, ISPCMD_ERASE, NUMICRO_SPROM_BASE3, NUMICRO_SPROM_ISPDAT, &rdat);
		if (retval != ERROR_OK)
			return retval;
	}
	else {
		LOG_DEBUG("SPROM do not exist");
	}

	command_print(CMD_CTX, "numicro chip_erase complete");

	return ERROR_OK;
}

int nulink_usb_M2351_erase(void);
COMMAND_HANDLER(numicro_handle_M2351_erase_command)
{
	int retval = ERROR_OK;

	if (CMD_ARGC != 0)
		return ERROR_COMMAND_SYNTAX_ERROR;

	struct target *target = get_current_target(CMD_CTX);

	numicro_get_arm_arch(target);
	retval = numicro_init_isp(target);
	if (retval != ERROR_OK)
		return retval;

	retval = nulink_usb_M2351_erase();
	if (retval != ERROR_OK) {
		command_print(CMD_CTX, "numicro M2351_erase failed");
		return retval;
	}

	command_print(CMD_CTX, "numicro M2351_erase complete");

	return ERROR_OK;
}

COMMAND_HANDLER(numicro_handle_NUC505_sram_ini_command)
{
	unsigned long address = 0, length = 0;

	if (CMD_ARGC != 2)
		return ERROR_COMMAND_SYNTAX_ERROR;

	struct target *target = get_current_target(CMD_CTX);

	COMMAND_PARSE_NUMBER(ulong, CMD_ARGV[0], address);
	COMMAND_PARSE_NUMBER(ulong, CMD_ARGV[1], length);

	target_write_u32(target, 0x40000050, address);
	target_write_u32(target, 0x40000054, length);
	target_write_u32(target, 0x4000005C, 0x00000001);
	/* cpu reset */
	target_write_u32(target, 0x40000008, 0x00000001);
	/* wait for NUC505 IBR operations */
	busy_sleep(50);

	command_print(CMD_CTX, "numicro NUC505_sram_ini complete");

	return ERROR_OK;
}

COMMAND_HANDLER(numicro_handle_NUC505_chip_reset_command)
{
	if (CMD_ARGC != 0)
		return ERROR_COMMAND_SYNTAX_ERROR;

	struct target *target = get_current_target(CMD_CTX);

	/* cpu reset */
	target_write_u32(target, 0x40000008, 0x00000002);
	/* wait for NUC505 IBR operations */
	busy_sleep(50);

	command_print(CMD_CTX, "numicro NUC505_chip_reset complete");

	return ERROR_OK;
}

static const struct command_registration numicro_exec_command_handlers[] = {
	{
		.name = "read_isp",
		.handler = numicro_handle_read_isp_command,
		.usage = "address",
		.mode = COMMAND_EXEC,
		.help = "read flash through ISP.",
	},
	{
		.name = "write_isp",
		.handler = numicro_handle_write_isp_command,
		.usage = "address value",
		.mode = COMMAND_EXEC,
		.help = "write flash through ISP.",
	},
	{
		.name = "erase_isp",
		.handler = numicro_handle_erase_isp_command,
		.usage = "address",
		.mode = COMMAND_EXEC,
		.help = "erase flash through ISP.",
	},
	{
		.name = "chip_erase",
		.handler = numicro_handle_chip_erase_command,
		.mode = COMMAND_EXEC,
		.help = "chip erase through ISP.",
	},
	{
		.name = "M2351_erase",
		.handler = numicro_handle_M2351_erase_command,
		.mode = COMMAND_EXEC,
		.help = "M2351 erase command.",
	},
	{
		.name = "NUC505_sram_ini",
		.handler = numicro_handle_NUC505_sram_ini_command,
		.mode = COMMAND_EXEC,
		.help = "NUC505 sram initialization command.",
	},
	{
		.name = "NUC505_chip_reset",
		.handler = numicro_handle_NUC505_chip_reset_command,
		.mode = COMMAND_EXEC,
		.help = "NUC505 chip reset command.",
	},
	COMMAND_REGISTRATION_DONE
};

static const struct command_registration numicro_command_handlers[] = {
	{
		.name = "numicro",
		.mode = COMMAND_ANY,
		.help = "numicro flash command group",
		.usage = "",
		.chain = numicro_exec_command_handlers,
	},
	COMMAND_REGISTRATION_DONE
};

struct flash_driver numicro_flash = {
	.name = "numicro",
	.commands = numicro_command_handlers,
	.flash_bank_command = numicro_flash_bank_command,
	.erase = numicro_erase,
	.write = numicro_write,
	.read = default_flash_read,
	.probe = numicro_probe,
	.auto_probe = numicro_auto_probe,
	.erase_check = default_flash_blank_check,
	.protect_check = numicro_protect_check,
};
